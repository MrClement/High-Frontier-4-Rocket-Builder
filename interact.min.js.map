<!DOCTYPE html><html lang="en"><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-140352188-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-140352188-1');</script><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="description" content="The CDN for interactjs"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/><meta name="timestamp" content="2021-02-17T03:12:04.186Z"/><link rel="shortcut icon" href="/favicon.ico"/><title>UNPKG - interactjs</title><script>window.Promise || document.write('\x3Cscript src="/es6-promise@4.2.5/dist/es6-promise.min.js">\x3C/script>\x3Cscript>ES6Promise.polyfill()\x3C/script>')</script><script>window.fetch || document.write('\x3Cscript src="/whatwg-fetch@3.0.0/dist/fetch.umd.js">\x3C/script>')</script><script>window.__DATA__ = {"packageName":"interactjs","packageVersion":"1.10.3","availableVersions":["1.2.7","1.2.8","1.2.9","1.3.0-alpha.0","1.3.0-alpha.1","1.3.0-alpha.2","1.3.0-alpha.3","1.3.0-alpha.5","1.3.0-alpha.6","1.3.0-alpha.7","1.3.0-rc.0","1.3.0-rc.1","1.3.0-rc.2","1.3.0-rc.3","1.3.0-rc.4","1.3.0","1.3.1","1.3.2","1.3.3","1.3.4","1.4.0-alpha.0","1.4.0-alpha.1","1.4.0-alpha.2","1.4.0-alpha.3","1.4.0-alpha.4","1.4.0-alpha.5","1.4.0-alpha.6","1.4.0-alpha.7","1.4.0-alpha.8","1.4.0-alpha.9","1.4.0-alpha.10","1.4.0-alpha.12","1.4.0-alpha.13","1.4.0-alpha.14","1.4.0-alpha.15","1.4.0-alpha.16","1.4.0-alpha.17","1.4.0-alpha.18","1.4.0-alpha.19","1.4.0-alpha.20","1.4.0-alpha.21","1.4.0-alpha.22","1.4.0-alpha.23","1.4.0-alpha.24","1.4.0-alpha.25","1.4.0-alpha.26","1.4.0-alpha.27","1.4.0-alpha.28","1.4.0-alpha.29","1.4.0-alpha.30","1.4.0-alpha.31","1.4.0-alpha.32","1.4.0-alpha.33","1.4.0-beta.0","1.4.0-beta.1","1.4.0-beta.2","1.4.0-beta.3","1.4.0-beta.4","1.4.0-rc.0","1.4.0-rc.1","1.4.0-rc.2","1.4.0-rc.3","1.4.0-rc.4","1.4.0-rc.5","1.4.0-rc.6","1.4.0-rc.7","1.4.0-rc.8","1.4.0-rc.9","1.4.0-rc.10","1.4.0-rc.11","1.4.0-rc.12","1.4.0-rc.13","1.4.0","1.4.1","1.4.2","1.4.3","1.4.4","1.4.5","1.4.6","1.4.7","1.4.8","1.4.9","1.4.10","1.4.11","1.4.12","1.4.13","1.4.14","1.5.0","1.5.1","1.5.2","1.5.3","1.5.4","1.6.0","1.6.1-0","1.6.1","1.6.2","1.6.3","1.7.0","1.7.1","1.7.2","1.7.3","1.8.0-alpha.0","1.8.0-alpha.1","1.8.0-alpha.2","1.8.0-alpha.3","1.8.0-alpha.4","1.8.0-alpha.5","1.8.0-alpha.6","1.8.0-alpha.7","1.8.0-rc.0","1.8.0-rc.1","1.8.0-rc.2","1.8.0-rc.3","1.8.0","1.8.1","1.8.2","1.8.3","1.8.4","1.8.5","1.9.0","1.9.1","1.9.2","1.9.3","1.9.4","1.9.5","1.9.6","1.9.7","1.9.8","1.9.9","1.9.10","1.9.11","1.9.12","1.9.13","1.9.14","1.9.15","1.9.16","1.9.17","1.9.18","1.9.19","1.9.20","1.9.21","1.9.22","1.10.0","1.10.1","1.10.2","1.10.3"],"filename":"/dist/interact.min.js.map","target":{"path":"/dist/interact.min.js.map","type":"file","details":{"contentType":"application/json","integrity":"sha384-NPem/3CGQFr7c57HiubWqEbWn7MkxdcW/2WtNFVVwHJaNScA+p08YAQsoOp5FYbq","language":"Source Map (JSON)","size":394459,"uri":null,"highlights":["{<span class=\"code-attr\">\"version\"</span>:<span class=\"code-number\">3</span>,<span class=\"code-attr\">\"sources\"</span>:[<span class=\"code-string\">\"_header.js\"</span>,<span class=\"code-string\">\"node_modules/browser-pack-flat/_prelude\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/isWindow.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/window.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/is.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/drag/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/domObjects.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/browser.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/domUtils.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/extend.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/rect.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/getOriginXY.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/normalizeListeners.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/hypot.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/pointerExtend.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/pointerUtils.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/BaseEvent.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/arr.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/drop/DropEvent.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/drop/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/gesture/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/resize/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/actions/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/arrange/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/raf.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-scroll/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/misc.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-start/InteractableMethods.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-start/base.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-start/dragAxis.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-start/hold.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/auto-start/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/clone/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/interactablePreventDefault.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/dev-tools/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/utils/clone.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/Modification.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/base.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/defaultOptions.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/InteractEvent.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/PointerInfo.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/Interaction.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/offset/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/inertia/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/Eventable.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/isNonNativeEvent.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/Interactable.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/InteractableSet.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/events.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/interactStatic.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/interactionFinder.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/interactions.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/core/scope.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/interact/index.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/snappers/edgeTarget.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/snappers/elements.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/snappers/grid.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/snappers/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/aspectRatio.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/noop.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/restrict/pointer.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/restrict/edges.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/restrict/rect.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/restrict/size.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/snap/pointer.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/snap/size.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/snap/edges.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/all.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/modifiers/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/pointer-events/PointerEvent.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/pointer-events/base.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/pointer-events/holdRepeat.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/pointer-events/interactableTargets.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/pointer-events/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/reflow/plugin.ts\"</span>,<span class=\"code-string\">\"packages/@interactjs/interactjs/index.ts\"</span>,<span class=\"code-string\">\"packages/interactjs/index.ts\"</span>,<span class=\"code-string\">\"node_modules/browser-pack-flat/_postlude\"</span>],<span class=\"code-attr\">\"names\"</span>:[],<span class=\"code-attr\">\"mappings\"</span>:<span class=\"code-string\">\"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\"</span>,<span class=\"code-attr\">\"file\"</span>:<span class=\"code-string\">\"interact.min.js\"</span>,<span class=\"code-attr\">\"sourceRoot\"</span>:<span class=\"code-string\">\"\"</span>,<span class=\"code-attr\">\"sourcesContent\"</span>:[<span class=\"code-string\">\"/* interact.js 1.10.3 | https://raw.github.com/taye/interact.js/master/LICENSE */\\n\"</span>,<span class=\"code-string\">\"(function(f){if(typeof exports===\\\"object\\\"&amp;&amp;typeof module!==\\\"undefined\\\"){module.exports=f()}else if(typeof define===\\\"function\\\"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==\\\"undefined\\\"){g=window}else if(typeof global!==\\\"undefined\\\"){g=global}else if(typeof self!==\\\"undefined\\\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;\\n\"</span>,<span class=\"code-string\">\"export default (thing: any) =&gt; !!(thing &amp;&amp; thing.Window) &amp;&amp; thing instanceof thing.Window\\n\"</span>,<span class=\"code-string\">\"import isWindow from './isWindow'\\n\\nexport let realWindow = undefined as Window\\n\\nlet win = undefined as Window\\nexport { win as window }\\n\\nexport function init (window: Window &amp; { wrap?: (...args: any[]) =&gt; any }) {\\n  // get wrapped window if using Shadow DOM polyfill\\n\\n  realWindow = window\\n\\n  // create a TextNode\\n  const el = window.document.createTextNode('')\\n\\n  // check if it's wrapped by a polyfill\\n  if (el.ownerDocument !== window.document &amp;&amp; typeof window.wrap === 'function' &amp;&amp; window.wrap(el) === el) {\\n    // use wrapped window\\n    window = window.wrap(window)\\n  }\\n\\n  win = window\\n}\\n\\nif (typeof window !== 'undefined' &amp;&amp; !!window) {\\n  init(window)\\n}\\n\\nexport function getWindow (node: any) {\\n  if (isWindow(node)) {\\n    return node\\n  }\\n\\n  const rootNode = node.ownerDocument || node\\n\\n  return rootNode.defaultView || win.window\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Element } from '@interactjs/types/index'\\n\\nimport isWindow from './isWindow'\\nimport * as win from './window'\\n\\nconst window = (thing: any): thing is Window =&gt; thing === win.window || isWindow(thing)\\n\\nconst docFrag = (thing: any): thing is DocumentFragment =&gt; object(thing) &amp;&amp; thing.nodeType === 11\\n\\nconst object = (thing: any): thing is { [index: string]: any } =&gt; !!thing &amp;&amp; typeof thing === 'object'\\n\\nconst func = (thing: any): thing is (...args: any[]) =&gt; any =&gt; typeof thing === 'function'\\n\\nconst number = (thing: any): thing is number =&gt; typeof thing === 'number'\\n\\nconst bool = (thing: any): thing is boolean =&gt; typeof thing === 'boolean'\\n\\nconst string = (thing: any): thing is string =&gt; typeof thing === 'string'\\n\\nconst element = (thing: any): thing is Element =&gt; {\\n  if (!thing || typeof thing !== 'object') {\\n    return false\\n  }\\n\\n  // eslint-disable-next-line import/no-named-as-default-member\\n  const _window = win.getWindow(thing) || win.window\\n\\n  return /object|function/.test(typeof _window.Element)\\n    ? thing instanceof _window.Element // DOM2\\n    : thing.nodeType === 1 &amp;&amp; typeof thing.nodeName === 'string'\\n}\\n\\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =&gt;\\n  object(thing) &amp;&amp; !!thing.constructor &amp;&amp; /function Object\\\\b/.test(thing.constructor.toString())\\n\\nconst array = &lt;T extends unknown&gt;(thing: any): thing is T[] =&gt;\\n  object(thing) &amp;&amp; typeof thing.length !== 'undefined' &amp;&amp; func(thing.splice)\\n\\nexport default {\\n  window,\\n  docFrag,\\n  object,\\n  func,\\n  number,\\n  bool,\\n  string,\\n  element,\\n  plainObject,\\n  array,\\n}\\n\"</span>,<span class=\"code-string\">\"import type { InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\\nimport is from '@interactjs/utils/is'\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    draggable: DraggableMethod\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface ActionDefaults {\\n    drag: DraggableOptions\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface ActionMap {\\n    drag?: typeof drag\\n  }\\n}\\n\\nexport type DragEvent = InteractEvent&lt;'drag'&gt;\\n\\nexport type DraggableMethod = ActionMethod&lt;DraggableOptions&gt;\\n\\nfunction install (scope: Scope) {\\n  const { actions, Interactable, defaults } = scope\\n\\n  Interactable.prototype.draggable = drag.draggable\\n\\n  actions.map.drag = drag\\n  actions.methodDict.drag = 'draggable'\\n\\n  defaults.actions.drag = drag.defaults\\n}\\n\\nfunction beforeMove ({ interaction }) {\\n  if (interaction.prepared.name !== 'drag') return\\n\\n  const axis = interaction.prepared.axis\\n\\n  if (axis === 'x') {\\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\\n\\n    interaction.coords.velocity.client.y = 0\\n    interaction.coords.velocity.page.y = 0\\n  } else if (axis === 'y') {\\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\\n\\n    interaction.coords.velocity.client.x = 0\\n    interaction.coords.velocity.page.x = 0\\n  }\\n}\\n\\nfunction move ({ iEvent, interaction }) {\\n  if (interaction.prepared.name !== 'drag') return\\n\\n  const axis = interaction.prepared.axis\\n\\n  if (axis === 'x' || axis === 'y') {\\n    const opposite = axis === 'x' ? 'y' : 'x'\\n\\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\\n    iEvent.delta[opposite] = 0\\n  }\\n}\\n\\n/**\\n * ```js\\n * interact(element).draggable({\\n *     onstart: function (event) {},\\n *     onmove : function (event) {},\\n *     onend  : function (event) {},\\n *\\n *     // the axis in which the first movement must be\\n *     // for the drag sequence to start\\n *     // 'xy' by default - any direction\\n *     startAxis: 'x' || 'y' || 'xy',\\n *\\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\\n *     // 'x' or 'y' to restrict movement to either axis\\n *     // 'start' to restrict movement to the axis the drag started in\\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\\n *\\n *     // max number of drags that can happen concurrently\\n *     // with elements of this Interactable. Infinity by default\\n *     max: Infinity,\\n *\\n *     // max number of drags that can target the same element+Interactable\\n *     // 1 by default\\n *     maxPerElement: 2\\n * })\\n *\\n * var isDraggable = interact('element').draggable(); // true\\n * ```\\n *\\n * Get or set whether drag actions can be performed on the target\\n *\\n * @alias Interactable.prototype.draggable\\n *\\n * @param {boolean | object} [options] true/false or An object with event\\n * listeners to be fired on drag events (object makes the Interactable\\n * draggable)\\n * @return {boolean | Interactable} boolean indicating if this can be the\\n * target of drag events, or this Interctable\\n */\\nconst draggable: DraggableMethod = function draggable (\\n  this: Interactable,\\n  options?: DraggableOptions | boolean,\\n): any {\\n  if (is.object(options)) {\\n    this.options.drag.enabled = options.enabled !== false\\n    this.setPerAction('drag', options)\\n    this.setOnEvents('drag', options)\\n\\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\\n      this.options.drag.lockAxis = options.lockAxis\\n    }\\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\\n      this.options.drag.startAxis = options.startAxis\\n    }\\n\\n    return this\\n  }\\n\\n  if (is.bool(options)) {\\n    this.options.drag.enabled = options\\n\\n    return this\\n  }\\n\\n  return this.options.drag\\n}\\n\\nconst drag: Plugin = {\\n  id: 'actions/drag',\\n  install,\\n  listeners: {\\n    'interactions:before-action-move': beforeMove,\\n    'interactions:action-resume': beforeMove,\\n\\n    // dragmove\\n    'interactions:action-move': move,\\n    'auto-start:check': arg =&gt; {\\n      const { interaction, interactable, buttons } = arg\\n      const dragOptions = interactable.options.drag\\n\\n      if (\\n        !(dragOptions &amp;&amp; dragOptions.enabled) ||\\n        // check mouseButton setting if the pointer is down\\n        (interaction.pointerIsDown &amp;&amp;\\n          /mouse|pointer/.test(interaction.pointerType) &amp;&amp;\\n          (buttons &amp; interactable.options.drag.mouseButtons) === 0)\\n      ) {\\n        return undefined\\n      }\\n\\n      arg.action = {\\n        name: 'drag',\\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\\n      }\\n\\n      return false\\n    },\\n  },\\n  draggable,\\n  beforeMove,\\n  move,\\n  defaults: {\\n    startAxis: 'xy',\\n    lockAxis: 'xy',\\n  } as DropzoneOptions,\\n\\n  getCursor () {\\n    return 'move'\\n  },\\n}\\n\\nexport default drag\\n\"</span>,<span class=\"code-string\">\"const domObjects: {\\n  init: any\\n  document: Document\\n  DocumentFragment: typeof DocumentFragment\\n  SVGElement: typeof SVGElement\\n  SVGSVGElement: typeof SVGSVGElement\\n  SVGElementInstance: any\\n  Element: typeof Element\\n  HTMLElement: typeof HTMLElement\\n  Event: typeof Event\\n  Touch: typeof Touch\\n  PointerEvent: typeof PointerEvent\\n} = {\\n  init,\\n  document: null,\\n  DocumentFragment: null,\\n  SVGElement: null,\\n  SVGSVGElement: null,\\n  SVGElementInstance: null,\\n  Element: null,\\n  HTMLElement: null,\\n  Event: null,\\n  Touch: null,\\n  PointerEvent: null,\\n}\\n\\nfunction blank () {}\\n\\nexport default domObjects\\n\\nfunction init (window: Window) {\\n  const win = window as any\\n\\n  domObjects.document = win.document\\n  domObjects.DocumentFragment = win.DocumentFragment || blank\\n  domObjects.SVGElement = win.SVGElement || blank\\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\\n  domObjects.Element = win.Element || blank\\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\\n\\n  domObjects.Event = win.Event\\n  domObjects.Touch = win.Touch || blank\\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\\n}\\n\"</span>,<span class=\"code-string\">\"import domObjects from './domObjects'\\nimport is from './is'\\nimport * as win from './window'\\n\\nconst browser = {\\n  init,\\n  supportsTouch: null as boolean,\\n  supportsPointerEvent: null as boolean,\\n  isIOS7: null as boolean,\\n  isIOS: null as boolean,\\n  isIe9: null as boolean,\\n  isOperaMobile: null as boolean,\\n  prefixedMatchesSelector: null as 'matches',\\n  pEventTypes: null as {\\n    up: string\\n    down: string\\n    over: string\\n    out: string\\n    move: string\\n    cancel: string\\n  },\\n  wheelEvent: null as string,\\n}\\n\\nfunction init (window: any) {\\n  const Element = domObjects.Element\\n  const navigator = win.window.navigator\\n\\n  // Does the browser support touch input?\\n  browser.supportsTouch =\\n    'ontouchstart' in window ||\\n    (is.func(window.DocumentTouch) &amp;&amp; domObjects.document instanceof window.DocumentTouch)\\n\\n  // Does the browser support PointerEvents\\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false &amp;&amp; !!domObjects.PointerEvent\\n\\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\\n\\n  // scrolling doesn't change the result of getClientRects on iOS 7\\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) &amp;&amp; /OS 7[^\\\\d]/.test(navigator.appVersion)\\n\\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\\n\\n  // Opera Mobile must be handled differently\\n  browser.isOperaMobile =\\n    navigator.appName === 'Opera' &amp;&amp; browser.supportsTouch &amp;&amp; /Presto/.test(navigator.userAgent)\\n\\n  // prefix matchesSelector\\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\\n    ? 'matches'\\n    : 'webkitMatchesSelector' in Element.prototype\\n      ? 'webkitMatchesSelector'\\n      : 'mozMatchesSelector' in Element.prototype\\n        ? 'mozMatchesSelector'\\n        : 'oMatchesSelector' in Element.prototype\\n          ? 'oMatchesSelector'\\n          : 'msMatchesSelector') as 'matches'\\n\\n  browser.pEventTypes = browser.supportsPointerEvent\\n    ? domObjects.PointerEvent === window.MSPointerEvent\\n      ? {\\n        up: 'MSPointerUp',\\n        down: 'MSPointerDown',\\n        over: 'mouseover',\\n        out: 'mouseout',\\n        move: 'MSPointerMove',\\n        cancel: 'MSPointerCancel',\\n      }\\n      : {\\n        up: 'pointerup',\\n        down: 'pointerdown',\\n        over: 'pointerover',\\n        out: 'pointerout',\\n        move: 'pointermove',\\n        cancel: 'pointercancel',\\n      }\\n    : null\\n\\n  // because Webkit and Opera still use 'mousewheel' event type\\n  browser.wheelEvent = 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\\n}\\n\\nexport default browser\\n\"</span>,<span class=\"code-string\">\"import type { Rect, Target, Element } from '@interactjs/types/index'\\n\\nimport browser from './browser'\\nimport domObjects from './domObjects'\\nimport is from './is'\\nimport * as win from './window'\\n\\nexport function nodeContains (parent: Node, child: Node) {\\n  if (parent.contains) {\\n    return parent.contains(child as Node)\\n  }\\n\\n  while (child) {\\n    if (child === parent) {\\n      return true\\n    }\\n\\n    child = (child as Node).parentNode\\n  }\\n\\n  return false\\n}\\n\\nexport function closest (element: Node, selector: string) {\\n  while (is.element(element)) {\\n    if (matchesSelector(element, selector)) {\\n      return element\\n    }\\n\\n    element = parentNode(element)\\n  }\\n\\n  return null\\n}\\n\\nexport function parentNode (node: Node | Document) {\\n  let parent = node.parentNode\\n\\n  if (is.docFrag(parent)) {\\n    // skip past #shado-root fragments\\n    // tslint:disable-next-line\\n    while ((parent = (parent as any).host) &amp;&amp; is.docFrag(parent)) {\\n      continue\\n    }\\n\\n    return parent\\n  }\\n\\n  return parent\\n}\\n\\nexport function matchesSelector (element: Element, selector: string) {\\n  // remove /deep/ from selectors if shadowDOM polyfill is used\\n  if (win.window !== win.realWindow) {\\n    selector = selector.replace(/\\\\/deep\\\\//g, ' ')\\n  }\\n\\n  return element[browser.prefixedMatchesSelector](selector)\\n}\\n\\nconst getParent = (el: Node | Document | ShadowRoot) =&gt; el.parentNode || (el as ShadowRoot).host\\n\\n// Test for the element that's \\\"above\\\" all other qualifiers\\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf&lt;globalThis.Element&gt;) {\\n  let deepestNodeParents: Node[] = []\\n  let deepestNodeIndex: number\\n\\n  for (let i = 0; i &lt; elements.length; i++) {\\n    const currentNode = elements[i]\\n    const deepestNode: Node = elements[deepestNodeIndex]\\n\\n    // node may appear in elements array multiple times\\n    if (!currentNode || i === deepestNodeIndex) {\\n      continue\\n    }\\n\\n    if (!deepestNode) {\\n      deepestNodeIndex = i\\n      continue\\n    }\\n\\n    const currentNodeParent = getParent(currentNode)\\n    const deepestNodeParent = getParent(deepestNode)\\n\\n    // check if the deepest or current are document.documentElement/rootElement\\n    // - if the current node is, do nothing and continue\\n    if (currentNodeParent === currentNode.ownerDocument) {\\n      continue\\n    }\\n    // - if deepest is, update with the current node and continue to next\\n    else if (deepestNodeParent === currentNode.ownerDocument) {\\n      deepestNodeIndex = i\\n      continue\\n    }\\n\\n    // compare zIndex of siblings\\n    if (currentNodeParent === deepestNodeParent) {\\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\\n        deepestNodeIndex = i\\n      }\\n\\n      continue\\n    }\\n\\n    // populate the ancestry array for the latest deepest node\\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\\n\\n    let ancestryStart: Node\\n\\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\\n    if (\\n      deepestNode instanceof domObjects.HTMLElement &amp;&amp;\\n      currentNode instanceof domObjects.SVGElement &amp;&amp;\\n      !(currentNode instanceof domObjects.SVGSVGElement)\\n    ) {\\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\\n      if (currentNode === deepestNodeParent) {\\n        continue\\n      }\\n\\n      ancestryStart = currentNode.ownerSVGElement\\n    } else {\\n      ancestryStart = currentNode\\n    }\\n\\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\\n    let commonIndex = 0\\n\\n    // get (position of closest common ancestor) + 1\\n    while (\\n      currentNodeParents[commonIndex] &amp;&amp;\\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\\n    ) {\\n      commonIndex++\\n    }\\n\\n    const parents = [\\n      currentNodeParents[commonIndex - 1],\\n      currentNodeParents[commonIndex],\\n      deepestNodeParents[commonIndex],\\n    ]\\n\\n    let child = parents[0].lastChild\\n\\n    while (child) {\\n      if (child === parents[1]) {\\n        deepestNodeIndex = i\\n        deepestNodeParents = currentNodeParents\\n\\n        break\\n      } else if (child === parents[2]) {\\n        break\\n      }\\n\\n      child = child.previousSibling\\n    }\\n  }\\n\\n  return deepestNodeIndex\\n}\\n\\nfunction getNodeParents (node: Node, limit?: Node) {\\n  const parents: Node[] = []\\n  let parent: Node = node\\n  let parentParent: Node\\n\\n  while ((parentParent = getParent(parent)) &amp;&amp; parent !== limit &amp;&amp; parentParent !== parent.ownerDocument) {\\n    parents.unshift(parent)\\n    parent = parentParent\\n  }\\n\\n  return parents\\n}\\n\\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\\n\\n  return higherIndex &gt;= lowerIndex\\n}\\n\\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\\n  while (is.element(element)) {\\n    if (matchesSelector(element, selector)) {\\n      return true\\n    }\\n\\n    element = parentNode(element) as Element\\n\\n    if (element === limit) {\\n      return matchesSelector(element, selector)\\n    }\\n  }\\n\\n  return false\\n}\\n\\nexport function getActualElement (element: Element) {\\n  return (element as SVGElement).correspondingUseElement || element\\n}\\n\\nexport function getScrollXY (relevantWindow?: Window) {\\n  relevantWindow = relevantWindow || win.window\\n  return {\\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\\n  }\\n}\\n\\nexport function getElementClientRect (element: Element): Required&lt;Rect&gt; {\\n  const clientRect =\\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\\n\\n  return (\\n    clientRect &amp;&amp; {\\n      left: clientRect.left,\\n      right: clientRect.right,\\n      top: clientRect.top,\\n      bottom: clientRect.bottom,\\n      width: clientRect.width || clientRect.right - clientRect.left,\\n      height: clientRect.height || clientRect.bottom - clientRect.top,\\n    }\\n  )\\n}\\n\\nexport function getElementRect (element: Element) {\\n  const clientRect = getElementClientRect(element)\\n\\n  if (!browser.isIOS7 &amp;&amp; clientRect) {\\n    const scroll = getScrollXY(win.getWindow(element))\\n\\n    clientRect.left += scroll.x\\n    clientRect.right += scroll.x\\n    clientRect.top += scroll.y\\n    clientRect.bottom += scroll.y\\n  }\\n\\n  return clientRect\\n}\\n\\nexport function getPath (node: Node | Document) {\\n  const path = []\\n\\n  while (node) {\\n    path.push(node)\\n    node = parentNode(node)\\n  }\\n\\n  return path\\n}\\n\\nexport function trySelector (value: Target) {\\n  if (!is.string(value)) {\\n    return false\\n  }\\n\\n  // an exception will be raised if it is invalid\\n  domObjects.document.querySelector(value)\\n  return true\\n}\\n\"</span>,<span class=\"code-string\">\"export default function extend&lt;T, U extends object&gt; (dest: U &amp; Partial&lt;T&gt;, source: T): T &amp; U {\\n  for (const prop in source) {\\n    ;((dest as unknown) as T)[prop] = source[prop]\\n  }\\n\\n  const ret = dest as T &amp; U\\n\\n  return ret\\n}\\n\"</span>,<span class=\"code-string\">\"import type { HasGetRect, RectResolvable, Rect, Element, Point, FullRect, EdgeOptions } from '../types'\\n\\nimport { closest, getElementRect, parentNode } from './domUtils'\\nimport extend from './extend'\\nimport is from './is'\\n\\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\\n  if (value === 'parent') {\\n    return parentNode(element)\\n  }\\n\\n  if (value === 'self') {\\n    return target.getRect(element as Element)\\n  }\\n\\n  return closest(element, value)\\n}\\n\\nexport function resolveRectLike&lt;T extends any[]&gt; (\\n  value: RectResolvable&lt;T&gt;,\\n  target?: HasGetRect,\\n  element?: Node,\\n  functionArgs?: T,\\n) {\\n  let returnValue: any = value\\n  if (is.string(returnValue)) {\\n    returnValue = getStringOptionResult(returnValue, target, element)\\n  } else if (is.func(returnValue)) {\\n    returnValue = returnValue(...functionArgs)\\n  }\\n\\n  if (is.element(returnValue)) {\\n    returnValue = getElementRect(returnValue)\\n  }\\n\\n  return returnValue as Rect\\n}\\n\\nexport function rectToXY (rect: Rect | Point) {\\n  return (\\n    rect &amp;&amp; {\\n      x: 'x' in rect ? rect.x : rect.left,\\n      y: 'y' in rect ? rect.y : rect.top,\\n    }\\n  )\\n}\\n\\nexport function xywhToTlbr&lt;T extends Partial&lt;Rect &amp; Point&gt;&gt; (rect: T) {\\n  if (rect &amp;&amp; !('left' in rect &amp;&amp; 'top' in rect)) {\\n    rect = extend({}, rect)\\n\\n    rect.left = rect.x || 0\\n    rect.top = rect.y || 0\\n    rect.right = rect.right || rect.left + rect.width\\n    rect.bottom = rect.bottom || rect.top + rect.height\\n  }\\n\\n  return rect as Rect &amp; T\\n}\\n\\nexport function tlbrToXywh (rect: Rect &amp; Partial&lt;Point&gt;) {\\n  if (rect &amp;&amp; !('x' in rect &amp;&amp; 'y' in rect)) {\\n    rect = extend({}, rect)\\n\\n    rect.x = rect.left || 0\\n    rect.y = rect.top || 0\\n    rect.width = rect.width || (rect.right || 0) - rect.x\\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\\n  }\\n\\n  return rect as FullRect &amp; Point\\n}\\n\\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\\n  if (edges.left) {\\n    rect.left += delta.x\\n  }\\n  if (edges.right) {\\n    rect.right += delta.x\\n  }\\n  if (edges.top) {\\n    rect.top += delta.y\\n  }\\n  if (edges.bottom) {\\n    rect.bottom += delta.y\\n  }\\n\\n  rect.width = rect.right - rect.left\\n  rect.height = rect.bottom - rect.top\\n}\\n\"</span>,<span class=\"code-string\">\"import type { PerActionDefaults } from '@interactjs/core/defaultOptions'\\nimport type { ActionName } from '@interactjs/core/scope'\\nimport type { HasGetRect } from '@interactjs/types/index'\\n\\nimport { rectToXY, resolveRectLike } from './rect'\\n\\nexport default function (\\n  target: HasGetRect &amp; { options: PerActionDefaults },\\n  element: Node,\\n  actionName?: ActionName,\\n) {\\n  const actionOptions = (target.options as any)[actionName]\\n  const actionOrigin = actionOptions &amp;&amp; actionOptions.origin\\n  const origin = actionOrigin || target.options.origin\\n\\n  const originRect = resolveRectLike(origin, target, element, [target &amp;&amp; element])\\n\\n  return rectToXY(originRect) || { x: 0, y: 0 }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { EventTypes, Listener, ListenersArg } from '@interactjs/types/index'\\n\\nimport extend from './extend'\\nimport is from './is'\\n\\nexport interface NormalizedListeners {\\n  [type: string]: Listener[]\\n}\\n\\nexport default function normalize (\\n  type: EventTypes,\\n  listeners?: ListenersArg | ListenersArg[],\\n  result?: NormalizedListeners,\\n): NormalizedListeners {\\n  result = result || {}\\n\\n  if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\\n    type = split(type)\\n  }\\n\\n  if (is.array(type)) {\\n    return type.reduce&lt;NormalizedListeners&gt;((acc, t) =&gt; extend(acc, normalize(t, listeners, result)), result)\\n  }\\n\\n  // ({ type: fn }) -&gt; ('', { type: fn })\\n  if (is.object(type)) {\\n    listeners = type\\n    type = ''\\n  }\\n\\n  if (is.func(listeners)) {\\n    result[type] = result[type] || []\\n    result[type].push(listeners)\\n  } else if (is.array(listeners)) {\\n    for (const l of listeners) {\\n      normalize(type, l, result)\\n    }\\n  } else if (is.object(listeners)) {\\n    for (const prefix in listeners) {\\n      const combinedTypes = split(prefix).map(p =&gt; `${type}${p}`)\\n\\n      normalize(combinedTypes, listeners[prefix], result)\\n    }\\n  }\\n\\n  return result as NormalizedListeners\\n}\\n\\nfunction split (type: string) {\\n  return type.trim().split(/ +/)\\n}\\n\"</span>,<span class=\"code-string\">\"export default (x: number, y: number) =&gt; Math.sqrt(x * x + y * y)\\n\"</span>,<span class=\"code-string\">\"function pointerExtend&lt;T&gt; (dest: Partial&lt;T&gt;, source: T) {\\n  for (const prop in source) {\\n    const prefixedPropREs = pointerExtend.prefixedPropREs\\n    let deprecated = false\\n\\n    // skip deprecated prefixed properties\\n    for (const vendor in prefixedPropREs) {\\n      if (prop.indexOf(vendor) === 0 &amp;&amp; prefixedPropREs[vendor].test(prop)) {\\n        deprecated = true\\n        break\\n      }\\n    }\\n\\n    if (!deprecated &amp;&amp; typeof source[prop] !== 'function') {\\n      dest[prop] = source[prop]\\n    }\\n  }\\n  return dest\\n}\\n\\npointerExtend.prefixedPropREs = {\\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\\n  moz: /(Pressure)$/,\\n} as { [prefix: string]: RegExp }\\n\\nexport default pointerExtend\\n\"</span>,<span class=\"code-string\">\"import type { InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/types/index'\\n\\nimport browser from './browser'\\nimport dom from './domObjects'\\nimport * as domUtils from './domUtils'\\nimport hypot from './hypot'\\nimport is from './is'\\nimport pointerExtend from './pointerExtend'\\n\\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\\n  dest.page = dest.page || ({} as any)\\n  dest.page.x = src.page.x\\n  dest.page.y = src.page.y\\n\\n  dest.client = dest.client || ({} as any)\\n  dest.client.x = src.client.x\\n  dest.client.y = src.client.y\\n\\n  dest.timeStamp = src.timeStamp\\n}\\n\\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\\n  targetObj.page.x = cur.page.x - prev.page.x\\n  targetObj.page.y = cur.page.y - prev.page.y\\n  targetObj.client.x = cur.client.x - prev.client.x\\n  targetObj.client.y = cur.client.y - prev.client.y\\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\\n}\\n\\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\\n\\n  targetObj.page.x = delta.page.x / dt\\n  targetObj.page.y = delta.page.y / dt\\n  targetObj.client.x = delta.client.x / dt\\n  targetObj.client.y = delta.client.y / dt\\n  targetObj.timeStamp = dt\\n}\\n\\nexport function setZeroCoords (targetObj: CoordsSetMember) {\\n  targetObj.page.x = 0\\n  targetObj.page.y = 0\\n  targetObj.client.x = 0\\n  targetObj.client.y = 0\\n}\\n\\nexport function isNativePointer (pointer: any) {\\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\\n}\\n\\n// Get specified X/Y coords for mouse or event.touches[0]\\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\\n  xy = xy || ({} as Point)\\n  type = type || 'page'\\n\\n  xy.x = pointer[(type + 'X') as keyof PointerType]\\n  xy.y = pointer[(type + 'Y') as keyof PointerType]\\n\\n  return xy\\n}\\n\\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\\n  page = page || { x: 0, y: 0 }\\n\\n  // Opera Mobile handles the viewport and scrolling oddly\\n  if (browser.isOperaMobile &amp;&amp; isNativePointer(pointer)) {\\n    getXY('screen', pointer, page)\\n\\n    page.x += window.scrollX\\n    page.y += window.scrollY\\n  } else {\\n    getXY('page', pointer, page)\\n  }\\n\\n  return page\\n}\\n\\nexport function getClientXY (pointer: PointerType, client: Point) {\\n  client = client || ({} as any)\\n\\n  if (browser.isOperaMobile &amp;&amp; isNativePointer(pointer)) {\\n    // Opera Mobile handles the viewport and scrolling oddly\\n    getXY('screen', pointer, client)\\n  } else {\\n    getXY('client', pointer, client)\\n  }\\n\\n  return client\\n}\\n\\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\\n}\\n\\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\\n  const pointer = pointers.length &gt; 1 ? pointerAverage(pointers) : pointers[0]\\n\\n  getPageXY(pointer, dest.page)\\n  getClientXY(pointer, dest.client)\\n\\n  dest.timeStamp = timeStamp\\n}\\n\\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\\n  const touches: PointerType[] = []\\n\\n  // array of touches is supplied\\n  if (is.array(event)) {\\n    touches[0] = event[0]\\n    touches[1] = event[1]\\n  }\\n  // an event\\n  else {\\n    if (event.type === 'touchend') {\\n      if (event.touches.length === 1) {\\n        touches[0] = event.touches[0]\\n        touches[1] = event.changedTouches[0]\\n      } else if (event.touches.length === 0) {\\n        touches[0] = event.changedTouches[0]\\n        touches[1] = event.changedTouches[1]\\n      }\\n    } else {\\n      touches[0] = event.touches[0]\\n      touches[1] = event.touches[1]\\n    }\\n  }\\n\\n  return touches\\n}\\n\\nexport function pointerAverage (pointers: PointerType[]) {\\n  const average = {\\n    pageX: 0,\\n    pageY: 0,\\n    clientX: 0,\\n    clientY: 0,\\n    screenX: 0,\\n    screenY: 0,\\n  }\\n\\n  type CoordKeys = keyof typeof average\\n\\n  for (const pointer of pointers) {\\n    for (const prop in average) {\\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\\n    }\\n  }\\n  for (const prop in average) {\\n    average[prop as CoordKeys] /= pointers.length\\n  }\\n\\n  return average\\n}\\n\\nexport function touchBBox (event: PointerType[]) {\\n  if (!event.length) {\\n    return null\\n  }\\n\\n  const touches = getTouchPair(event)\\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\\n\\n  return {\\n    x: minX,\\n    y: minY,\\n    left: minX,\\n    top: minY,\\n    right: maxX,\\n    bottom: maxY,\\n    width: maxX - minX,\\n    height: maxY - minY,\\n  }\\n}\\n\\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\\n  const sourceX = (deltaSource + 'X') as 'pageX'\\n  const sourceY = (deltaSource + 'Y') as 'pageY'\\n  const touches = getTouchPair(event)\\n\\n  const dx = touches[0][sourceX] - touches[1][sourceX]\\n  const dy = touches[0][sourceY] - touches[1][sourceY]\\n\\n  return hypot(dx, dy)\\n}\\n\\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\\n  const sourceX = (deltaSource + 'X') as 'pageX'\\n  const sourceY = (deltaSource + 'Y') as 'pageY'\\n  const touches = getTouchPair(event)\\n  const dx = touches[1][sourceX] - touches[0][sourceX]\\n  const dy = touches[1][sourceY] - touches[0][sourceY]\\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\\n\\n  return angle\\n}\\n\\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\\n  return is.string(pointer.pointerType)\\n    ? pointer.pointerType\\n    : is.number(pointer.pointerType)\\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\\n      : // if the PointerEvent API isn't available, then the \\\"pointer\\\" must\\n    // be either a MouseEvent, TouchEvent, or Touch object\\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\\n        ? 'touch'\\n        : 'mouse'\\n}\\n\\n// [ event.target, event.currentTarget ]\\nexport function getEventTargets (event: Event) {\\n  const path = is.func(event.composedPath)\\n    ? (event.composedPath() as Element[])\\n    : ((event as unknown) as { path: Element[] }).path\\n\\n  return [\\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\\n    domUtils.getActualElement(event.currentTarget as Element),\\n  ]\\n}\\n\\nexport function newCoords (): CoordsSetMember {\\n  return {\\n    page: { x: 0, y: 0 },\\n    client: { x: 0, y: 0 },\\n    timeStamp: 0,\\n  }\\n}\\n\\nexport function coordsToEvent (coords: MockCoords) {\\n  const event = {\\n    coords,\\n    get page () {\\n      return this.coords.page\\n    },\\n    get client () {\\n      return this.coords.client\\n    },\\n    get timeStamp () {\\n      return this.coords.timeStamp\\n    },\\n    get pageX () {\\n      return this.coords.page.x\\n    },\\n    get pageY () {\\n      return this.coords.page.y\\n    },\\n    get clientX () {\\n      return this.coords.client.x\\n    },\\n    get clientY () {\\n      return this.coords.client.y\\n    },\\n    get pointerId () {\\n      return this.coords.pointerId\\n    },\\n    get target () {\\n      return this.coords.target\\n    },\\n    get type () {\\n      return this.coords.type\\n    },\\n    get pointerType () {\\n      return this.coords.pointerType\\n    },\\n    get buttons () {\\n      return this.coords.buttons\\n    },\\n    preventDefault () {},\\n  }\\n\\n  return event as typeof event &amp; PointerType &amp; PointerEventType\\n}\\n\\nexport interface MockCoords {\\n  page: Point\\n  client: Point\\n  timeStamp?: number\\n  pointerId?: any\\n  target?: any\\n  type?: string\\n  pointerType?: string\\n  buttons?: number\\n}\\n\\nexport { pointerExtend }\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\\nimport type { ActionName } from '@interactjs/core/scope'\\n\\nexport class BaseEvent&lt;T extends ActionName | null = never&gt; {\\n  type: string\\n  target: EventTarget\\n  currentTarget: Node\\n  interactable: Interactable\\n  _interaction: Interaction&lt;T&gt;\\n  timeStamp: any\\n  immediatePropagationStopped = false\\n  propagationStopped = false\\n\\n  constructor (interaction: Interaction&lt;T&gt;) {\\n    this._interaction = interaction\\n  }\\n\\n  preventDefault () {}\\n\\n  /**\\n   * Don't call any other listeners (even on the current target)\\n   */\\n  stopPropagation () {\\n    this.propagationStopped = true\\n  }\\n\\n  /**\\n   * Don't call listeners on the remaining targets\\n   */\\n  stopImmediatePropagation () {\\n    this.immediatePropagationStopped = this.propagationStopped = true\\n  }\\n}\\n\\n// defined outside of class definition to avoid assignment of undefined during\\n// construction\\nexport interface BaseEvent&lt;T extends ActionName&gt; {\\n  interaction: InteractionProxy&lt;T&gt;\\n}\\n\\n// getters and setters defined here to support typescript 3.6 and below which\\n// don't support getter and setters in .d.ts files\\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\\n  get (this: BaseEvent) {\\n    return this._interaction._proxy\\n  },\\n  set (this: BaseEvent) {},\\n})\\n\"</span>,<span class=\"code-string\">\"type Filter&lt;T&gt; = (element: T, index: number, array: T[]) =&gt; boolean\\n\\nexport const contains = &lt;T&gt;(array: T[], target: T) =&gt; array.indexOf(target) !== -1\\n\\nexport const remove = &lt;T&gt;(array: T[], target: T) =&gt; array.splice(array.indexOf(target), 1)\\n\\nexport const merge = &lt;T, U&gt;(target: Array&lt;T | U&gt;, source: U[]) =&gt; {\\n  for (const item of source) {\\n    target.push(item)\\n  }\\n\\n  return target\\n}\\n\\nexport const from = &lt;T = any&gt;(source: ArrayLike&lt;T&gt;) =&gt; merge([] as T[], source as T[])\\n\\nexport const findIndex = &lt;T&gt;(array: T[], func: Filter&lt;T&gt;) =&gt; {\\n  for (let i = 0; i &lt; array.length; i++) {\\n    if (func(array[i], i, array)) {\\n      return i\\n    }\\n  }\\n\\n  return -1\\n}\\n\\nexport const find = &lt;T = any&gt;(array: T[], func: Filter&lt;T&gt;) =&gt; array[findIndex(array, func)]\\n\"</span>,<span class=\"code-string\">\"import { BaseEvent } from '@interactjs/core/BaseEvent'\\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Element } from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\n\\nimport type { DropState } from './plugin'\\n\\nexport class DropEvent extends BaseEvent&lt;'drag'&gt; {\\n  target: Element\\n  dropzone: Interactable\\n  dragEvent: InteractEvent&lt;'drag'&gt;\\n  relatedTarget: Element\\n  draggable: Interactable\\n  timeStamp: number\\n  propagationStopped = false\\n  immediatePropagationStopped = false\\n\\n  /**\\n   * Class of events fired on dropzones during drags with acceptable targets.\\n   */\\n  constructor (dropState: DropState, dragEvent: InteractEvent&lt;'drag'&gt;, type: string) {\\n    super(dragEvent._interaction)\\n\\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\\n\\n    this.type = type\\n    this.target = element\\n    this.currentTarget = element\\n    this.dropzone = dropzone\\n    this.dragEvent = dragEvent\\n    this.relatedTarget = dragEvent.target\\n    this.draggable = dragEvent.interactable\\n    this.timeStamp = dragEvent.timeStamp\\n  }\\n\\n  /**\\n   * If this is a `dropactivate` event, the dropzone element will be\\n   * deactivated.\\n   *\\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\\n   * dropzone element and more.\\n   */\\n  reject () {\\n    const { dropState } = this._interaction\\n\\n    if (\\n      this.type !== 'dropactivate' &amp;&amp;\\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\\n    ) {\\n      return\\n    }\\n\\n    dropState.prev.dropzone = this.dropzone\\n    dropState.prev.element = this.target\\n\\n    dropState.rejected = true\\n    dropState.events.enter = null\\n\\n    this.stopImmediatePropagation()\\n\\n    if (this.type === 'dropactivate') {\\n      const activeDrops = dropState.activeDrops\\n      const index = arr.findIndex(\\n        activeDrops,\\n        ({ dropzone, element }) =&gt; dropzone === this.dropzone &amp;&amp; element === this.target,\\n      )\\n\\n      dropState.activeDrops.splice(index, 1)\\n\\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\\n\\n      deactivateEvent.dropzone = this.dropzone\\n      deactivateEvent.target = this.target\\n\\n      this.dropzone.fire(deactivateEvent)\\n    } else {\\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\\n    }\\n  }\\n\\n  preventDefault () {}\\n\\n  stopPropagation () {\\n    this.propagationStopped = true\\n  }\\n\\n  stopImmediatePropagation () {\\n    this.immediatePropagationStopped = this.propagationStopped = true\\n  }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { DropzoneOptions, Element, PointerEventType, Rect } from '@interactjs/types/index'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport getOriginXY from '@interactjs/utils/getOriginXY'\\nimport is from '@interactjs/utils/is'\\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\nimport type { DragEvent } from '../drag/plugin'\\nimport drag from '../drag/plugin'\\n\\nimport { DropEvent } from './DropEvent'\\n\\nexport interface DropzoneMethod {\\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\\n  (): DropzoneOptions\\n}\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    dropzone: DropzoneMethod\\n    dropCheck: (\\n      dragEvent: InteractEvent,\\n      event: PointerEventType,\\n      draggable: Interactable,\\n      draggableElement: Element,\\n      dropElemen: Element,\\n      rect: any,\\n    ) =&gt; boolean\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    dropState?: DropState\\n  }\\n}\\n\\ndeclare module '@interactjs/core/InteractEvent' {\\n  interface InteractEvent {\\n    prevDropzone?: Interactable\\n    dropzone?: Interactable\\n    dragEnter?: Element\\n    dragLeave?: Element\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface ActionDefaults {\\n    drop: DropzoneOptions\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface ActionMap {\\n    drop?: typeof drop\\n  }\\n\\n  interface Scope {\\n    dynamicDrop?: boolean\\n  }\\n\\n  interface SignalArgs {\\n    'actions/drop:start': DropSignalArg\\n    'actions/drop:move': DropSignalArg\\n    'actions/drop:end': DropSignalArg\\n  }\\n}\\n\\ndeclare module '@interactjs/core/interactStatic' {\\n  export interface InteractStatic {\\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) =&gt; boolean | this\\n  }\\n}\\n\\ninterface DropSignalArg {\\n  interaction: Interaction&lt;'drag'&gt;\\n  dragEvent: DragEvent\\n}\\n\\nexport interface ActiveDrop {\\n  dropzone: Interactable\\n  element: Element\\n  rect: Rect\\n}\\n\\nexport interface DropState {\\n  cur: {\\n    // the dropzone a drag target might be dropped into\\n    dropzone: Interactable\\n    // the element at the time of checking\\n    element: Element\\n  }\\n  prev: {\\n    // the dropzone that was recently dragged away from\\n    dropzone: Interactable\\n    // the element at the time of checking\\n    element: Element\\n  }\\n  // wheather the potential drop was rejected from a listener\\n  rejected: boolean\\n  // the drop events related to the current drag event\\n  events: FiredDropEvents\\n  activeDrops: ActiveDrop[]\\n}\\n\\nfunction install (scope: Scope) {\\n  const {\\n    actions,\\n    /** @lends module:interact */\\n    interactStatic: interact,\\n    /** @lends Interactable */\\n    Interactable,\\n    defaults,\\n  } = scope\\n\\n  scope.usePlugin(drag)\\n\\n  /**\\n   *\\n   * ```js\\n   * interact('.drop').dropzone({\\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\\n   *   overlap: 'pointer' || 'center' || zeroToOne\\n   * }\\n   * ```\\n   *\\n   * Returns or sets whether draggables can be dropped onto this target to\\n   * trigger drop events\\n   *\\n   * Dropzones can receive the following events:\\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\\n   *  - `drop` when a draggable is dropped into this dropzone\\n   *\\n   * Use the `accept` option to allow only elements that match the given CSS\\n   * selector or element. The value can be:\\n   *\\n   *  - **an Element** - only that element can be dropped into this dropzone.\\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\\n   *  - **`null`** - accept options is cleared - it accepts any element.\\n   *\\n   * Use the `overlap` option to set how drops are checked for. The allowed\\n   * values are:\\n   *\\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\\n   *   - `'center'`, the draggable element's center must be over the dropzone\\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\\n   *   over the dropzone\\n   *\\n   * Use the `checker` option to specify a function to check if a dragged element\\n   * is over this Interactable.\\n   *\\n   * @param {boolean | object | null} [options] The new options to be set.\\n   * @return {object | Interactable} The current setting or this Interactable\\n   */\\n  Interactable.prototype.dropzone = function (this: Interactable, options?: DropzoneOptions | boolean) {\\n    return dropzoneMethod(this, options)\\n  } as Interactable['dropzone']\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\\n   *                       dropped,           // bool result of the default checker\\n   *                       dropzone,          // dropzone Interactable\\n   *                       dropElement,       // dropzone elemnt\\n   *                       draggable,         // draggable Interactable\\n   *                       draggableElement) {// draggable element\\n   *\\n   *   return dropped &amp;&amp; event.target.hasAttribute('allow-drop')\\n   * }\\n   * ```\\n   */\\n  Interactable.prototype.dropCheck = function (\\n    this: Interactable,\\n    dragEvent,\\n    event,\\n    draggable,\\n    draggableElement,\\n    dropElement,\\n    rect,\\n  ) {\\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\\n  }\\n\\n  /**\\n   * Returns or sets whether the dimensions of dropzone elements are calculated\\n   * on every dragmove or only on dragstart for the default dropChecker\\n   *\\n   * @param {boolean} [newValue] True to check on each move. False to check only\\n   * before start\\n   * @return {boolean | interact} The current setting or interact\\n   */\\n  interact.dynamicDrop = function (newValue?: boolean) {\\n    if (is.bool(newValue)) {\\n      // if (dragging &amp;&amp; scope.dynamicDrop !== newValue &amp;&amp; !newValue) {\\n      //  calcRects(dropzones)\\n      // }\\n\\n      scope.dynamicDrop = newValue\\n\\n      return interact\\n    }\\n    return scope.dynamicDrop\\n  }\\n\\n  extend(actions.phaselessTypes, {\\n    dragenter: true,\\n    dragleave: true,\\n    dropactivate: true,\\n    dropdeactivate: true,\\n    dropmove: true,\\n    drop: true,\\n  })\\n  actions.methodDict.drop = 'dropzone'\\n\\n  scope.dynamicDrop = false\\n\\n  defaults.actions.drop = drop.defaults\\n}\\n\\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\\n  const drops: ActiveDrop[] = []\\n\\n  // collect all dropzones and their elements which qualify for a drop\\n  for (const dropzone of interactables.list) {\\n    if (!dropzone.options.drop.enabled) {\\n      continue\\n    }\\n\\n    const accept = dropzone.options.drop.accept\\n\\n    // test the draggable draggableElement against the dropzone's accept setting\\n    if (\\n      (is.element(accept) &amp;&amp; accept !== draggableElement) ||\\n      (is.string(accept) &amp;&amp; !domUtils.matchesSelector(draggableElement, accept)) ||\\n      (is.func(accept) &amp;&amp; !accept({ dropzone, draggableElement }))\\n    ) {\\n      continue\\n    }\\n\\n    // query for new elements if necessary\\n    const dropElements = (is.string(dropzone.target)\\n      ? dropzone._context.querySelectorAll(dropzone.target)\\n      : is.array(dropzone.target)\\n        ? dropzone.target\\n        : [dropzone.target]) as Element[]\\n\\n    for (const dropzoneElement of dropElements) {\\n      if (dropzoneElement !== draggableElement) {\\n        drops.push({\\n          dropzone,\\n          element: dropzoneElement,\\n          rect: dropzone.getRect(dropzoneElement),\\n        })\\n      }\\n    }\\n  }\\n\\n  return drops\\n}\\n\\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\\n  // loop through all active dropzones and trigger event\\n  for (const { dropzone, element } of activeDrops.slice()) {\\n    event.dropzone = dropzone\\n\\n    // set current element as event target\\n    event.target = element\\n    dropzone.fire(event)\\n    event.propagationStopped = event.immediatePropagationStopped = false\\n  }\\n}\\n\\n// return a new array of possible drops. getActiveDrops should always be\\n// called when a drag has just started or a drag event happens while\\n// dynamicDrop is true\\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\\n  // get dropzones and their elements that could receive the draggable\\n  const activeDrops = collectDrops(scope, dragElement)\\n\\n  for (const activeDrop of activeDrops) {\\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\\n  }\\n\\n  return activeDrops\\n}\\n\\nfunction getDrop (\\n  { dropState, interactable: draggable, element: dragElement }: Partial&lt;Interaction&gt;,\\n  dragEvent,\\n  pointerEvent,\\n) {\\n  const validDrops = []\\n\\n  // collect all dropzones and their elements which qualify for a drop\\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\\n    validDrops.push(\\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\\n        ? dropzoneElement\\n        : null,\\n    )\\n  }\\n\\n  // get the most appropriate dropzone based on DOM depth and order\\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\\n\\n  return dropState.activeDrops[dropIndex] || null\\n}\\n\\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\\n  const { dropState } = interaction\\n  const dropEvents = {\\n    enter: null,\\n    leave: null,\\n    activate: null,\\n    deactivate: null,\\n    move: null,\\n    drop: null,\\n  }\\n\\n  if (dragEvent.type === 'dragstart') {\\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\\n\\n    dropEvents.activate.target = null\\n    dropEvents.activate.dropzone = null\\n  }\\n  if (dragEvent.type === 'dragend') {\\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\\n\\n    dropEvents.deactivate.target = null\\n    dropEvents.deactivate.dropzone = null\\n  }\\n\\n  if (dropState.rejected) {\\n    return dropEvents\\n  }\\n\\n  if (dropState.cur.element !== dropState.prev.element) {\\n    // if there was a previous dropzone, create a dragleave event\\n    if (dropState.prev.dropzone) {\\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\\n\\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\\n    }\\n    // if dropzone is not null, create a dragenter event\\n    if (dropState.cur.dropzone) {\\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\\n\\n      dragEvent.dragEnter = dropState.cur.element\\n      dragEvent.dropzone = dropState.cur.dropzone\\n    }\\n  }\\n\\n  if (dragEvent.type === 'dragend' &amp;&amp; dropState.cur.dropzone) {\\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\\n\\n    dragEvent.dropzone = dropState.cur.dropzone\\n    dragEvent.relatedTarget = dropState.cur.element\\n  }\\n  if (dragEvent.type === 'dragmove' &amp;&amp; dropState.cur.dropzone) {\\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\\n\\n    dropEvents.move.dragmove = dragEvent\\n    dragEvent.dropzone = dropState.cur.dropzone\\n  }\\n\\n  return dropEvents\\n}\\n\\ntype FiredDropEvents = Partial&lt;\\nRecord&lt;'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent&gt;\\n&gt;\\n\\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\\n  const { dropState } = interaction\\n  const { activeDrops, cur, prev } = dropState\\n\\n  if (events.leave) {\\n    prev.dropzone.fire(events.leave)\\n  }\\n  if (events.enter) {\\n    cur.dropzone.fire(events.enter)\\n  }\\n  if (events.move) {\\n    cur.dropzone.fire(events.move)\\n  }\\n  if (events.drop) {\\n    cur.dropzone.fire(events.drop)\\n  }\\n\\n  if (events.deactivate) {\\n    fireActivationEvents(activeDrops, events.deactivate)\\n  }\\n\\n  dropState.prev.dropzone = cur.dropzone\\n  dropState.prev.element = cur.element\\n}\\n\\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg&lt;'drag', EventPhase&gt;, scope: Scope) {\\n  if (iEvent.type !== 'dragmove' &amp;&amp; iEvent.type !== 'dragend') {\\n    return\\n  }\\n\\n  const { dropState } = interaction\\n\\n  if (scope.dynamicDrop) {\\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\\n  }\\n\\n  const dragEvent = iEvent\\n  const dropResult = getDrop(interaction, dragEvent, event)\\n\\n  // update rejected status\\n  dropState.rejected =\\n    dropState.rejected &amp;&amp;\\n    !!dropResult &amp;&amp;\\n    dropResult.dropzone === dropState.cur.dropzone &amp;&amp;\\n    dropResult.element === dropState.cur.element\\n\\n  dropState.cur.dropzone = dropResult &amp;&amp; dropResult.dropzone\\n  dropState.cur.element = dropResult &amp;&amp; dropResult.element\\n\\n  dropState.events = getDropEvents(interaction, event, dragEvent)\\n}\\n\\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\\n  if (is.object(options)) {\\n    interactable.options.drop.enabled = options.enabled !== false\\n\\n    if (options.listeners) {\\n      const normalized = normalizeListeners(options.listeners)\\n      // rename 'drop' to '' as it will be prefixed with 'drop'\\n      const corrected = Object.keys(normalized).reduce((acc, type) =&gt; {\\n        const correctedType = /^(enter|leave)/.test(type)\\n          ? `drag${type}`\\n          : /^(activate|deactivate|move)/.test(type)\\n            ? `drop${type}`\\n            : type\\n\\n        acc[correctedType] = normalized[type]\\n\\n        return acc\\n      }, {})\\n\\n      interactable.off(interactable.options.drop.listeners)\\n      interactable.on(corrected)\\n      interactable.options.drop.listeners = corrected\\n    }\\n\\n    if (is.func(options.ondrop)) {\\n      interactable.on('drop', options.ondrop)\\n    }\\n    if (is.func(options.ondropactivate)) {\\n      interactable.on('dropactivate', options.ondropactivate)\\n    }\\n    if (is.func(options.ondropdeactivate)) {\\n      interactable.on('dropdeactivate', options.ondropdeactivate)\\n    }\\n    if (is.func(options.ondragenter)) {\\n      interactable.on('dragenter', options.ondragenter)\\n    }\\n    if (is.func(options.ondragleave)) {\\n      interactable.on('dragleave', options.ondragleave)\\n    }\\n    if (is.func(options.ondropmove)) {\\n      interactable.on('dropmove', options.ondropmove)\\n    }\\n\\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\\n      interactable.options.drop.overlap = options.overlap\\n    } else if (is.number(options.overlap)) {\\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\\n    }\\n    if ('accept' in options) {\\n      interactable.options.drop.accept = options.accept\\n    }\\n    if ('checker' in options) {\\n      interactable.options.drop.checker = options.checker\\n    }\\n\\n    return interactable\\n  }\\n\\n  if (is.bool(options)) {\\n    interactable.options.drop.enabled = options\\n\\n    return interactable\\n  }\\n\\n  return interactable.options.drop\\n}\\n\\nfunction dropCheckMethod (\\n  interactable: Interactable,\\n  dragEvent: InteractEvent,\\n  event: PointerEventType,\\n  draggable: Interactable,\\n  draggableElement: Element,\\n  dropElement: Element,\\n  rect: any,\\n) {\\n  let dropped = false\\n\\n  // if the dropzone has no rect (eg. display: none)\\n  // call the custom dropChecker or just return false\\n  if (!(rect = rect || interactable.getRect(dropElement))) {\\n    return interactable.options.drop.checker\\n      ? interactable.options.drop.checker(\\n        dragEvent,\\n        event,\\n        dropped,\\n        interactable,\\n        dropElement,\\n        draggable,\\n        draggableElement,\\n      )\\n      : false\\n  }\\n\\n  const dropOverlap = interactable.options.drop.overlap\\n\\n  if (dropOverlap === 'pointer') {\\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\\n    const page = pointerUtils.getPageXY(dragEvent)\\n\\n    page.x += origin.x\\n    page.y += origin.y\\n\\n    const horizontal = page.x &gt; rect.left &amp;&amp; page.x &lt; rect.right\\n    const vertical = page.y &gt; rect.top &amp;&amp; page.y &lt; rect.bottom\\n\\n    dropped = horizontal &amp;&amp; vertical\\n  }\\n\\n  const dragRect = draggable.getRect(draggableElement)\\n\\n  if (dragRect &amp;&amp; dropOverlap === 'center') {\\n    const cx = dragRect.left + dragRect.width / 2\\n    const cy = dragRect.top + dragRect.height / 2\\n\\n    dropped = cx &gt;= rect.left &amp;&amp; cx &lt;= rect.right &amp;&amp; cy &gt;= rect.top &amp;&amp; cy &lt;= rect.bottom\\n  }\\n\\n  if (dragRect &amp;&amp; is.number(dropOverlap)) {\\n    const overlapArea =\\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\\n\\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\\n\\n    dropped = overlapRatio &gt;= dropOverlap\\n  }\\n\\n  if (interactable.options.drop.checker) {\\n    dropped = interactable.options.drop.checker(\\n      dragEvent,\\n      event,\\n      dropped,\\n      interactable,\\n      dropElement,\\n      draggable,\\n      draggableElement,\\n    )\\n  }\\n\\n  return dropped\\n}\\n\\nconst drop: Plugin = {\\n  id: 'actions/drop',\\n  install,\\n  listeners: {\\n    'interactions:before-action-start': ({ interaction }) =&gt; {\\n      if (interaction.prepared.name !== 'drag') {\\n        return\\n      }\\n\\n      interaction.dropState = {\\n        cur: {\\n          dropzone: null,\\n          element: null,\\n        },\\n        prev: {\\n          dropzone: null,\\n          element: null,\\n        },\\n        rejected: null,\\n        events: null,\\n        activeDrops: [],\\n      }\\n    },\\n\\n    'interactions:after-action-start': (\\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg&lt;'drag', EventPhase&gt;,\\n      scope,\\n    ) =&gt; {\\n      if (interaction.prepared.name !== 'drag') {\\n        return\\n      }\\n\\n      const { dropState } = interaction\\n\\n      // reset active dropzones\\n      dropState.activeDrops = null\\n      dropState.events = null\\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\\n      dropState.events = getDropEvents(interaction, event, dragEvent)\\n\\n      if (dropState.events.activate) {\\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\\n        scope.fire('actions/drop:start', { interaction, dragEvent })\\n      }\\n    },\\n\\n    'interactions:action-move': onEventCreated,\\n\\n    'interactions:after-action-move': (\\n      { interaction, iEvent: dragEvent }: DoPhaseArg&lt;'drag', EventPhase&gt;,\\n      scope,\\n    ) =&gt; {\\n      if (interaction.prepared.name !== 'drag') {\\n        return\\n      }\\n\\n      fireDropEvents(interaction, interaction.dropState.events)\\n\\n      scope.fire('actions/drop:move', { interaction, dragEvent })\\n      interaction.dropState.events = {}\\n    },\\n\\n    'interactions:action-end': (arg: DoPhaseArg&lt;'drag', EventPhase&gt;, scope) =&gt; {\\n      if (arg.interaction.prepared.name !== 'drag') {\\n        return\\n      }\\n\\n      const { interaction, iEvent: dragEvent } = arg\\n\\n      onEventCreated(arg, scope)\\n      fireDropEvents(interaction, interaction.dropState.events)\\n      scope.fire('actions/drop:end', { interaction, dragEvent })\\n    },\\n\\n    'interactions:stop': ({ interaction }) =&gt; {\\n      if (interaction.prepared.name !== 'drag') {\\n        return\\n      }\\n\\n      const { dropState } = interaction\\n\\n      if (dropState) {\\n        dropState.activeDrops = null\\n        dropState.events = null\\n        dropState.cur.dropzone = null\\n        dropState.cur.element = null\\n        dropState.prev.dropzone = null\\n        dropState.prev.element = null\\n        dropState.rejected = false\\n      }\\n    },\\n  },\\n  getActiveDrops,\\n  getDrop,\\n  getDropEvents,\\n  fireDropEvents,\\n  defaults: {\\n    enabled: false,\\n    accept: null,\\n    overlap: 'pointer',\\n  } as DropzoneOptions,\\n}\\n\\nexport default drop\\n\"</span>,<span class=\"code-string\">\"import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\\nimport type { Options } from '@interactjs/core/defaultOptions'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\\nimport is from '@interactjs/utils/is'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\nexport type GesturableMethod = ActionMethod&lt;GesturableOptions&gt;\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    gesture?: {\\n      angle: number // angle from first to second touch\\n      distance: number\\n      scale: number // gesture.distance / gesture.startDistance\\n      startAngle: number // angle of line joining two touches\\n      startDistance: number // distance between two touches of touchStart\\n    }\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    gesturable: GesturableMethod\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface ActionDefaults {\\n    gesture: GesturableOptions\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface ActionMap {\\n    gesture?: typeof gesture\\n  }\\n}\\n\\nexport interface GestureEvent extends InteractEvent&lt;'gesture'&gt; {\\n  distance: number\\n  angle: number\\n  da: number // angle change\\n  scale: number // ratio of distance start to current event\\n  ds: number // scale change\\n  box: Rect // enclosing box of all points\\n  touches: PointerType[]\\n}\\n\\nexport interface GestureSignalArg extends DoPhaseArg&lt;'gesture', EventPhase&gt; {\\n  iEvent: GestureEvent\\n  interaction: Interaction&lt;'gesture'&gt;\\n}\\n\\nfunction install (scope: Scope) {\\n  const { actions, Interactable, defaults } = scope\\n\\n  /**\\n   * ```js\\n   * interact(element).gesturable({\\n   *     onstart: function (event) {},\\n   *     onmove : function (event) {},\\n   *     onend  : function (event) {},\\n   *\\n   *     // limit multiple gestures.\\n   *     // See the explanation in {@link Interactable.draggable} example\\n   *     max: Infinity,\\n   *     maxPerElement: 1,\\n   * })\\n   *\\n   * var isGestureable = interact(element).gesturable()\\n   * ```\\n   *\\n   * Gets or sets whether multitouch gestures can be performed on the target\\n   *\\n   * @param {boolean | object} [options] true/false or An object with event\\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\\n   * @return {boolean | Interactable} A boolean indicating if this can be the\\n   * target of gesture events, or this Interactable\\n   */\\n  Interactable.prototype.gesturable = function (\\n    this: InstanceType&lt;typeof Interactable&gt;,\\n    options: GesturableOptions | boolean,\\n  ) {\\n    if (is.object(options)) {\\n      this.options.gesture.enabled = options.enabled !== false\\n      this.setPerAction('gesture', options)\\n      this.setOnEvents('gesture', options)\\n\\n      return this\\n    }\\n\\n    if (is.bool(options)) {\\n      this.options.gesture.enabled = options\\n\\n      return this\\n    }\\n\\n    return this.options.gesture as Options\\n  } as GesturableMethod\\n\\n  actions.map.gesture = gesture\\n  actions.methodDict.gesture = 'gesturable'\\n\\n  defaults.actions.gesture = gesture.defaults\\n}\\n\\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\\n  if (interaction.prepared.name !== 'gesture') return\\n\\n  const pointers = interaction.pointers.map(p =&gt; p.pointer)\\n  const starting = phase === 'start'\\n  const ending = phase === 'end'\\n  const deltaSource = interaction.interactable.options.deltaSource\\n\\n  iEvent.touches = [pointers[0], pointers[1]]\\n\\n  if (starting) {\\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\\n    iEvent.box = pointerUtils.touchBBox(pointers)\\n    iEvent.scale = 1\\n    iEvent.ds = 0\\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\\n    iEvent.da = 0\\n\\n    interaction.gesture.startDistance = iEvent.distance\\n    interaction.gesture.startAngle = iEvent.angle\\n  } else if (ending) {\\n    const prevEvent = interaction.prevEvent as GestureEvent\\n\\n    iEvent.distance = prevEvent.distance\\n    iEvent.box = prevEvent.box\\n    iEvent.scale = prevEvent.scale\\n    iEvent.ds = 0\\n    iEvent.angle = prevEvent.angle\\n    iEvent.da = 0\\n  } else {\\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\\n    iEvent.box = pointerUtils.touchBBox(pointers)\\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\\n\\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\\n    iEvent.da = iEvent.angle - interaction.gesture.angle\\n  }\\n\\n  interaction.gesture.distance = iEvent.distance\\n  interaction.gesture.angle = iEvent.angle\\n\\n  if (is.number(iEvent.scale) &amp;&amp; iEvent.scale !== Infinity &amp;&amp; !isNaN(iEvent.scale)) {\\n    interaction.gesture.scale = iEvent.scale\\n  }\\n}\\n\\nconst gesture: Plugin = {\\n  id: 'actions/gesture',\\n  before: ['actions/drag', 'actions/resize'],\\n  install,\\n  listeners: {\\n    'interactions:action-start': updateGestureProps,\\n    'interactions:action-move': updateGestureProps,\\n    'interactions:action-end': updateGestureProps,\\n\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.gesture = {\\n        angle: 0,\\n        distance: 0,\\n        scale: 1,\\n        startAngle: 0,\\n        startDistance: 0,\\n      }\\n    },\\n\\n    'auto-start:check': arg =&gt; {\\n      if (arg.interaction.pointers.length &lt; 2) {\\n        return undefined\\n      }\\n\\n      const gestureOptions = arg.interactable.options.gesture\\n\\n      if (!(gestureOptions &amp;&amp; gestureOptions.enabled)) {\\n        return undefined\\n      }\\n\\n      arg.action = { name: 'gesture' }\\n\\n      return false\\n    },\\n  },\\n\\n  defaults: {},\\n\\n  getCursor () {\\n    return ''\\n  },\\n}\\n\\nexport default gesture\\n\"</span>,<span class=\"code-string\">\"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { Interactable } from '@interactjs/core/Interactable'\\nimport type { ActionProps, Interaction } from '@interactjs/core/Interaction'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type {\\n  ActionMethod,\\n  ResizableOptions,\\n  FullRect,\\n  OrBoolean,\\n  Point,\\n  Rect,\\n} from '@interactjs/types/index'\\nimport * as dom from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\n\\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\\n\\nexport type ResizableMethod = ActionMethod&lt;ResizableOptions&gt;\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    resizable: ResizableMethod\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    resizeAxes: 'x' | 'y' | 'xy'\\n    resizeStartAspectRatio: number\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface ActionDefaults {\\n    resize: ResizableOptions\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface ActionMap {\\n    resize?: typeof resize\\n  }\\n}\\n\\nexport interface ResizeEvent&lt;P extends EventPhase = EventPhase&gt; extends InteractEvent&lt;'resize', P&gt; {\\n  deltaRect?: FullRect\\n  edges?: ActionProps['edges']\\n}\\n\\nfunction install (scope: Scope) {\\n  const {\\n    actions,\\n    browser,\\n    /** @lends Interactable */\\n    Interactable, // tslint:disable-line no-shadowed-variable\\n    defaults,\\n  } = scope\\n\\n  // Less Precision with touch input\\n\\n  resize.cursors = initCursors(browser)\\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\\n\\n  /**\\n   * ```js\\n   * interact(element).resizable({\\n   *   onstart: function (event) {},\\n   *   onmove : function (event) {},\\n   *   onend  : function (event) {},\\n   *\\n   *   edges: {\\n   *     top   : true,       // Use pointer coords to check for resize.\\n   *     left  : false,      // Disable resizing from left edge.\\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\\n   *     right : handleEl    // Resize if pointer target is the given Element\\n   *   },\\n   *\\n   *     // Width and height can be adjusted independently. When `true`, width and\\n   *     // height are adjusted at a 1:1 ratio.\\n   *     square: false,\\n   *\\n   *     // Width and height can be adjusted independently. When `true`, width and\\n   *     // height maintain the aspect ratio they had when resizing started.\\n   *     preserveAspectRatio: false,\\n   *\\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\\n   *   // 'negate' will allow the rect to have negative width/height\\n   *   // 'reposition' will keep the width/height positive by swapping\\n   *   // the top and bottom edges and/or swapping the left and right edges\\n   *   invert: 'none' || 'negate' || 'reposition'\\n   *\\n   *   // limit multiple resizes.\\n   *   // See the explanation in the {@link Interactable.draggable} example\\n   *   max: Infinity,\\n   *   maxPerElement: 1,\\n   * })\\n   *\\n   * var isResizeable = interact(element).resizable()\\n   * ```\\n   *\\n   * Gets or sets whether resize actions can be performed on the target\\n   *\\n   * @param {boolean | object} [options] true/false or An object with event\\n   * listeners to be fired on resize events (object makes the Interactable\\n   * resizable)\\n   * @return {boolean | Interactable} A boolean indicating if this can be the\\n   * target of resize elements, or this Interactable\\n   */\\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\\n    return resizable(this, options, scope)\\n  } as ResizableMethod\\n\\n  actions.map.resize = resize\\n  actions.methodDict.resize = 'resizable'\\n\\n  defaults.actions.resize = resize.defaults\\n}\\n\\nfunction resizeChecker (arg) {\\n  const { interaction, interactable, element, rect, buttons } = arg\\n\\n  if (!rect) {\\n    return undefined\\n  }\\n\\n  const page = extend({}, interaction.coords.cur.page)\\n  const resizeOptions = interactable.options.resize\\n\\n  if (\\n    !(resizeOptions &amp;&amp; resizeOptions.enabled) ||\\n    // check mouseButton setting if the pointer is down\\n    (interaction.pointerIsDown &amp;&amp;\\n      /mouse|pointer/.test(interaction.pointerType) &amp;&amp;\\n      (buttons &amp; resizeOptions.mouseButtons) === 0)\\n  ) {\\n    return undefined\\n  }\\n\\n  // if using resize.edges\\n  if (is.object(resizeOptions.edges)) {\\n    const resizeEdges = {\\n      left: false,\\n      right: false,\\n      top: false,\\n      bottom: false,\\n    }\\n\\n    for (const edge in resizeEdges) {\\n      resizeEdges[edge] = checkResizeEdge(\\n        edge,\\n        resizeOptions.edges[edge],\\n        page,\\n        interaction._latestPointer.eventTarget,\\n        element,\\n        rect,\\n        resizeOptions.margin || resize.defaultMargin,\\n      )\\n    }\\n\\n    resizeEdges.left = resizeEdges.left &amp;&amp; !resizeEdges.right\\n    resizeEdges.top = resizeEdges.top &amp;&amp; !resizeEdges.bottom\\n\\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\\n      arg.action = {\\n        name: 'resize',\\n        edges: resizeEdges,\\n      }\\n    }\\n  } else {\\n    const right = resizeOptions.axis !== 'y' &amp;&amp; page.x &gt; rect.right - resize.defaultMargin\\n    const bottom = resizeOptions.axis !== 'x' &amp;&amp; page.y &gt; rect.bottom - resize.defaultMargin\\n\\n    if (right || bottom) {\\n      arg.action = {\\n        name: 'resize',\\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\\n      }\\n    }\\n  }\\n\\n  return arg.action ? false : undefined\\n}\\n\\nfunction resizable (interactable: Interactable, options: OrBoolean&lt;ResizableOptions&gt; | boolean, scope: Scope) {\\n  if (is.object(options)) {\\n    interactable.options.resize.enabled = options.enabled !== false\\n    interactable.setPerAction('resize', options)\\n    interactable.setOnEvents('resize', options)\\n\\n    if (is.string(options.axis) &amp;&amp; /^x$|^y$|^xy$/.test(options.axis)) {\\n      interactable.options.resize.axis = options.axis\\n    } else if (options.axis === null) {\\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\\n    }\\n\\n    if (is.bool(options.preserveAspectRatio)) {\\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\\n    } else if (is.bool(options.square)) {\\n      interactable.options.resize.square = options.square\\n    }\\n\\n    return interactable\\n  }\\n  if (is.bool(options)) {\\n    interactable.options.resize.enabled = options\\n\\n    return interactable\\n  }\\n  return interactable.options.resize\\n}\\n\\nfunction checkResizeEdge (\\n  name: string,\\n  value: any,\\n  page: Point,\\n  element: Node,\\n  interactableElement: Element,\\n  rect: Rect,\\n  margin: number,\\n) {\\n  // false, '', undefined, null\\n  if (!value) {\\n    return false\\n  }\\n\\n  // true value, use pointer coords and element rect\\n  if (value === true) {\\n    // if dimensions are negative, \\\"switch\\\" edges\\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\\n\\n    // don't use margin greater than half the relevent dimension\\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\\n\\n    if (width &lt; 0) {\\n      if (name === 'left') {\\n        name = 'right'\\n      } else if (name === 'right') {\\n        name = 'left'\\n      }\\n    }\\n    if (height &lt; 0) {\\n      if (name === 'top') {\\n        name = 'bottom'\\n      } else if (name === 'bottom') {\\n        name = 'top'\\n      }\\n    }\\n\\n    if (name === 'left') {\\n      return page.x &lt; (width &gt;= 0 ? rect.left : rect.right) + margin\\n    }\\n    if (name === 'top') {\\n      return page.y &lt; (height &gt;= 0 ? rect.top : rect.bottom) + margin\\n    }\\n\\n    if (name === 'right') {\\n      return page.x &gt; (width &gt;= 0 ? rect.right : rect.left) - margin\\n    }\\n    if (name === 'bottom') {\\n      return page.y &gt; (height &gt;= 0 ? rect.bottom : rect.top) - margin\\n    }\\n  }\\n\\n  // the remaining checks require an element\\n  if (!is.element(element)) {\\n    return false\\n  }\\n\\n  return is.element(value)\\n    ? // the value is an element to use as a resize handle\\n    value === element\\n    : // otherwise check if element matches value as selector\\n    dom.matchesUpTo(element, value, interactableElement)\\n}\\n\\n/* eslint-disable multiline-ternary */\\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\\n  return browser.isIe9\\n    ? {\\n      x: 'e-resize',\\n      y: 's-resize',\\n      xy: 'se-resize',\\n\\n      top: 'n-resize',\\n      left: 'w-resize',\\n      bottom: 's-resize',\\n      right: 'e-resize',\\n      topleft: 'se-resize',\\n      bottomright: 'se-resize',\\n      topright: 'ne-resize',\\n      bottomleft: 'ne-resize',\\n    }\\n    : {\\n      x: 'ew-resize',\\n      y: 'ns-resize',\\n      xy: 'nwse-resize',\\n\\n      top: 'ns-resize',\\n      left: 'ew-resize',\\n      bottom: 'ns-resize',\\n      right: 'ew-resize',\\n      topleft: 'nwse-resize',\\n      bottomright: 'nwse-resize',\\n      topright: 'nesw-resize',\\n      bottomleft: 'nesw-resize',\\n    }\\n}\\n/* eslint-enable multiline-ternary */\\n\\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\\n    return\\n  }\\n\\n  const resizeEvent = iEvent as ResizeEvent\\n  const rect = interaction.rect\\n\\n  interaction._rects = {\\n    start: extend({}, rect),\\n    corrected: extend({}, rect),\\n    previous: extend({}, rect),\\n    delta: {\\n      left: 0,\\n      right: 0,\\n      width: 0,\\n      top: 0,\\n      bottom: 0,\\n      height: 0,\\n    },\\n  }\\n\\n  resizeEvent.edges = interaction.prepared.edges\\n  resizeEvent.rect = interaction._rects.corrected\\n  resizeEvent.deltaRect = interaction._rects.delta\\n}\\n\\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\\n\\n  const resizeEvent = iEvent as ResizeEvent\\n  const resizeOptions = interaction.interactable.options.resize\\n  const invert = resizeOptions.invert\\n  const invertible = invert === 'reposition' || invert === 'negate'\\n\\n  const current = interaction.rect\\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\\n\\n  extend(previous, corrected)\\n\\n  if (invertible) {\\n    // if invertible, copy the current rect\\n    extend(corrected, current)\\n\\n    if (invert === 'reposition') {\\n      // swap edge values if necessary to keep width/height positive\\n      if (corrected.top &gt; corrected.bottom) {\\n        const swap = corrected.top\\n\\n        corrected.top = corrected.bottom\\n        corrected.bottom = swap\\n      }\\n      if (corrected.left &gt; corrected.right) {\\n        const swap = corrected.left\\n\\n        corrected.left = corrected.right\\n        corrected.right = swap\\n      }\\n    }\\n  } else {\\n    // if not invertible, restrict to minimum of 0x0 rect\\n    corrected.top = Math.min(current.top, startRect.bottom)\\n    corrected.bottom = Math.max(current.bottom, startRect.top)\\n    corrected.left = Math.min(current.left, startRect.right)\\n    corrected.right = Math.max(current.right, startRect.left)\\n  }\\n\\n  corrected.width = corrected.right - corrected.left\\n  corrected.height = corrected.bottom - corrected.top\\n\\n  for (const edge in corrected) {\\n    deltaRect[edge] = corrected[edge] - previous[edge]\\n  }\\n\\n  resizeEvent.edges = interaction.prepared.edges\\n  resizeEvent.rect = corrected\\n  resizeEvent.deltaRect = deltaRect\\n}\\n\\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\\n\\n  const resizeEvent = iEvent as ResizeEvent\\n\\n  resizeEvent.edges = interaction.prepared.edges\\n  resizeEvent.rect = interaction._rects.corrected\\n  resizeEvent.deltaRect = interaction._rects.delta\\n}\\n\\nfunction updateEventAxes ({\\n  iEvent,\\n  interaction,\\n}: {\\n  iEvent: InteractEvent&lt;any, any&gt;\\n  interaction: Interaction\\n}) {\\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\\n\\n  const options = interaction.interactable.options\\n  const resizeEvent = iEvent as ResizeEvent\\n\\n  if (options.resize.square) {\\n    if (interaction.resizeAxes === 'y') {\\n      resizeEvent.delta.x = resizeEvent.delta.y\\n    } else {\\n      resizeEvent.delta.y = resizeEvent.delta.x\\n    }\\n    resizeEvent.axes = 'xy'\\n  } else {\\n    resizeEvent.axes = interaction.resizeAxes\\n\\n    if (interaction.resizeAxes === 'x') {\\n      resizeEvent.delta.y = 0\\n    } else if (interaction.resizeAxes === 'y') {\\n      resizeEvent.delta.x = 0\\n    }\\n  }\\n}\\n\\nconst resize: Plugin = {\\n  id: 'actions/resize',\\n  before: ['actions/drag'],\\n  install,\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.resizeAxes = 'xy'\\n    },\\n\\n    'interactions:action-start': arg =&gt; {\\n      start(arg)\\n      updateEventAxes(arg)\\n    },\\n    'interactions:action-move': arg =&gt; {\\n      move(arg)\\n      updateEventAxes(arg)\\n    },\\n    'interactions:action-end': end,\\n    'auto-start:check': resizeChecker,\\n  },\\n\\n  defaults: {\\n    square: false,\\n    preserveAspectRatio: false,\\n    axis: 'xy',\\n\\n    // use default margin\\n    margin: NaN,\\n\\n    // object with props left, right, top, bottom which are\\n    // true/false values to resize when the pointer is over that edge,\\n    // CSS selectors to match the handles for each direction\\n    // or the Elements for each handle\\n    edges: null,\\n\\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\\n    // 'negate' will alow the rect to have negative width/height\\n    // 'reposition' will keep the width/height positive by swapping\\n    // the top and bottom edges and/or swapping the left and right edges\\n    invert: 'none',\\n  } as ResizableOptions,\\n\\n  cursors: null as ReturnType&lt;typeof initCursors&gt;,\\n\\n  getCursor ({ edges, axis, name }: ActionProps) {\\n    const cursors = resize.cursors\\n    let result: string = null\\n\\n    if (axis) {\\n      result = cursors[name + axis]\\n    } else if (edges) {\\n      let cursorKey = ''\\n\\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\\n        if (edges[edge]) {\\n          cursorKey += edge\\n        }\\n      }\\n\\n      result = cursors[cursorKey]\\n    }\\n\\n    return result\\n  },\\n\\n  defaultMargin: null as number,\\n}\\n\\nexport default resize\\n\"</span>,<span class=\"code-string\">\"import type { Scope } from '@interactjs/core/scope'\\n\\nimport drag from './drag/plugin'\\nimport drop from './drop/plugin'\\nimport gesture from './gesture/plugin'\\nimport resize from './resize/plugin'\\n\\nexport default {\\n  id: 'actions',\\n  install (scope: Scope) {\\n    scope.usePlugin(gesture)\\n    scope.usePlugin(resize)\\n    scope.usePlugin(drag)\\n    scope.usePlugin(drop)\\n  },\\n}\\n\"</span>,<span class=\"code-string\">\"export type ArrangeEvent = {}\\nexport type ArrangeMode = {}\\n\\nexport default {}\\n\"</span>,<span class=\"code-string\">\"let lastTime = 0\\nlet request: typeof requestAnimationFrame\\nlet cancel: typeof cancelAnimationFrame\\n\\nfunction init (window: Window) {\\n  request = window.requestAnimationFrame\\n  cancel = window.cancelAnimationFrame\\n\\n  if (!request) {\\n    const vendors = ['ms', 'moz', 'webkit', 'o']\\n\\n    for (const vendor of vendors) {\\n      request = window[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\\n      cancel =\\n        window[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\\n        window[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\\n    }\\n  }\\n\\n  request = request &amp;&amp; request.bind(window)\\n  cancel = cancel &amp;&amp; cancel.bind(window)\\n\\n  if (!request) {\\n    request = callback =&gt; {\\n      const currTime = Date.now()\\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\\n      const token = window.setTimeout(() =&gt; {\\n        // eslint-disable-next-line node/no-callback-literal\\n        callback(currTime + timeToCall)\\n      }, timeToCall)\\n\\n      lastTime = currTime + timeToCall\\n      return token\\n    }\\n\\n    cancel = token =&gt; clearTimeout(token)\\n  }\\n}\\n\\nexport default {\\n  request: (callback: FrameRequestCallback) =&gt; request(callback),\\n  cancel: (token: number) =&gt; cancel(token),\\n  init,\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type Interaction from '@interactjs/core/Interaction'\\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\\nimport type { PointerType } from '@interactjs/types/index'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport is from '@interactjs/utils/is'\\nimport raf from '@interactjs/utils/raf'\\nimport { getStringOptionResult } from '@interactjs/utils/rect'\\nimport { getWindow } from '@interactjs/utils/window'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    autoScroll: typeof autoScroll\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    autoScroll?: typeof autoScroll\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface PerActionDefaults {\\n    autoScroll?: AutoScrollOptions\\n  }\\n}\\n\\nexport interface AutoScrollOptions {\\n  container?: Window | HTMLElement\\n  margin?: number\\n  distance?: number\\n  interval?: number\\n  speed?: number\\n  enabled?: boolean\\n}\\n\\nfunction install (scope: Scope) {\\n  const { defaults, actions } = scope\\n\\n  scope.autoScroll = autoScroll\\n  autoScroll.now = () =&gt; scope.now()\\n\\n  actions.phaselessTypes.autoscroll = true\\n  defaults.perAction.autoScroll = autoScroll.defaults\\n}\\n\\nconst autoScroll = {\\n  defaults: {\\n    enabled: false,\\n    margin: 60,\\n\\n    // the item that is scrolled (Window or HTMLElement)\\n    container: null as AutoScrollOptions['container'],\\n\\n    // the scroll speed in pixels per second\\n    speed: 300,\\n  } as AutoScrollOptions,\\n\\n  now: Date.now,\\n\\n  interaction: null as Interaction,\\n  i: 0, // the handle returned by window.setInterval\\n\\n  // Direction each pulse is to scroll in\\n  x: 0,\\n  y: 0,\\n\\n  isScrolling: false,\\n  prevTime: 0,\\n  margin: 0,\\n  speed: 0,\\n\\n  start (interaction: Interaction) {\\n    autoScroll.isScrolling = true\\n    raf.cancel(autoScroll.i)\\n\\n    interaction.autoScroll = autoScroll\\n    autoScroll.interaction = interaction\\n    autoScroll.prevTime = autoScroll.now()\\n    autoScroll.i = raf.request(autoScroll.scroll)\\n  },\\n\\n  stop () {\\n    autoScroll.isScrolling = false\\n    if (autoScroll.interaction) {\\n      autoScroll.interaction.autoScroll = null\\n    }\\n    raf.cancel(autoScroll.i)\\n  },\\n\\n  // scroll the window by the values in scroll.x/y\\n  scroll () {\\n    const { interaction } = autoScroll\\n    const { interactable, element } = interaction\\n    const actionName = interaction.prepared.name\\n    const options = interactable.options[actionName].autoScroll\\n    const container = getContainer(options.container, interactable, element)\\n    const now = autoScroll.now()\\n    // change in time in seconds\\n    const dt = (now - autoScroll.prevTime) / 1000\\n    // displacement\\n    const s = options.speed * dt\\n\\n    if (s &gt;= 1) {\\n      const scrollBy = {\\n        x: autoScroll.x * s,\\n        y: autoScroll.y * s,\\n      }\\n\\n      if (scrollBy.x || scrollBy.y) {\\n        const prevScroll = getScroll(container)\\n\\n        if (is.window(container)) {\\n          container.scrollBy(scrollBy.x, scrollBy.y)\\n        } else if (container) {\\n          container.scrollLeft += scrollBy.x\\n          container.scrollTop += scrollBy.y\\n        }\\n\\n        const curScroll = getScroll(container)\\n        const delta = {\\n          x: curScroll.x - prevScroll.x,\\n          y: curScroll.y - prevScroll.y,\\n        }\\n\\n        if (delta.x || delta.y) {\\n          interactable.fire({\\n            type: 'autoscroll',\\n            target: element,\\n            interactable,\\n            delta,\\n            interaction,\\n            container,\\n          })\\n        }\\n      }\\n\\n      autoScroll.prevTime = now\\n    }\\n\\n    if (autoScroll.isScrolling) {\\n      raf.cancel(autoScroll.i)\\n      autoScroll.i = raf.request(autoScroll.scroll)\\n    }\\n  },\\n  check (interactable: Interactable, actionName: ActionName) {\\n    const options = interactable.options\\n\\n    return options[actionName].autoScroll?.enabled\\n  },\\n  onInteractionMove&lt;T extends ActionName&gt; ({\\n    interaction,\\n    pointer,\\n  }: {\\n    interaction: Interaction&lt;T&gt;\\n    pointer: PointerType\\n  }) {\\n    if (\\n      !(interaction.interacting() &amp;&amp; autoScroll.check(interaction.interactable, interaction.prepared.name))\\n    ) {\\n      return\\n    }\\n\\n    if (interaction.simulation) {\\n      autoScroll.x = autoScroll.y = 0\\n      return\\n    }\\n\\n    let top: boolean\\n    let right: boolean\\n    let bottom: boolean\\n    let left: boolean\\n\\n    const { interactable, element } = interaction\\n    const actionName = interaction.prepared.name\\n    const options = interactable.options[actionName].autoScroll\\n    const container = getContainer(options.container, interactable, element)\\n\\n    if (is.window(container)) {\\n      left = pointer.clientX &lt; autoScroll.margin\\n      top = pointer.clientY &lt; autoScroll.margin\\n      right = pointer.clientX &gt; container.innerWidth - autoScroll.margin\\n      bottom = pointer.clientY &gt; container.innerHeight - autoScroll.margin\\n    } else {\\n      const rect = domUtils.getElementClientRect(container)\\n\\n      left = pointer.clientX &lt; rect.left + autoScroll.margin\\n      top = pointer.clientY &lt; rect.top + autoScroll.margin\\n      right = pointer.clientX &gt; rect.right - autoScroll.margin\\n      bottom = pointer.clientY &gt; rect.bottom - autoScroll.margin\\n    }\\n\\n    autoScroll.x = right ? 1 : left ? -1 : 0\\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\\n\\n    if (!autoScroll.isScrolling) {\\n      // set the autoScroll properties to those of the target\\n      autoScroll.margin = options.margin\\n      autoScroll.speed = options.speed\\n\\n      autoScroll.start(interaction)\\n    }\\n  },\\n}\\n\\nexport function getContainer (value: any, interactable: Interactable, element: Element) {\\n  return (\\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\\n  )\\n}\\n\\nexport function getScroll (container: any) {\\n  if (is.window(container)) {\\n    container = window.document.body\\n  }\\n\\n  return { x: container.scrollLeft, y: container.scrollTop }\\n}\\n\\nexport function getScrollSize (container: any) {\\n  if (is.window(container)) {\\n    container = window.document.body\\n  }\\n\\n  return { x: container.scrollWidth, y: container.scrollHeight }\\n}\\n\\nexport function getScrollSizeDelta&lt;T extends ActionName&gt; (\\n  {\\n    interaction,\\n    element,\\n  }: {\\n    interaction: Partial&lt;Interaction&lt;T&gt;&gt;\\n    element: Element\\n  },\\n  func: any,\\n) {\\n  const scrollOptions = interaction &amp;&amp; interaction.interactable.options[interaction.prepared.name].autoScroll\\n\\n  if (!scrollOptions || !scrollOptions.enabled) {\\n    func()\\n    return { x: 0, y: 0 }\\n  }\\n\\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\\n\\n  const prevSize = getScroll(scrollContainer)\\n  func()\\n  const curSize = getScroll(scrollContainer)\\n\\n  return {\\n    x: curSize.x - prevSize.x,\\n    y: curSize.y - prevSize.y,\\n  }\\n}\\n\\nconst autoScrollPlugin: Plugin = {\\n  id: 'auto-scroll',\\n  install,\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.autoScroll = null\\n    },\\n\\n    'interactions:destroy': ({ interaction }) =&gt; {\\n      interaction.autoScroll = null\\n      autoScroll.stop()\\n      if (autoScroll.interaction) {\\n        autoScroll.interaction = null\\n      }\\n    },\\n\\n    'interactions:stop': autoScroll.stop,\\n\\n    'interactions:action-move': (arg: any) =&gt; autoScroll.onInteractionMove(arg),\\n  },\\n}\\n\\nexport default autoScrollPlugin\\n\"</span>,<span class=\"code-string\">\"import type { ActionProps } from '@interactjs/core/Interaction'\\nimport type { ActionName } from '@interactjs/core/scope'\\n\\nimport { window } from './window'\\n\\nexport function warnOnce&lt;T&gt; (this: T, method: (...args: any[]) =&gt; any, message: string) {\\n  let warned = false\\n\\n  return function (this: T) {\\n    if (!warned) {\\n      ;(window as any).console.warn(message)\\n      warned = true\\n    }\\n\\n    return method.apply(this, arguments)\\n  }\\n}\\n\\nexport function copyAction&lt;T extends ActionName&gt; (dest: ActionProps&lt;any&gt;, src: ActionProps&lt;T&gt;) {\\n  dest.name = src.name\\n  dest.axis = src.axis\\n  dest.edges = src.edges\\n\\n  return dest\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\\nimport type { Scope } from '@interactjs/core/scope'\\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\\nimport is from '@interactjs/utils/is'\\nimport { warnOnce } from '@interactjs/utils/misc'\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    getAction: (\\n      this: Interactable,\\n      pointer: PointerType,\\n      event: PointerEventType,\\n      interaction: Interaction,\\n      element: Element,\\n    ) =&gt; ActionProps | null\\n    styleCursor: typeof styleCursor\\n    actionChecker: typeof actionChecker\\n    ignoreFrom: {\\n      (...args: any[]): Interactable\\n      (): boolean\\n    }\\n    allowFrom: {\\n      (...args: any[]): Interactable\\n      (): boolean\\n    }\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  const {\\n    /** @lends Interactable */\\n    Interactable, // tslint:disable-line no-shadowed-variable\\n  } = scope\\n\\n  Interactable.prototype.getAction = function getAction (\\n    this: Interactable,\\n    pointer: PointerType,\\n    event: PointerEventType,\\n    interaction: Interaction,\\n    element: Element,\\n  ): ActionProps {\\n    const action = defaultActionChecker(this, event, interaction, element, scope)\\n\\n    if (this.options.actionChecker) {\\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\\n    }\\n\\n    return action\\n  }\\n\\n  /**\\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\\n   * of it's parents match the given CSS selector or Element, no\\n   * drag/resize/gesture is started.\\n   *\\n   * @deprecated\\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\\n   * or for `pointerEvents`\\n   *\\n   * ```js\\n   * interact(targett)\\n   *   .draggable({\\n   *     ignoreFrom: 'input, textarea, a[href]'',\\n   *   })\\n   *   .pointerEvents({\\n   *     ignoreFrom: '[no-pointer]',\\n   *   })\\n   * ```\\n   *\\n   * @param {string | Element | null} [newValue] a CSS selector string, an\\n   * Element or `null` to not ignore any elements\\n   * @return {string | Element | object} The current ignoreFrom value or this\\n   * Interactable\\n   */\\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\\n    return this._backCompatOption('ignoreFrom', newValue)\\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\\n\\n  /**\\n   *\\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\\n   * CSS selector or Element.\\n   *\\n   * @deprecated\\n   * Don't use this method. Instead set the `allowFrom` option for each action\\n   * or for `pointerEvents`\\n   *\\n   * ```js\\n   * interact(targett)\\n   *   .resizable({\\n   *     allowFrom: '.resize-handle',\\n   *   .pointerEvents({\\n   *     allowFrom: '.handle',,\\n   *   })\\n   * ```\\n   *\\n   * @param {string | Element | null} [newValue] a CSS selector string, an\\n   * Element or `null` to allow from any element\\n   * @return {string | Element | object} The current allowFrom value or this\\n   * Interactable\\n   */\\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\\n    return this._backCompatOption('allowFrom', newValue)\\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\\n\\n  /**\\n   * ```js\\n   * interact('.resize-drag')\\n   *   .resizable(true)\\n   *   .draggable(true)\\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\\n   *\\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\\n   *       // force drag with handle target\\n   *       action.name = drag\\n   *     }\\n   *     else {\\n   *       // resize from the top and right edges\\n   *       action.name  = 'resize'\\n   *       action.edges = { top: true, right: true }\\n   *     }\\n   *\\n   *     return action\\n   * })\\n   * ```\\n   *\\n   * Returns or sets the function used to check action to be performed on\\n   * pointerDown\\n   *\\n   * @param {function | null} [checker] A function which takes a pointer event,\\n   * defaultAction string, interactable, element and interaction as parameters\\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\\n   * props.\\n   * @return {Function | Interactable} The checker function or this Interactable\\n   */\\n  Interactable.prototype.actionChecker = actionChecker\\n\\n  /**\\n   * Returns or sets whether the the cursor should be changed depending on the\\n   * action that would be performed if the mouse were pressed and dragged.\\n   *\\n   * @param {boolean} [newValue]\\n   * @return {boolean | Interactable} The current setting or this Interactable\\n   */\\n  Interactable.prototype.styleCursor = styleCursor\\n}\\n\\nfunction defaultActionChecker (\\n  interactable: Interactable,\\n  event: PointerEventType,\\n  interaction: Interaction,\\n  element: Element,\\n  scope: Scope,\\n) {\\n  const rect = interactable.getRect(element)\\n  const buttons =\\n    (event as MouseEvent).buttons ||\\n    {\\n      0: 1,\\n      1: 4,\\n      3: 8,\\n      4: 16,\\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\\n  const arg = {\\n    action: null,\\n    interactable,\\n    interaction,\\n    element,\\n    rect,\\n    buttons,\\n  }\\n\\n  scope.fire('auto-start:check', arg)\\n\\n  return arg.action\\n}\\n\\nfunction styleCursor(this: Interactable): boolean\\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\\nfunction styleCursor (this: Interactable, newValue?: boolean) {\\n  if (is.bool(newValue)) {\\n    this.options.styleCursor = newValue\\n\\n    return this\\n  }\\n\\n  if (newValue === null) {\\n    delete this.options.styleCursor\\n\\n    return this\\n  }\\n\\n  return this.options.styleCursor\\n}\\n\\nfunction actionChecker (this: Interactable, checker: any) {\\n  if (is.func(checker)) {\\n    this.options.actionChecker = checker\\n\\n    return this\\n  }\\n\\n  if (checker === null) {\\n    delete this.options.actionChecker\\n\\n    return this\\n  }\\n\\n  return this.options.actionChecker\\n}\\n\\nexport default {\\n  id: 'auto-start/interactableMethods',\\n  install,\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\\nimport type { Scope, SignalArgs, ActionName, Plugin } from '@interactjs/core/scope'\\nimport type { CursorChecker, PointerType, PointerEventType, Element } from '@interactjs/types/index'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\nimport { copyAction } from '@interactjs/utils/misc'\\n\\nimport InteractableMethods from './InteractableMethods'\\n\\ndeclare module '@interactjs/core/interactStatic' {\\n  export interface InteractStatic {\\n    maxInteractions: (newValue: any) =&gt; any\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    autoStart: AutoStart\\n  }\\n\\n  interface SignalArgs {\\n    'autoStart:before-start': Omit&lt;SignalArgs['interactions:move'], 'interaction'&gt; &amp; {\\n      interaction: Interaction&lt;ActionName&gt;\\n    }\\n    'autoStart:prepared': { interaction: Interaction }\\n    'auto-start:check': CheckSignalArg\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface BaseDefaults {\\n    actionChecker?: any\\n    cursorChecker?: any\\n    styleCursor?: any\\n  }\\n\\n  interface PerActionDefaults {\\n    manualStart?: boolean\\n    max?: number\\n    maxPerElement?: number\\n    allowFrom?: string | Element\\n    ignoreFrom?: string | Element\\n    cursorChecker?: CursorChecker\\n\\n    // only allow left button by default\\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\\n    // TODO: docst\\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\\n  }\\n}\\n\\ninterface CheckSignalArg {\\n  interactable: Interactable\\n  interaction: Interaction\\n  element: Element\\n  action: ActionProps&lt;ActionName&gt;\\n  buttons: number\\n}\\n\\nexport interface AutoStart {\\n  // Allow this many interactions to happen simultaneously\\n  maxInteractions: number\\n  withinInteractionLimit: typeof withinInteractionLimit\\n  cursorElement: Element\\n}\\n\\nfunction install (scope: Scope) {\\n  const { interactStatic: interact, defaults } = scope\\n\\n  scope.usePlugin(InteractableMethods)\\n\\n  defaults.base.actionChecker = null\\n  defaults.base.styleCursor = true\\n\\n  extend(defaults.perAction, {\\n    manualStart: false,\\n    max: Infinity,\\n    maxPerElement: 1,\\n    allowFrom: null,\\n    ignoreFrom: null,\\n\\n    // only allow left button by default\\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\\n    mouseButtons: 1,\\n  })\\n\\n  /**\\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\\n   * default only 1 interaction is allowed at a time (for backwards\\n   * compatibility). To allow multiple interactions on the same Interactables and\\n   * elements, you need to enable it in the draggable, resizable and gesturable\\n   * `'max'` and `'maxPerElement'` options.\\n   *\\n   * @alias module:interact.maxInteractions\\n   *\\n   * @param {number} [newValue] Any number. newValue &lt;= 0 means no interactions.\\n   */\\n  interact.maxInteractions = (newValue: number) =&gt; maxInteractions(newValue, scope)\\n\\n  scope.autoStart = {\\n    // Allow this many interactions to happen simultaneously\\n    maxInteractions: Infinity,\\n    withinInteractionLimit,\\n    cursorElement: null,\\n  }\\n}\\n\\nfunction prepareOnDown (\\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\\n  scope: Scope,\\n) {\\n  if (interaction.interacting()) return\\n\\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\\n  prepare(interaction, actionInfo, scope)\\n}\\n\\nfunction prepareOnMove (\\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\\n  scope: Scope,\\n) {\\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\\n\\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\\n  prepare(interaction, actionInfo, scope)\\n}\\n\\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\\n  const { interaction } = arg\\n\\n  if (\\n    !interaction.pointerIsDown ||\\n    interaction.interacting() ||\\n    !interaction.pointerWasMoved ||\\n    !interaction.prepared.name\\n  ) {\\n    return\\n  }\\n\\n  scope.fire('autoStart:before-start', arg)\\n\\n  const { interactable } = interaction\\n  const actionName = (interaction as Interaction&lt;ActionName&gt;).prepared.name\\n\\n  if (actionName &amp;&amp; interactable) {\\n    // check manualStart and interaction limit\\n    if (\\n      interactable.options[actionName].manualStart ||\\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\\n    ) {\\n      interaction.stop()\\n    } else {\\n      interaction.start(interaction.prepared, interactable, interaction.element)\\n      setInteractionCursor(interaction, scope)\\n    }\\n  }\\n}\\n\\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\\n  const { interactable } = interaction\\n\\n  if (interactable &amp;&amp; interactable.options.styleCursor) {\\n    setCursor(interaction.element, '', scope)\\n  }\\n}\\n\\n// Check if the current interactable supports the action.\\n// If so, return the validated action. Otherwise, return null\\nfunction validateAction&lt;T extends ActionName&gt; (\\n  action: ActionProps&lt;T&gt;,\\n  interactable: Interactable,\\n  element: Element,\\n  eventTarget: Node,\\n  scope: Scope,\\n) {\\n  if (\\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &amp;&amp;\\n    interactable.options[action.name].enabled &amp;&amp;\\n    withinInteractionLimit(interactable, element, action, scope)\\n  ) {\\n    return action\\n  }\\n\\n  return null\\n}\\n\\nfunction validateMatches (\\n  interaction: Interaction,\\n  pointer: PointerType,\\n  event: PointerEventType,\\n  matches: Interactable[],\\n  matchElements: Element[],\\n  eventTarget: Node,\\n  scope: Scope,\\n) {\\n  for (let i = 0, len = matches.length; i &lt; len; i++) {\\n    const match = matches[i]\\n    const matchElement = matchElements[i]\\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\\n\\n    if (!matchAction) {\\n      continue\\n    }\\n\\n    const action = validateAction&lt;ActionName&gt;(matchAction, match, matchElement, eventTarget, scope)\\n\\n    if (action) {\\n      return {\\n        action,\\n        interactable: match,\\n        element: matchElement,\\n      }\\n    }\\n  }\\n\\n  return { action: null, interactable: null, element: null }\\n}\\n\\nfunction getActionInfo (\\n  interaction: Interaction,\\n  pointer: PointerType,\\n  event: PointerEventType,\\n  eventTarget: Node,\\n  scope: Scope,\\n) {\\n  let matches: Interactable[] = []\\n  let matchElements: Element[] = []\\n\\n  let element = eventTarget as Element\\n\\n  function pushMatches (interactable: Interactable) {\\n    matches.push(interactable)\\n    matchElements.push(element)\\n  }\\n\\n  while (is.element(element)) {\\n    matches = []\\n    matchElements = []\\n\\n    scope.interactables.forEachMatch(element, pushMatches)\\n\\n    const actionInfo = validateMatches(\\n      interaction,\\n      pointer,\\n      event,\\n      matches,\\n      matchElements,\\n      eventTarget,\\n      scope,\\n    )\\n\\n    if (actionInfo.action &amp;&amp; !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\\n      return actionInfo\\n    }\\n\\n    element = domUtils.parentNode(element) as Element\\n  }\\n\\n  return { action: null, interactable: null, element: null }\\n}\\n\\nfunction prepare (\\n  interaction: Interaction,\\n  {\\n    action,\\n    interactable,\\n    element,\\n  }: {\\n    action: ActionProps&lt;any&gt;\\n    interactable: Interactable\\n    element: Element\\n  },\\n  scope: Scope,\\n) {\\n  action = action || { name: null }\\n\\n  interaction.interactable = interactable\\n  interaction.element = element\\n  copyAction(interaction.prepared, action)\\n\\n  interaction.rect = interactable &amp;&amp; action.name ? interactable.getRect(element) : null\\n\\n  setInteractionCursor(interaction, scope)\\n\\n  scope.fire('autoStart:prepared', { interaction })\\n}\\n\\nfunction withinInteractionLimit&lt;T extends ActionName&gt; (\\n  interactable: Interactable,\\n  element: Element,\\n  action: ActionProps&lt;T&gt;,\\n  scope: Scope,\\n) {\\n  const options = interactable.options\\n  const maxActions = options[action.name].max\\n  const maxPerElement = options[action.name].maxPerElement\\n  const autoStartMax = scope.autoStart.maxInteractions\\n  let activeInteractions = 0\\n  let interactableCount = 0\\n  let elementCount = 0\\n\\n  // no actions if any of these values == 0\\n  if (!(maxActions &amp;&amp; maxPerElement &amp;&amp; autoStartMax)) {\\n    return false\\n  }\\n\\n  for (const interaction of scope.interactions.list) {\\n    const otherAction = interaction.prepared.name\\n\\n    if (!interaction.interacting()) {\\n      continue\\n    }\\n\\n    activeInteractions++\\n\\n    if (activeInteractions &gt;= autoStartMax) {\\n      return false\\n    }\\n\\n    if (interaction.interactable !== interactable) {\\n      continue\\n    }\\n\\n    interactableCount += otherAction === action.name ? 1 : 0\\n\\n    if (interactableCount &gt;= maxActions) {\\n      return false\\n    }\\n\\n    if (interaction.element === element) {\\n      elementCount++\\n\\n      if (otherAction === action.name &amp;&amp; elementCount &gt;= maxPerElement) {\\n        return false\\n      }\\n    }\\n  }\\n\\n  return autoStartMax &gt; 0\\n}\\n\\nfunction maxInteractions (newValue: any, scope: Scope) {\\n  if (is.number(newValue)) {\\n    scope.autoStart.maxInteractions = newValue\\n\\n    return this\\n  }\\n\\n  return scope.autoStart.maxInteractions\\n}\\n\\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\\n  const { cursorElement: prevCursorElement } = scope.autoStart\\n\\n  if (prevCursorElement &amp;&amp; prevCursorElement !== element) {\\n    prevCursorElement.style.cursor = ''\\n  }\\n\\n  element.ownerDocument.documentElement.style.cursor = cursor\\n  element.style.cursor = cursor\\n  scope.autoStart.cursorElement = cursor ? element : null\\n}\\n\\nfunction setInteractionCursor&lt;T extends ActionName&gt; (interaction: Interaction&lt;T&gt;, scope: Scope) {\\n  const { interactable, element, prepared } = interaction\\n\\n  if (!(interaction.pointerType === 'mouse' &amp;&amp; interactable &amp;&amp; interactable.options.styleCursor)) {\\n    // clear previous target element cursor\\n    if (scope.autoStart.cursorElement) {\\n      setCursor(scope.autoStart.cursorElement, '', scope)\\n    }\\n\\n    return\\n  }\\n\\n  let cursor = ''\\n\\n  if (prepared.name) {\\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\\n\\n    if (is.func(cursorChecker)) {\\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\\n    } else {\\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\\n    }\\n  }\\n\\n  setCursor(interaction.element, cursor || '', scope)\\n}\\n\\nconst autoStart: Plugin = {\\n  id: 'auto-start/base',\\n  before: ['actions'],\\n  install,\\n  listeners: {\\n    'interactions:down': prepareOnDown,\\n    'interactions:move': (arg, scope) =&gt; {\\n      prepareOnMove(arg, scope)\\n      startOnMove(arg, scope)\\n    },\\n    'interactions:stop': clearCursorOnStop,\\n  },\\n  maxInteractions,\\n  withinInteractionLimit,\\n  validateAction,\\n}\\n\\nexport default autoStart\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type Interaction from '@interactjs/core/Interaction'\\nimport type { SignalArgs, Scope, ActionName } from '@interactjs/core/scope'\\nimport type { Element } from '@interactjs/types/index'\\nimport { parentNode } from '@interactjs/utils/domUtils'\\nimport is from '@interactjs/utils/is'\\n\\nimport autoStart from './base'\\n\\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\\n  if (interaction.prepared.name !== 'drag') return\\n\\n  // check if a drag is in the correct axis\\n  const absX = Math.abs(dx)\\n  const absY = Math.abs(dy)\\n  const targetOptions = interaction.interactable.options.drag\\n  const startAxis = targetOptions.startAxis\\n  const currentAxis = absX &gt; absY ? 'x' : absX &lt; absY ? 'y' : 'xy'\\n\\n  interaction.prepared.axis =\\n    targetOptions.lockAxis === 'start'\\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\\n      : targetOptions.lockAxis\\n\\n  // if the movement isn't in the startAxis of the interactable\\n  if (currentAxis !== 'xy' &amp;&amp; startAxis !== 'xy' &amp;&amp; startAxis !== currentAxis) {\\n    // cancel the prepared action\\n    ;(interaction as Interaction&lt;ActionName&gt;).prepared.name = null\\n\\n    // then try to get a drag from another ineractable\\n    let element = eventTarget as Element\\n\\n    const getDraggable = function (interactable: Interactable): Interactable | void {\\n      if (interactable === interaction.interactable) return\\n\\n      const options = interaction.interactable.options.drag\\n\\n      if (!options.manualStart &amp;&amp; interactable.testIgnoreAllow(options, element, eventTarget)) {\\n        const action = interactable.getAction(\\n          interaction.downPointer,\\n          interaction.downEvent,\\n          interaction,\\n          element,\\n        )\\n\\n        if (\\n          action &amp;&amp;\\n          action.name === 'drag' &amp;&amp;\\n          checkStartAxis(currentAxis, interactable) &amp;&amp;\\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\\n        ) {\\n          return interactable\\n        }\\n      }\\n    }\\n\\n    // check all interactables\\n    while (is.element(element)) {\\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\\n\\n      if (interactable) {\\n        ;(interaction as Interaction&lt;ActionName&gt;).prepared.name = 'drag'\\n        interaction.interactable = interactable\\n        interaction.element = element\\n        break\\n      }\\n\\n      element = parentNode(element) as Element\\n    }\\n  }\\n}\\n\\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\\n  if (!interactable) {\\n    return false\\n  }\\n\\n  const thisAxis = interactable.options.drag.startAxis\\n\\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\\n}\\n\\nexport default {\\n  id: 'auto-start/dragAxis',\\n  listeners: { 'autoStart:before-start': beforeStart },\\n}\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\n\\nimport basePlugin from './base'\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface PerActionDefaults {\\n    hold?: number\\n    delay?: number\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    autoStartHoldTimer?: any\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  const { defaults } = scope\\n\\n  scope.usePlugin(basePlugin)\\n\\n  defaults.perAction.hold = 0\\n  defaults.perAction.delay = 0\\n}\\n\\nfunction getHoldDuration (interaction: Interaction) {\\n  const actionName = interaction.prepared &amp;&amp; interaction.prepared.name\\n\\n  if (!actionName) {\\n    return null\\n  }\\n\\n  const options = interaction.interactable.options\\n\\n  return options[actionName].hold || options[actionName].delay\\n}\\n\\nconst hold: Plugin = {\\n  id: 'auto-start/hold',\\n  install,\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.autoStartHoldTimer = null\\n    },\\n\\n    'autoStart:prepared': ({ interaction }) =&gt; {\\n      const hold = getHoldDuration(interaction)\\n\\n      if (hold &gt; 0) {\\n        interaction.autoStartHoldTimer = setTimeout(() =&gt; {\\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\\n        }, hold)\\n      }\\n    },\\n\\n    'interactions:move': ({ interaction, duplicate }) =&gt; {\\n      if (interaction.autoStartHoldTimer &amp;&amp; interaction.pointerWasMoved &amp;&amp; !duplicate) {\\n        clearTimeout(interaction.autoStartHoldTimer)\\n        interaction.autoStartHoldTimer = null\\n      }\\n    },\\n\\n    // prevent regular down-&gt;move autoStart\\n    'autoStart:before-start': ({ interaction }) =&gt; {\\n      const holdDuration = getHoldDuration(interaction)\\n\\n      if (holdDuration &gt; 0) {\\n        interaction.prepared.name = null\\n      }\\n    },\\n  },\\n  getHoldDuration,\\n}\\nexport default hold\\n\"</span>,<span class=\"code-string\">\"import type { Scope } from '@interactjs/core/scope'\\n\\nimport autoStart from './base'\\nimport dragAxis from './dragAxis'\\nimport hold from './hold'\\n\\nexport default {\\n  id: 'auto-start',\\n  install (scope: Scope) {\\n    scope.usePlugin(autoStart)\\n    scope.usePlugin(hold)\\n    scope.usePlugin(dragAxis)\\n  },\\n}\\n\"</span>,<span class=\"code-string\">\"export default {}\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type Interaction from '@interactjs/core/Interaction'\\nimport type { Scope } from '@interactjs/core/scope'\\nimport type { PointerEventType } from '@interactjs/types/index'\\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\\nimport is from '@interactjs/utils/is'\\nimport { getWindow } from '@interactjs/utils/window'\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    preventDefault: typeof preventDefault\\n    checkAndPreventDefault: (event: Event) =&gt; void\\n  }\\n}\\n\\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\\nfunction preventDefault(this: Interactable): PreventDefaultValue\\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\\n  if (/^(always|never|auto)$/.test(newValue)) {\\n    this.options.preventDefault = newValue\\n    return this\\n  }\\n\\n  if (is.bool(newValue)) {\\n    this.options.preventDefault = newValue ? 'always' : 'never'\\n    return this\\n  }\\n\\n  return this.options.preventDefault\\n}\\n\\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\\n  const setting = interactable.options.preventDefault\\n\\n  if (setting === 'never') return\\n\\n  if (setting === 'always') {\\n    event.preventDefault()\\n    return\\n  }\\n\\n  // setting === 'auto'\\n\\n  // if the browser supports passive event listeners and isn't running on iOS,\\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\\n  // user-select should be used instead of calling event.preventDefault().\\n  if (scope.events.supportsPassive &amp;&amp; /^touch(start|move)$/.test(event.type)) {\\n    const doc = getWindow(event.target).document\\n    const docOptions = scope.getDocOptions(doc)\\n\\n    if (!(docOptions &amp;&amp; docOptions.events) || docOptions.events.passive !== false) {\\n      return\\n    }\\n  }\\n\\n  // don't preventDefault of pointerdown events\\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\\n    return\\n  }\\n\\n  // don't preventDefault on editable elements\\n  if (\\n    is.element(event.target) &amp;&amp;\\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\\n  ) {\\n    return\\n  }\\n\\n  event.preventDefault()\\n}\\n\\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\\n  if (interaction.interactable) {\\n    interaction.interactable.checkAndPreventDefault(event as Event)\\n  }\\n}\\n\\nexport function install (scope: Scope) {\\n  /** @lends Interactable */\\n  const { Interactable } = scope\\n\\n  /**\\n   * Returns or sets whether to prevent the browser's default behaviour in\\n   * response to pointer events. Can be set to:\\n   *  - `'always'` to always prevent\\n   *  - `'never'` to never prevent\\n   *  - `'auto'` to let interact.js try to determine what would be best\\n   *\\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\\n   * @return {string | Interactable} The current setting or this Interactable\\n   */\\n  Interactable.prototype.preventDefault = preventDefault\\n\\n  Interactable.prototype.checkAndPreventDefault = function (event) {\\n    return checkAndPreventDefault(this, scope, event)\\n  }\\n\\n  // prevent native HTML5 drag on interact.js target elements\\n  scope.interactions.docEvents.push({\\n    type: 'dragstart',\\n    listener (event) {\\n      for (const interaction of scope.interactions.list) {\\n        if (\\n          interaction.element &amp;&amp;\\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\\n        ) {\\n          interaction.interactable.checkAndPreventDefault(event)\\n          return\\n        }\\n      }\\n    },\\n  })\\n}\\n\\nexport default {\\n  id: 'core/interactablePreventDefault',\\n  install,\\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) =&gt; {\\n    acc[`interactions:${eventType}`] = onInteractionEvent\\n    return acc\\n  }, {} as any),\\n}\\n\"</span>,<span class=\"code-string\">\"/* eslint-disable no-console */\\nimport type Interaction from '@interactjs/core/Interaction'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { Element, OptionMethod } from '@interactjs/types/index'\\nimport domObjects from '@interactjs/utils/domObjects'\\nimport { parentNode } from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\nimport * as win from '@interactjs/utils/window'\\n\\nimport type visualizer from './visualizer/plugin'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    logger: Logger\\n  }\\n}\\n\\ndeclare module '@interactjs/core/interactStatic' {\\n  export interface InteractStatic {\\n    visializer: typeof visualizer\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface BaseDefaults {\\n    devTools?: DevToolsOptions\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    devTools: OptionMethod&lt;DevToolsOptions&gt;\\n  }\\n}\\n\\nexport interface DevToolsOptions {\\n  ignore: { [P in keyof typeof CheckName]?: boolean }\\n}\\n\\nexport interface Logger {\\n  warn: (...args: any[]) =&gt; void\\n  error: (...args: any[]) =&gt; void\\n  log: (...args: any[]) =&gt; void\\n}\\n\\nexport interface Check {\\n  name: CheckName\\n  text: string\\n  perform: (interaction: Interaction) =&gt; boolean\\n  getInfo: (interaction: Interaction) =&gt; any[]\\n}\\n\\nenum CheckName {\\n  touchAction = 'touchAction',\\n  boxSizing = 'boxSizing',\\n  noListeners = 'noListeners',\\n}\\n\\nconst prefix = '[interact.js] '\\nconst links = {\\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\\n}\\n\\n// eslint-disable-next-line no-undef\\nconst isProduction = process.env.NODE_ENV === 'production'\\n\\n// eslint-disable-next-line no-restricted-syntax\\nfunction install (scope: Scope, { logger }: { logger?: Logger } = {}) {\\n  const { Interactable, defaults } = scope\\n\\n  scope.logger = logger || console\\n\\n  defaults.base.devTools = {\\n    ignore: {},\\n  }\\n\\n  Interactable.prototype.devTools = function (options?: object) {\\n    if (options) {\\n      extend(this.options.devTools, options)\\n      return this\\n    }\\n\\n    return this.options.devTools\\n  }\\n}\\n\\nconst checks: Check[] = [\\n  {\\n    name: CheckName.touchAction,\\n    perform ({ element }) {\\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\\n    },\\n    getInfo ({ element }) {\\n      return [element, links.touchAction]\\n    },\\n    text: 'Consider adding CSS \\\"touch-action: none\\\" to this element\\\\n',\\n  },\\n\\n  {\\n    name: CheckName.boxSizing,\\n    perform (interaction) {\\n      const { element } = interaction\\n\\n      return (\\n        interaction.prepared.name === 'resize' &amp;&amp;\\n        element instanceof domObjects.HTMLElement &amp;&amp;\\n        !hasStyle(element, 'boxSizing', /border-box/)\\n      )\\n    },\\n    text: 'Consider adding CSS \\\"box-sizing: border-box\\\" to this resizable element',\\n    getInfo ({ element }) {\\n      return [element, links.boxSizing]\\n    },\\n  },\\n\\n  {\\n    name: CheckName.noListeners,\\n    perform (interaction) {\\n      const actionName = interaction.prepared.name\\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\\n\\n      return !moveListeners.length\\n    },\\n    getInfo (interaction) {\\n      return [interaction.prepared.name, interaction.interactable]\\n    },\\n    text: 'There are no listeners set for this action',\\n  },\\n]\\n\\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\\n  return styleRe.test((value || '').toString())\\n}\\n\\nfunction parentHasStyle (element: Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\\n  let parent = element as HTMLElement\\n\\n  while (is.element(parent)) {\\n    if (hasStyle(parent, prop, styleRe)) {\\n      return true\\n    }\\n\\n    parent = parentNode(parent) as HTMLElement\\n  }\\n\\n  return false\\n}\\n\\nconst id = 'dev-tools'\\nconst defaultExport: Plugin = isProduction\\n  ? { id, install: () =&gt; {} }\\n  : {\\n    id,\\n    install,\\n    listeners: {\\n      'interactions:action-start': ({ interaction }, scope) =&gt; {\\n        for (const check of checks) {\\n          const options = interaction.interactable &amp;&amp; interaction.interactable.options\\n\\n          if (\\n            !(options &amp;&amp; options.devTools &amp;&amp; options.devTools.ignore[check.name]) &amp;&amp;\\n              check.perform(interaction)\\n          ) {\\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\\n          }\\n        }\\n      },\\n    },\\n    checks,\\n    CheckName,\\n    links,\\n    prefix,\\n  }\\n\\nexport default defaultExport\\n\"</span>,<span class=\"code-string\">\"import * as arr from './arr'\\nimport is from './is'\\n\\n// tslint:disable-next-line ban-types\\nexport default function clone&lt;T extends Object&gt; (source: T): Partial&lt;T&gt; {\\n  const dest = {} as Partial&lt;T&gt;\\n\\n  for (const prop in source) {\\n    const value = source[prop]\\n\\n    if (is.plainObject(value)) {\\n      dest[prop] = clone(value) as any\\n    } else if (is.array(value)) {\\n      dest[prop] = arr.from(value) as typeof value\\n    } else {\\n      dest[prop] = value\\n    }\\n  }\\n\\n  return dest\\n}\\n\"</span>,<span class=\"code-string\">\"import type { EventPhase } from '@interactjs/core/InteractEvent'\\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\\nimport clone from '@interactjs/utils/clone'\\nimport extend from '@interactjs/utils/extend'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\nimport type { Modifier, ModifierArg, ModifierState } from './base'\\n\\nexport interface ModificationResult {\\n  delta: Point\\n  rectDelta: Rect\\n  coords: Point\\n  rect: FullRect\\n  eventProps: any[]\\n  changed: boolean\\n}\\n\\ninterface MethodArg {\\n  phase: EventPhase\\n  pageCoords: Point\\n  rect: FullRect\\n  coords: Point\\n  preEnd?: boolean\\n  skipModifiers?: number\\n}\\n\\nexport default class Modification {\\n  states: ModifierState[] = []\\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\\n  startDelta!: Point\\n  result!: ModificationResult\\n  endResult!: Point\\n  edges!: EdgeOptions\\n  readonly interaction: Readonly&lt;Interaction&gt;\\n\\n  constructor (interaction: Interaction) {\\n    this.interaction = interaction\\n    this.result = createResult()\\n  }\\n\\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\\n    const { interaction } = this\\n    const modifierList = getModifierList(interaction)\\n    this.prepareStates(modifierList)\\n\\n    this.edges = extend({}, interaction.edges)\\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\\n    this.startDelta = { x: 0, y: 0 }\\n\\n    const arg = this.fillArg({\\n      phase,\\n      pageCoords,\\n      preEnd: false,\\n    })\\n\\n    this.result = createResult()\\n    this.startAll(arg)\\n\\n    const result = (this.result = this.setAll(arg))\\n\\n    return result\\n  }\\n\\n  fillArg (arg: Partial&lt;ModifierArg&gt;) {\\n    const { interaction } = this\\n\\n    arg.interaction = interaction\\n    arg.interactable = interaction.interactable\\n    arg.element = interaction.element\\n    arg.rect = arg.rect || interaction.rect\\n    arg.edges = this.edges\\n    arg.startOffset = this.startOffset\\n\\n    return arg as ModifierArg\\n  }\\n\\n  startAll (arg: MethodArg &amp; Partial&lt;ModifierArg&gt;) {\\n    for (const state of this.states) {\\n      if (state.methods.start) {\\n        arg.state = state\\n        state.methods.start(arg as ModifierArg)\\n      }\\n    }\\n  }\\n\\n  setAll (arg: MethodArg &amp; Partial&lt;ModifierArg&gt;): ModificationResult {\\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect } = arg\\n\\n    arg.coords = extend({}, arg.pageCoords)\\n    arg.rect = extend({}, unmodifiedRect)\\n\\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\\n\\n    const newResult = createResult(arg.coords, arg.rect)\\n\\n    for (const state of states) {\\n      const { options } = state\\n      const lastModifierCoords = extend({}, arg.coords)\\n      let returnValue = null\\n\\n      if (state.methods?.set &amp;&amp; this.shouldDo(options, preEnd, phase)) {\\n        arg.state = state\\n        returnValue = state.methods.set(arg as ModifierArg&lt;never&gt;)\\n\\n        rectUtils.addEdges(this.interaction.edges, arg.rect, {\\n          x: arg.coords.x - lastModifierCoords.x,\\n          y: arg.coords.y - lastModifierCoords.y,\\n        })\\n      }\\n\\n      newResult.eventProps.push(returnValue)\\n    }\\n\\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\\n\\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\\n\\n    const prevCoords = this.result.coords\\n    const prevRect = this.result.rect\\n\\n    if (prevCoords &amp;&amp; prevRect) {\\n      const rectChanged =\\n        newResult.rect.left !== prevRect.left ||\\n        newResult.rect.right !== prevRect.right ||\\n        newResult.rect.top !== prevRect.top ||\\n        newResult.rect.bottom !== prevRect.bottom\\n\\n      newResult.changed =\\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\\n    }\\n\\n    return newResult\\n  }\\n\\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\\n    const { interaction } = this\\n    const { phase } = arg\\n    const curCoords = interaction.coords.cur\\n    const startCoords = interaction.coords.start\\n    const { result, startDelta } = this\\n    const curDelta = result.delta\\n\\n    if (phase === 'start') {\\n      extend(this.startDelta, result.delta)\\n    }\\n\\n    for (const [coordsSet, delta] of [\\n      [startCoords, startDelta],\\n      [curCoords, curDelta],\\n    ] as const) {\\n      coordsSet.page.x += delta.x\\n      coordsSet.page.y += delta.y\\n      coordsSet.client.x += delta.x\\n      coordsSet.client.y += delta.y\\n    }\\n\\n    const { rectDelta } = this.result\\n    const rect = arg.rect || interaction.rect\\n\\n    rect.left += rectDelta.left\\n    rect.right += rectDelta.right\\n    rect.top += rectDelta.top\\n    rect.bottom += rectDelta.bottom\\n\\n    rect.width = rect.right - rect.left\\n    rect.height = rect.bottom - rect.top\\n  }\\n\\n  setAndApply (\\n    arg: Partial&lt;DoAnyPhaseArg&gt; &amp; {\\n      phase: EventPhase\\n      preEnd?: boolean\\n      skipModifiers?: number\\n      modifiedCoords?: Point\\n    },\\n  ): void | false {\\n    const { interaction } = this\\n    const { phase, preEnd, skipModifiers } = arg\\n\\n    const result = this.setAll(\\n      this.fillArg({\\n        preEnd,\\n        phase,\\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\\n      }),\\n    )\\n\\n    this.result = result\\n\\n    // don't fire an action move if a modifier would keep the event in the same\\n    // cordinates as before\\n    if (\\n      !result.changed &amp;&amp;\\n      (!skipModifiers || skipModifiers &lt; this.states.length) &amp;&amp;\\n      interaction.interacting()\\n    ) {\\n      return false\\n    }\\n\\n    if (arg.modifiedCoords) {\\n      const { page } = interaction.coords.cur\\n      const adjustment = {\\n        x: arg.modifiedCoords.x - page.x,\\n        y: arg.modifiedCoords.y - page.y,\\n      }\\n\\n      result.coords.x += adjustment.x\\n      result.coords.y += adjustment.y\\n      result.delta.x += adjustment.x\\n      result.delta.y += adjustment.y\\n    }\\n\\n    this.applyToInteraction(arg)\\n  }\\n\\n  beforeEnd (arg: Omit&lt;DoAnyPhaseArg, 'iEvent'&gt; &amp; { state?: ModifierState }): void | false {\\n    const { interaction, event } = arg\\n    const states = this.states\\n\\n    if (!states || !states.length) {\\n      return\\n    }\\n\\n    let doPreend = false\\n\\n    for (const state of states) {\\n      arg.state = state\\n      const { options, methods } = state\\n\\n      const endPosition = methods.beforeEnd &amp;&amp; methods.beforeEnd((arg as unknown) as ModifierArg)\\n\\n      if (endPosition) {\\n        this.endResult = endPosition\\n        return false\\n      }\\n\\n      doPreend = doPreend || (!doPreend &amp;&amp; this.shouldDo(options, true, arg.phase, true))\\n    }\\n\\n    if (doPreend) {\\n      // trigger a final modified move before ending\\n      interaction.move({ event, preEnd: true })\\n    }\\n  }\\n\\n  stop (arg: { interaction: Interaction }) {\\n    const { interaction } = arg\\n\\n    if (!this.states || !this.states.length) {\\n      return\\n    }\\n\\n    const modifierArg: Partial&lt;ModifierArg&gt; = extend(\\n      {\\n        states: this.states,\\n        interactable: interaction.interactable,\\n        element: interaction.element,\\n        rect: null,\\n      },\\n      arg,\\n    )\\n\\n    this.fillArg(modifierArg)\\n\\n    for (const state of this.states) {\\n      modifierArg.state = state\\n\\n      if (state.methods.stop) {\\n        state.methods.stop(modifierArg as ModifierArg)\\n      }\\n    }\\n\\n    this.states = null\\n    this.endResult = null\\n  }\\n\\n  prepareStates (modifierList: Modifier[]) {\\n    this.states = []\\n\\n    for (let index = 0; index &lt; modifierList.length; index++) {\\n      const { options, methods, name } = modifierList[index]\\n\\n      this.states.push({\\n        options,\\n        methods,\\n        index,\\n        name,\\n      })\\n    }\\n\\n    return this.states\\n  }\\n\\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\\n    if (!modification.result) return\\n\\n    const { startDelta } = modification\\n    const { delta: curDelta, rectDelta } = modification.result\\n\\n    const coordsAndDeltas = [\\n      [coords.start, startDelta],\\n      [coords.cur, curDelta],\\n    ]\\n\\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\\n      coordsSet.page.x -= delta.x\\n      coordsSet.page.y -= delta.y\\n      coordsSet.client.x -= delta.x\\n      coordsSet.client.y -= delta.y\\n    }\\n\\n    rect.left -= rectDelta.left\\n    rect.right -= rectDelta.right\\n    rect.top -= rectDelta.top\\n    rect.bottom -= rectDelta.bottom\\n  }\\n\\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\\n    if (\\n      // ignore disabled modifiers\\n      !options ||\\n      options.enabled === false ||\\n      // check if we require endOnly option to fire move before end\\n      (requireEndOnly &amp;&amp; !options.endOnly) ||\\n      // don't apply endOnly modifiers when not ending\\n      (options.endOnly &amp;&amp; !preEnd) ||\\n      // check if modifier should run be applied on start\\n      (phase === 'start' &amp;&amp; !options.setStart)\\n    ) {\\n      return false\\n    }\\n\\n    return true\\n  }\\n\\n  copyFrom (other: Modification) {\\n    this.startOffset = other.startOffset\\n    this.startDelta = other.startDelta\\n    this.edges = other.edges\\n    this.states = other.states.map(s =&gt; clone(s) as ModifierState)\\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\\n  }\\n\\n  destroy () {\\n    for (const prop in this) {\\n      this[prop] = null\\n    }\\n  }\\n}\\n\\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\\n  return {\\n    rect,\\n    coords,\\n    delta: { x: 0, y: 0 },\\n    rectDelta: {\\n      left: 0,\\n      right: 0,\\n      top: 0,\\n      bottom: 0,\\n    },\\n    eventProps: [],\\n    changed: true,\\n  }\\n}\\n\\nfunction getModifierList (interaction) {\\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\\n  const actionModifiers = actionOptions.modifiers\\n\\n  if (actionModifiers &amp;&amp; actionModifiers.length) {\\n    return actionModifiers\\n  }\\n\\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\\n    .map(type =&gt; {\\n      const options = actionOptions[type]\\n\\n      return (\\n        options &amp;&amp;\\n        options.enabled &amp;&amp; {\\n          options,\\n          methods: options._methods,\\n        }\\n      )\\n    })\\n    .filter(m =&gt; !!m)\\n}\\n\\nexport function getRectOffset (rect, coords) {\\n  return rect\\n    ? {\\n      left: coords.x - rect.left,\\n      top: coords.y - rect.top,\\n      right: rect.right - coords.x,\\n      bottom: rect.bottom - coords.y,\\n    }\\n    : {\\n      left: 0,\\n      top: 0,\\n      right: 0,\\n      bottom: 0,\\n    }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\\nimport type { Interactable } from '@interactjs/core/Interactable'\\nimport type Interaction from '@interactjs/core/Interaction'\\nimport type { Plugin } from '@interactjs/core/scope'\\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\\n\\nimport Modification from './Modification'\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    modification?: Modification\\n  }\\n}\\n\\ndeclare module '@interactjs/core/InteractEvent' {\\n  interface InteractEvent {\\n    modifiers?: Array&lt;{\\n      name: string\\n      [key: string]: any\\n    }&gt;\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface PerActionDefaults {\\n    modifiers?: Modifier[]\\n  }\\n}\\n\\nexport interface Modifier&lt;\\n  Defaults = any,\\n  State extends ModifierState = any,\\n  Name extends string = any,\\n  Result = any\\n&gt; {\\n  options: Defaults\\n  methods: {\\n    start?: (arg: ModifierArg&lt;State&gt;) =&gt; void\\n    set?: (arg: ModifierArg&lt;State&gt;) =&gt; Result\\n    beforeEnd?: (arg: ModifierArg&lt;State&gt;) =&gt; Point | void\\n    stop?: (arg: ModifierArg&lt;State&gt;) =&gt; void\\n  }\\n  name?: Name\\n  enable: () =&gt; Modifier&lt;Defaults, State, Name, Result&gt;\\n  disable: () =&gt; Modifier&lt;Defaults, State, Name, Result&gt;\\n}\\n\\nexport type ModifierState&lt;Defaults = unknown, StateProps = unknown, Name extends string = any&gt; = {\\n  options: Defaults\\n  methods?: Modifier&lt;Defaults&gt;['methods']\\n  index?: number\\n  name?: Name\\n} &amp; StateProps\\n\\nexport interface ModifierArg&lt;State extends ModifierState = ModifierState&gt; {\\n  interaction: Interaction\\n  interactable: Interactable\\n  phase: EventPhase\\n  rect: FullRect\\n  edges: EdgeOptions\\n  state: State\\n  element: Element\\n  pageCoords: Point\\n  prevCoords: Point\\n  prevRect?: FullRect\\n  coords: Point\\n  startOffset: Rect\\n  preEnd?: boolean\\n}\\n\\nexport interface ModifierModule&lt;\\n  Defaults extends { enabled?: boolean },\\n  State extends ModifierState,\\n  Result = unknown\\n&gt; {\\n  defaults?: Defaults\\n  start?(arg: ModifierArg&lt;State&gt;): void\\n  set?(arg: ModifierArg&lt;State&gt;): Result\\n  beforeEnd?(arg: ModifierArg&lt;State&gt;): Point | void\\n  stop?(arg: ModifierArg&lt;State&gt;): void\\n}\\n\\nexport interface ModifierFunction&lt;\\n  Defaults extends { enabled?: boolean },\\n  State extends ModifierState,\\n  Name extends string\\n&gt; {\\n  (_options?: Partial&lt;Defaults&gt;): Modifier&lt;Defaults, State, Name&gt;\\n  _defaults: Defaults\\n  _methods: ModifierModule&lt;Defaults, State&gt;\\n}\\n\\nexport function makeModifier&lt;\\n  Defaults extends { enabled?: boolean },\\n  State extends ModifierState,\\n  Name extends string,\\n  Result\\n&gt; (module: ModifierModule&lt;Defaults, State, Result&gt;, name?: Name) {\\n  const { defaults } = module\\n  const methods = {\\n    start: module.start,\\n    set: module.set,\\n    beforeEnd: module.beforeEnd,\\n    stop: module.stop,\\n  }\\n\\n  const modifier = (_options?: Partial&lt;Defaults&gt;) =&gt; {\\n    const options = (_options || {}) as Defaults\\n\\n    options.enabled = options.enabled !== false\\n\\n    // add missing defaults to options\\n    for (const prop in defaults) {\\n      if (!(prop in options)) {\\n        ;(options as any)[prop] = defaults[prop]\\n      }\\n    }\\n\\n    const m: Modifier&lt;Defaults, State, Name, Result&gt; = {\\n      options,\\n      methods,\\n      name,\\n      enable: () =&gt; {\\n        options.enabled = true\\n        return m\\n      },\\n      disable: () =&gt; {\\n        options.enabled = false\\n        return m\\n      },\\n    }\\n\\n    return m\\n  }\\n\\n  if (name &amp;&amp; typeof name === 'string') {\\n    // for backwrads compatibility\\n    modifier._defaults = defaults\\n    modifier._methods = methods\\n  }\\n\\n  return modifier\\n}\\n\\nexport function addEventModifiers ({\\n  iEvent,\\n  interaction,\\n}: {\\n  iEvent: InteractEvent&lt;any&gt;\\n  interaction: Interaction&lt;any&gt;\\n}) {\\n  const result = interaction.modification!.result\\n\\n  if (result) {\\n    iEvent.modifiers = result.eventProps\\n  }\\n}\\n\\nconst modifiersBase: Plugin = {\\n  id: 'modifiers/base',\\n  before: ['actions'],\\n  install: scope =&gt; {\\n    scope.defaults.perAction.modifiers = []\\n  },\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.modification = new Modification(interaction)\\n    },\\n\\n    'interactions:before-action-start': arg =&gt; {\\n      const modification = arg.interaction.modification!\\n\\n      modification.start(arg, arg.interaction.coords.start.page)\\n      arg.interaction.edges = modification.edges\\n      modification.applyToInteraction(arg)\\n    },\\n\\n    'interactions:before-action-move': arg =&gt; arg.interaction.modification.setAndApply(arg),\\n\\n    'interactions:before-action-end': arg =&gt; arg.interaction.modification.beforeEnd(arg),\\n\\n    'interactions:action-start': addEventModifiers,\\n    'interactions:action-move': addEventModifiers,\\n    'interactions:action-end': addEventModifiers,\\n\\n    'interactions:after-action-start': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\\n    'interactions:after-action-move': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\\n\\n    'interactions:stop': arg =&gt; arg.interaction.modification.stop(arg),\\n  },\\n}\\n\\nexport default modifiersBase\\n\"</span>,<span class=\"code-string\">\"import type { Point, Listeners, OrBoolean, Element } from '@interactjs/types/index'\\n\\nexport interface Defaults {\\n  base: BaseDefaults\\n  perAction: PerActionDefaults\\n  actions: ActionDefaults\\n}\\n\\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\\nexport interface ActionDefaults {}\\n\\nexport interface BaseDefaults {\\n  preventDefault?: 'auto' | 'never' | string\\n  deltaSource?: 'page' | 'client'\\n  context?: Node\\n}\\n\\nexport interface PerActionDefaults {\\n  enabled?: boolean\\n  origin?: Point | string | Element\\n  listeners?: Listeners\\n  allowFrom?: string | Element\\n  ignoreFrom?: string | Element\\n}\\n\\nexport type Options = Partial&lt;BaseDefaults&gt; &amp;\\nPartial&lt;PerActionDefaults&gt; &amp;\\n{\\n  [P in keyof ActionDefaults]?: Partial&lt;ActionDefaults[P]&gt;\\n}\\n\\n// export interface Options extends BaseDefaults, PerActionDefaults {}\\n\\nexport interface OptionsArg extends BaseDefaults, OrBoolean&lt;Partial&lt;ActionDefaults&gt;&gt; {}\\n\\nexport const defaults: Defaults = {\\n  base: {\\n    preventDefault: 'auto',\\n    deltaSource: 'page',\\n  },\\n\\n  perAction: {\\n    enabled: false,\\n    origin: { x: 0, y: 0 },\\n  },\\n\\n  actions: {} as ActionDefaults,\\n}\\n\"</span>,<span class=\"code-string\">\"import type { ActionName } from '@interactjs/core/scope'\\nimport type { Point, FullRect, PointerEventType, Element } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport getOriginXY from '@interactjs/utils/getOriginXY'\\nimport hypot from '@interactjs/utils/hypot'\\n\\nimport { BaseEvent } from './BaseEvent'\\nimport type { Interaction } from './Interaction'\\nimport { defaults } from './defaultOptions'\\n\\nexport type EventPhase = keyof PhaseMap\\n\\nexport interface PhaseMap {\\n  start: true\\n  move: true\\n  end: true\\n}\\n\\n// defined outside of class definition to avoid assignment of undefined during\\n// construction\\nexport interface InteractEvent {\\n  pageX: number\\n  pageY: number\\n\\n  clientX: number\\n  clientY: number\\n\\n  dx: number\\n  dy: number\\n\\n  velocityX: number\\n  velocityY: number\\n}\\n\\nexport class InteractEvent&lt;\\n  T extends ActionName = never,\\n  P extends EventPhase = EventPhase\\n&gt; extends BaseEvent&lt;T&gt; {\\n  target: Element\\n  currentTarget: Element\\n  relatedTarget: Element | null = null\\n  screenX?: number\\n  screenY?: number\\n  button: number\\n  buttons: number\\n  ctrlKey: boolean\\n  shiftKey: boolean\\n  altKey: boolean\\n  metaKey: boolean\\n  page: Point\\n  client: Point\\n  delta: Point\\n  rect: FullRect\\n  x0: number\\n  y0: number\\n  t0: number\\n  dt: number\\n  duration: number\\n  clientX0: number\\n  clientY0: number\\n  velocity: Point\\n  speed: number\\n  swipe: ReturnType&lt;InteractEvent&lt;T&gt;['getSwipe']&gt;\\n  timeStamp: any\\n  // resize\\n  axes?: 'x' | 'y' | 'xy'\\n  preEnd?: boolean\\n\\n  /** */\\n  constructor (\\n    interaction: Interaction&lt;T&gt;,\\n    event: PointerEventType,\\n    actionName: T,\\n    phase: P,\\n    element: Element,\\n    preEnd?: boolean,\\n    type?: string,\\n  ) {\\n    super(interaction)\\n\\n    element = element || interaction.element\\n\\n    const target = interaction.interactable\\n    const deltaSource = (((target &amp;&amp; target.options) || defaults) as any).deltaSource as 'page' | 'client'\\n    const origin = getOriginXY(target, element, actionName)\\n    const starting = phase === 'start'\\n    const ending = phase === 'end'\\n    const prevEvent = starting ? this : interaction.prevEvent\\n    const coords = starting\\n      ? interaction.coords.start\\n      : ending\\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\\n        : interaction.coords.cur\\n\\n    this.page = extend({}, coords.page)\\n    this.client = extend({}, coords.client)\\n    this.rect = extend({}, interaction.rect)\\n    this.timeStamp = coords.timeStamp\\n\\n    if (!ending) {\\n      this.page.x -= origin.x\\n      this.page.y -= origin.y\\n\\n      this.client.x -= origin.x\\n      this.client.y -= origin.y\\n    }\\n\\n    this.ctrlKey = event.ctrlKey\\n    this.altKey = event.altKey\\n    this.shiftKey = event.shiftKey\\n    this.metaKey = event.metaKey\\n    this.button = (event as MouseEvent).button\\n    this.buttons = (event as MouseEvent).buttons\\n    this.target = element\\n    this.currentTarget = element\\n    this.preEnd = preEnd\\n    this.type = type || actionName + (phase || '')\\n    this.interactable = target\\n\\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\\n\\n    this.x0 = interaction.coords.start.page.x - origin.x\\n    this.y0 = interaction.coords.start.page.y - origin.y\\n    this.clientX0 = interaction.coords.start.client.x - origin.x\\n    this.clientY0 = interaction.coords.start.client.y - origin.y\\n\\n    if (starting || ending) {\\n      this.delta = { x: 0, y: 0 }\\n    } else {\\n      this.delta = {\\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\\n      }\\n    }\\n\\n    this.dt = interaction.coords.delta.timeStamp\\n    this.duration = this.timeStamp - this.t0\\n\\n    // velocity and speed in pixels per second\\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\\n    this.speed = hypot(this.velocity.x, this.velocity.y)\\n\\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\\n  }\\n\\n  getSwipe () {\\n    const interaction = this._interaction\\n\\n    if (interaction.prevEvent.speed &lt; 600 || this.timeStamp - interaction.prevEvent.timeStamp &gt; 150) {\\n      return null\\n    }\\n\\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\\n    const overlap = 22.5\\n\\n    if (angle &lt; 0) {\\n      angle += 360\\n    }\\n\\n    const left = 135 - overlap &lt;= angle &amp;&amp; angle &lt; 225 + overlap\\n    const up = 225 - overlap &lt;= angle &amp;&amp; angle &lt; 315 + overlap\\n\\n    const right = !left &amp;&amp; (315 - overlap &lt;= angle || angle &lt; 45 + overlap)\\n    const down = !up &amp;&amp; 45 - overlap &lt;= angle &amp;&amp; angle &lt; 135 + overlap\\n\\n    return {\\n      up,\\n      down,\\n      left,\\n      right,\\n      angle,\\n      speed: interaction.prevEvent.speed,\\n      velocity: {\\n        x: interaction.prevEvent.velocityX,\\n        y: interaction.prevEvent.velocityY,\\n      },\\n    }\\n  }\\n\\n  preventDefault () {}\\n\\n  /**\\n   * Don't call listeners on the remaining targets\\n   */\\n  stopImmediatePropagation () {\\n    this.immediatePropagationStopped = this.propagationStopped = true\\n  }\\n\\n  /**\\n   * Don't call any other listeners (even on the current target)\\n   */\\n  stopPropagation () {\\n    this.propagationStopped = true\\n  }\\n}\\n\\n// getters and setters defined here to support typescript 3.6 and below which\\n// don't support getter and setters in .d.ts files\\nObject.defineProperties(InteractEvent.prototype, {\\n  pageX: {\\n    get () {\\n      return this.page.x\\n    },\\n    set (value) {\\n      this.page.x = value\\n    },\\n  },\\n  pageY: {\\n    get () {\\n      return this.page.y\\n    },\\n    set (value) {\\n      this.page.y = value\\n    },\\n  },\\n\\n  clientX: {\\n    get () {\\n      return this.client.x\\n    },\\n    set (value) {\\n      this.client.x = value\\n    },\\n  },\\n  clientY: {\\n    get () {\\n      return this.client.y\\n    },\\n    set (value) {\\n      this.client.y = value\\n    },\\n  },\\n\\n  dx: {\\n    get () {\\n      return this.delta.x\\n    },\\n    set (value) {\\n      this.delta.x = value\\n    },\\n  },\\n  dy: {\\n    get () {\\n      return this.delta.y\\n    },\\n    set (value) {\\n      this.delta.y = value\\n    },\\n  },\\n\\n  velocityX: {\\n    get () {\\n      return this.velocity.x\\n    },\\n    set (value) {\\n      this.velocity.x = value\\n    },\\n  },\\n  velocityY: {\\n    get () {\\n      return this.velocity.y\\n    },\\n    set (value) {\\n      this.velocity.y = value\\n    },\\n  },\\n})\\n\"</span>,<span class=\"code-string\">\"import type { PointerEventType, PointerType } from '@interactjs/types/index'\\n\\nexport class PointerInfo {\\n  id: number\\n  pointer: PointerType\\n  event: PointerEventType\\n  downTime: number\\n  downTarget: Node\\n\\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\\n    this.id = id\\n    this.pointer = pointer\\n    this.event = event\\n    this.downTime = downTime\\n    this.downTarget = downTarget\\n  }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { ActionDefaults } from '@interactjs/core/defaultOptions'\\nimport type {\\n  Element,\\n  EdgeOptions,\\n  PointerEventType,\\n  PointerType,\\n  FullRect,\\n  CoordsSet,\\n} from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport extend from '@interactjs/utils/extend'\\nimport hypot from '@interactjs/utils/hypot'\\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\nimport type { EventPhase } from './InteractEvent'\\nimport { InteractEvent } from './InteractEvent'\\nimport type { Interactable } from './Interactable'\\nimport { PointerInfo } from './PointerInfo'\\nimport type { ActionName, Scope } from './scope'\\n\\nexport interface ActionProps&lt;T extends ActionName | null = never&gt; {\\n  name: T\\n  axis?: 'x' | 'y' | 'xy' | null\\n  edges?: EdgeOptions | null\\n}\\n\\nexport enum _ProxyValues {\\n  interactable = '',\\n  element = '',\\n  prepared = '',\\n  pointerIsDown = '',\\n  pointerWasMoved = '',\\n  _proxy = '',\\n}\\n\\nexport enum _ProxyMethods {\\n  start = '',\\n  move = '',\\n  end = '',\\n  stop = '',\\n  interacting = '',\\n}\\n\\nexport type PointerArgProps&lt;T extends {} = {}&gt; = {\\n  pointer: PointerType\\n  event: PointerEventType\\n  eventTarget: Node\\n  pointerIndex: number\\n  pointerInfo: PointerInfo\\n  interaction: Interaction&lt;never&gt;\\n} &amp; T\\n\\nexport interface DoPhaseArg&lt;T extends ActionName, P extends EventPhase&gt; {\\n  event: PointerEventType\\n  phase: EventPhase\\n  interaction: Interaction&lt;T&gt;\\n  iEvent: InteractEvent&lt;T, P&gt;\\n  preEnd?: boolean\\n  type?: string\\n}\\n\\nexport type DoAnyPhaseArg = DoPhaseArg&lt;ActionName, EventPhase&gt;\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'interactions:new': { interaction: Interaction&lt;ActionName&gt; }\\n    'interactions:down': PointerArgProps&lt;{\\n      type: 'down'\\n    }&gt;\\n    'interactions:move': PointerArgProps&lt;{\\n      type: 'move'\\n      dx: number\\n      dy: number\\n      duplicate: boolean\\n    }&gt;\\n    'interactions:up': PointerArgProps&lt;{\\n      type: 'up'\\n      curEventTarget: EventTarget\\n    }&gt;\\n    'interactions:cancel': SignalArgs['interactions:up'] &amp; {\\n      type: 'cancel'\\n      curEventTarget: EventTarget\\n    }\\n    'interactions:update-pointer': PointerArgProps&lt;{\\n      down: boolean\\n    }&gt;\\n    'interactions:remove-pointer': PointerArgProps\\n    'interactions:blur': { interaction: Interaction&lt;never&gt;, event: Event, type: 'blur' }\\n    'interactions:before-action-start': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\\n    'interactions:action-start': DoAnyPhaseArg\\n    'interactions:after-action-start': DoAnyPhaseArg\\n    'interactions:before-action-move': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\\n    'interactions:action-move': DoAnyPhaseArg\\n    'interactions:after-action-move': DoAnyPhaseArg\\n    'interactions:before-action-end': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\\n    'interactions:action-end': DoAnyPhaseArg\\n    'interactions:after-action-end': DoAnyPhaseArg\\n    'interactions:stop': { interaction: Interaction }\\n  }\\n}\\n\\nexport type InteractionProxy&lt;T extends ActionName | null = never&gt; = Pick&lt;\\nInteraction&lt;T&gt;,\\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\\n&gt;\\n\\nlet idCounter = 0\\n\\nexport class Interaction&lt;T extends ActionName | null = ActionName&gt; {\\n  // current interactable being interacted with\\n  interactable: Interactable = null\\n\\n  // the target element of the interactable\\n  element: Element = null\\n  rect: FullRect\\n  _rects?: {\\n    start: FullRect\\n    corrected: FullRect\\n    previous: FullRect\\n    delta: FullRect\\n  }\\n  edges: EdgeOptions\\n\\n  _scopeFire: Scope['fire']\\n\\n  // action that's ready to be fired on next move event\\n  prepared: ActionProps&lt;T&gt; = {\\n    name: null,\\n    axis: null,\\n    edges: null,\\n  }\\n\\n  pointerType: string\\n\\n  // keep track of added pointers\\n  pointers: PointerInfo[] = []\\n\\n  // pointerdown/mousedown/touchstart event\\n  downEvent: PointerEventType = null\\n\\n  downPointer: PointerType = {} as PointerType\\n\\n  _latestPointer: {\\n    pointer: PointerType\\n    event: PointerEventType\\n    eventTarget: Node\\n  } = {\\n    pointer: null,\\n    event: null,\\n    eventTarget: null,\\n  }\\n\\n  // previous action event\\n  prevEvent: InteractEvent&lt;T, EventPhase&gt; = null\\n\\n  pointerIsDown = false\\n  pointerWasMoved = false\\n  _interacting = false\\n  _ending = false\\n  _stopped = true\\n  _proxy: InteractionProxy&lt;T&gt; = null\\n\\n  simulation = null\\n\\n  /** @internal */ get pointerMoveTolerance () {\\n    return 1\\n  }\\n\\n  /**\\n   * @alias Interaction.prototype.move\\n   */\\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\\n    this.move(signalArg)\\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\\n\\n  coords: CoordsSet = {\\n    // Starting InteractEvent pointer coordinates\\n    start: pointerUtils.newCoords(),\\n    // Previous native pointer move event coordinates\\n    prev: pointerUtils.newCoords(),\\n    // current native pointer move event coordinates\\n    cur: pointerUtils.newCoords(),\\n    // Change in coordinates and time of the pointer\\n    delta: pointerUtils.newCoords(),\\n    // pointer velocity\\n    velocity: pointerUtils.newCoords(),\\n  }\\n\\n  readonly _id: number = idCounter++\\n\\n  /** */\\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\\n    this._scopeFire = scopeFire\\n    this.pointerType = pointerType\\n\\n    const that = this\\n\\n    this._proxy = {} as InteractionProxy&lt;T&gt;\\n\\n    for (const key in _ProxyValues) {\\n      Object.defineProperty(this._proxy, key, {\\n        get () {\\n          return that[key]\\n        },\\n      })\\n    }\\n\\n    for (const key in _ProxyMethods) {\\n      Object.defineProperty(this._proxy, key, {\\n        value: (...args: any[]) =&gt; that[key](...args),\\n      })\\n    }\\n\\n    this._scopeFire('interactions:new', { interaction: this })\\n  }\\n\\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\\n    const pointerInfo = this.pointers[pointerIndex]\\n\\n    this._scopeFire('interactions:down', {\\n      pointer,\\n      event,\\n      eventTarget,\\n      pointerIndex,\\n      pointerInfo,\\n      type: 'down',\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    })\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable({\\n   *     // disable the default drag start by down-&gt;move\\n   *     manualStart: true\\n   *   })\\n   *   // start dragging after the user holds the pointer down\\n   *   .on('hold', function (event) {\\n   *     var interaction = event.interaction\\n   *\\n   *     if (!interaction.interacting()) {\\n   *       interaction.start({ name: 'drag' },\\n   *                         event.interactable,\\n   *                         event.currentTarget)\\n   *     }\\n   * })\\n   * ```\\n   *\\n   * Start an action with the given Interactable and Element as tartgets. The\\n   * action must be enabled for the target Interactable and an appropriate\\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\\n   *\\n   * Use it with `interactable.&lt;action&gt;able({ manualStart: false })` to always\\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\\n   *\\n   * @param {object} action   The action to be performed - drag, resize, etc.\\n   * @param {Interactable} target  The Interactable to target\\n   * @param {Element} element The DOM Element to target\\n   * @return {Boolean} Whether the interaction was successfully started\\n   */\\n  start&lt;A extends ActionName&gt; (action: ActionProps&lt;A&gt;, interactable: Interactable, element: Element): boolean {\\n    if (\\n      this.interacting() ||\\n      !this.pointerIsDown ||\\n      this.pointers.length &lt; (action.name === 'gesture' ? 2 : 1) ||\\n      !interactable.options[action.name as keyof ActionDefaults].enabled\\n    ) {\\n      return false\\n    }\\n\\n    copyAction(this.prepared, action)\\n\\n    this.interactable = interactable\\n    this.element = element\\n    this.rect = interactable.getRect(element)\\n    this.edges = this.prepared.edges\\n      ? extend({}, this.prepared.edges)\\n      : { left: true, right: true, top: true, bottom: true }\\n    this._stopped = false\\n    this._interacting =\\n      this._doPhase({\\n        interaction: this,\\n        event: this.downEvent,\\n        phase: 'start',\\n      }) &amp;&amp; !this._stopped\\n\\n    return this._interacting\\n  }\\n\\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\\n    if (!this.simulation &amp;&amp; !(this.modification &amp;&amp; this.modification.endResult)) {\\n      this.updatePointer(pointer, event, eventTarget, false)\\n    }\\n\\n    const duplicateMove =\\n      this.coords.cur.page.x === this.coords.prev.page.x &amp;&amp;\\n      this.coords.cur.page.y === this.coords.prev.page.y &amp;&amp;\\n      this.coords.cur.client.x === this.coords.prev.client.x &amp;&amp;\\n      this.coords.cur.client.y === this.coords.prev.client.y\\n\\n    let dx: number\\n    let dy: number\\n\\n    // register movement greater than pointerMoveTolerance\\n    if (this.pointerIsDown &amp;&amp; !this.pointerWasMoved) {\\n      dx = this.coords.cur.client.x - this.coords.start.client.x\\n      dy = this.coords.cur.client.y - this.coords.start.client.y\\n\\n      this.pointerWasMoved = hypot(dx, dy) &gt; this.pointerMoveTolerance\\n    }\\n\\n    const pointerIndex = this.getPointerIndex(pointer)\\n    const signalArg = {\\n      pointer,\\n      pointerIndex,\\n      pointerInfo: this.pointers[pointerIndex],\\n      event,\\n      type: 'move' as const,\\n      eventTarget,\\n      dx,\\n      dy,\\n      duplicate: duplicateMove,\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    }\\n\\n    if (!duplicateMove) {\\n      // set pointer coordinate, time changes and velocity\\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\\n    }\\n\\n    this._scopeFire('interactions:move', signalArg)\\n\\n    if (!duplicateMove &amp;&amp; !this.simulation) {\\n      // if interacting, fire an 'action-move' signal etc\\n      if (this.interacting()) {\\n        signalArg.type = null\\n        this.move(signalArg)\\n      }\\n\\n      if (this.pointerWasMoved) {\\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable(true)\\n   *   .on('dragmove', function (event) {\\n   *     if (someCondition) {\\n   *       // change the snap settings\\n   *       event.interactable.draggable({ snap: { targets: [] }})\\n   *       // fire another move event with re-calculated snap\\n   *       event.interaction.move()\\n   *     }\\n   *   })\\n   * ```\\n   *\\n   * Force a move of the current action at the same coordinates. Useful if\\n   * snap/restrict has been changed and you want a movement with the new\\n   * settings.\\n   */\\n  move (signalArg?: any) {\\n    if (!signalArg || !signalArg.event) {\\n      pointerUtils.setZeroCoords(this.coords.delta)\\n    }\\n\\n    signalArg = extend(\\n      {\\n        pointer: this._latestPointer.pointer,\\n        event: this._latestPointer.event,\\n        eventTarget: this._latestPointer.eventTarget,\\n        interaction: this,\\n      },\\n      signalArg || {},\\n    )\\n\\n    signalArg.phase = 'move'\\n\\n    this._doPhase(signalArg)\\n  }\\n\\n  // End interact move events and stop auto-scroll unless simulation is running\\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\\n    let pointerIndex = this.getPointerIndex(pointer)\\n\\n    if (pointerIndex === -1) {\\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\\n    }\\n\\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\\n\\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\\n      pointer,\\n      pointerIndex,\\n      pointerInfo: this.pointers[pointerIndex],\\n      event,\\n      eventTarget,\\n      type: type as any,\\n      curEventTarget,\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    })\\n\\n    if (!this.simulation) {\\n      this.end(event)\\n    }\\n\\n    this.removePointer(pointer, event)\\n  }\\n\\n  documentBlur (event: Event) {\\n    this.end(event as any)\\n    this._scopeFire('interactions:blur', {\\n      event,\\n      type: 'blur',\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    })\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable(true)\\n   *   .on('move', function (event) {\\n   *     if (event.pageX &gt; 1000) {\\n   *       // end the current action\\n   *       event.interaction.end()\\n   *       // stop all further listeners from being called\\n   *       event.stopImmediatePropagation()\\n   *     }\\n   *   })\\n   * ```\\n   *\\n   * @param {PointerEvent} [event]\\n   */\\n  end (event?: PointerEventType) {\\n    this._ending = true\\n    event = event || this._latestPointer.event\\n    let endPhaseResult: boolean\\n\\n    if (this.interacting()) {\\n      endPhaseResult = this._doPhase({\\n        event,\\n        interaction: this,\\n        phase: 'end',\\n      })\\n    }\\n\\n    this._ending = false\\n\\n    if (endPhaseResult === true) {\\n      this.stop()\\n    }\\n  }\\n\\n  currentAction () {\\n    return this._interacting ? this.prepared.name : null\\n  }\\n\\n  interacting () {\\n    return this._interacting\\n  }\\n\\n  /** */\\n  stop () {\\n    this._scopeFire('interactions:stop', { interaction: this })\\n\\n    this.interactable = this.element = null\\n\\n    this._interacting = false\\n    this._stopped = true\\n    this.prepared.name = this.prevEvent = null\\n  }\\n\\n  getPointerIndex (pointer: PointerType) {\\n    const pointerId = pointerUtils.getPointerId(pointer)\\n\\n    // mouse and pen interactions may have only one pointer\\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\\n      ? this.pointers.length - 1\\n      : arr.findIndex(this.pointers, curPointer =&gt; curPointer.id === pointerId)\\n  }\\n\\n  getPointerInfo (pointer: any) {\\n    return this.pointers[this.getPointerIndex(pointer)]\\n  }\\n\\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\\n    const id = pointerUtils.getPointerId(pointer)\\n    let pointerIndex = this.getPointerIndex(pointer)\\n    let pointerInfo = this.pointers[pointerIndex]\\n\\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\\n\\n    if (!pointerInfo) {\\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\\n\\n      pointerIndex = this.pointers.length\\n      this.pointers.push(pointerInfo)\\n    } else {\\n      pointerInfo.pointer = pointer\\n    }\\n\\n    pointerUtils.setCoords(\\n      this.coords.cur,\\n      this.pointers.map(p =&gt; p.pointer),\\n      this._now(),\\n    )\\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\\n\\n    if (down) {\\n      this.pointerIsDown = true\\n\\n      pointerInfo.downTime = this.coords.cur.timeStamp\\n      pointerInfo.downTarget = eventTarget\\n      pointerUtils.pointerExtend(this.downPointer, pointer)\\n\\n      if (!this.interacting()) {\\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\\n\\n        this.downEvent = event\\n        this.pointerWasMoved = false\\n      }\\n    }\\n\\n    this._updateLatestPointer(pointer, event, eventTarget)\\n\\n    this._scopeFire('interactions:update-pointer', {\\n      pointer,\\n      event,\\n      eventTarget,\\n      down,\\n      pointerInfo,\\n      pointerIndex,\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    })\\n\\n    return pointerIndex\\n  }\\n\\n  removePointer (pointer: PointerType, event: PointerEventType) {\\n    const pointerIndex = this.getPointerIndex(pointer)\\n\\n    if (pointerIndex === -1) return\\n\\n    const pointerInfo = this.pointers[pointerIndex]\\n\\n    this._scopeFire('interactions:remove-pointer', {\\n      pointer,\\n      event,\\n      eventTarget: null,\\n      pointerIndex,\\n      pointerInfo,\\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\\n    })\\n\\n    this.pointers.splice(pointerIndex, 1)\\n    this.pointerIsDown = false\\n  }\\n\\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\\n    this._latestPointer.pointer = pointer\\n    this._latestPointer.event = event\\n    this._latestPointer.eventTarget = eventTarget\\n  }\\n\\n  destroy () {\\n    this._latestPointer.pointer = null\\n    this._latestPointer.event = null\\n    this._latestPointer.eventTarget = null\\n  }\\n\\n  _createPreparedEvent&lt;P extends EventPhase&gt; (\\n    event: PointerEventType,\\n    phase: P,\\n    preEnd?: boolean,\\n    type?: string,\\n  ) {\\n    return new InteractEvent&lt;T, P&gt;(this, event, this.prepared.name, phase, this.element, preEnd, type)\\n  }\\n\\n  _fireEvent&lt;P extends EventPhase&gt; (iEvent: InteractEvent&lt;T, P&gt;) {\\n    this.interactable.fire(iEvent)\\n\\n    if (!this.prevEvent || iEvent.timeStamp &gt;= this.prevEvent.timeStamp) {\\n      this.prevEvent = iEvent\\n    }\\n  }\\n\\n  _doPhase&lt;P extends EventPhase&gt; (\\n    signalArg: Omit&lt;DoPhaseArg&lt;T, P&gt;, 'iEvent'&gt; &amp; { iEvent?: InteractEvent&lt;T, P&gt; },\\n  ) {\\n    const { event, phase, preEnd, type } = signalArg\\n    const { rect } = this\\n\\n    if (rect &amp;&amp; phase === 'move') {\\n      // update the rect changes due to pointer move\\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\\n\\n      rect.width = rect.right - rect.left\\n      rect.height = rect.bottom - rect.top\\n    }\\n\\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\\n\\n    if (beforeResult === false) {\\n      return false\\n    }\\n\\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\\n\\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\\n\\n    if (phase === 'start') {\\n      this.prevEvent = iEvent\\n    }\\n\\n    this._fireEvent(iEvent)\\n\\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\\n\\n    return true\\n  }\\n\\n  _now () {\\n    return Date.now()\\n  }\\n}\\n\\nexport default Interaction\\nexport { PointerInfo }\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport { _ProxyMethods } from '@interactjs/core/Interaction'\\nimport type { Plugin } from '@interactjs/core/scope'\\nimport type { Point } from '@interactjs/types/index'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    offsetBy?: typeof offsetBy\\n    offset: {\\n      total: Point\\n      pending: Point\\n    }\\n  }\\n\\n  enum _ProxyMethods {\\n    offsetBy = '',\\n  }\\n}\\n\\n;(_ProxyMethods as any).offsetBy = ''\\n\\nexport function addTotal (interaction: Interaction) {\\n  if (!interaction.pointerIsDown) {\\n    return\\n  }\\n\\n  addToCoords(interaction.coords.cur, interaction.offset.total)\\n\\n  interaction.offset.pending.x = 0\\n  interaction.offset.pending.y = 0\\n}\\n\\nfunction beforeAction ({ interaction }: { interaction: Interaction }) {\\n  applyPending(interaction)\\n}\\n\\nfunction beforeEnd ({ interaction }: { interaction: Interaction }): boolean | void {\\n  const hadPending = applyPending(interaction)\\n\\n  if (!hadPending) return\\n\\n  interaction.move({ offset: true })\\n  interaction.end()\\n\\n  return false\\n}\\n\\nfunction end ({ interaction }: { interaction: Interaction }) {\\n  interaction.offset.total.x = 0\\n  interaction.offset.total.y = 0\\n  interaction.offset.pending.x = 0\\n  interaction.offset.pending.y = 0\\n}\\n\\nexport function applyPending (interaction: Interaction) {\\n  if (!hasPending(interaction)) {\\n    return false\\n  }\\n\\n  const { pending } = interaction.offset\\n\\n  addToCoords(interaction.coords.cur, pending)\\n  addToCoords(interaction.coords.delta, pending)\\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\\n\\n  pending.x = 0\\n  pending.y = 0\\n\\n  return true\\n}\\n\\nfunction offsetBy (this: Interaction, { x, y }: Point) {\\n  this.offset.pending.x += x\\n  this.offset.pending.y += y\\n\\n  this.offset.total.x += x\\n  this.offset.total.y += y\\n}\\n\\nfunction addToCoords ({ page, client }, { x, y }: Point) {\\n  page.x += x\\n  page.y += y\\n  client.x += x\\n  client.y += y\\n}\\n\\nfunction hasPending (interaction: Interaction) {\\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\\n}\\n\\nconst offset: Plugin = {\\n  id: 'offset',\\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\\n  install (scope) {\\n    scope.Interaction.prototype.offsetBy = offsetBy\\n  },\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.offset = {\\n        total: { x: 0, y: 0 },\\n        pending: { x: 0, y: 0 },\\n      }\\n    },\\n    'interactions:update-pointer': ({ interaction }) =&gt; addTotal(interaction),\\n    'interactions:before-action-start': beforeAction,\\n    'interactions:before-action-move': beforeAction,\\n    'interactions:before-action-end': beforeEnd,\\n    'interactions:stop': end,\\n  },\\n}\\n\\nexport default offset\\n\"</span>,<span class=\"code-string\">\"import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\\nimport type { ActionName, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\\nimport Modification from '@interactjs/modifiers/Modification'\\nimport * as modifiers from '@interactjs/modifiers/base'\\nimport offset from '@interactjs/offset/plugin'\\nimport type { Point, PointerEventType } from '@interactjs/types/index'\\nimport * as dom from '@interactjs/utils/domUtils'\\nimport hypot from '@interactjs/utils/hypot'\\nimport is from '@interactjs/utils/is'\\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\\nimport raf from '@interactjs/utils/raf'\\n\\ndeclare module '@interactjs/core/InteractEvent' {\\n  interface PhaseMap {\\n    resume?: true\\n    inertiastart?: true\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    inertia?: InertiaState\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface PerActionDefaults {\\n    inertia?: {\\n      enabled?: boolean\\n      resistance?: number // the lambda in exponential decay\\n      minSpeed?: number // target speed must be above this for inertia to start\\n      endSpeed?: number // the speed at which inertia is slow enough to stop\\n      allowResume?: true // allow resuming an action in inertia phase\\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\\n    }\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'interactions:before-action-inertiastart': Omit&lt;DoPhaseArg&lt;ActionName, 'inertiastart'&gt;, 'iEvent'&gt;\\n    'interactions:action-inertiastart': DoPhaseArg&lt;ActionName, 'inertiastart'&gt;\\n    'interactions:after-action-inertiastart': DoPhaseArg&lt;ActionName, 'inertiastart'&gt;\\n    'interactions:before-action-resume': Omit&lt;DoPhaseArg&lt;ActionName, 'resume'&gt;, 'iEvent'&gt;\\n    'interactions:action-resume': DoPhaseArg&lt;ActionName, 'resume'&gt;\\n    'interactions:after-action-resume': DoPhaseArg&lt;ActionName, 'resume'&gt;\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  const { defaults } = scope\\n\\n  scope.usePlugin(offset)\\n  scope.usePlugin(modifiers.default)\\n  scope.actions.phases.inertiastart = true\\n  scope.actions.phases.resume = true\\n\\n  defaults.perAction.inertia = {\\n    enabled: false,\\n    resistance: 10, // the lambda in exponential decay\\n    minSpeed: 100, // target speed must be above this for inertia to start\\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\\n    allowResume: true, // allow resuming an action in inertia phase\\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\\n  }\\n}\\n\\nexport class InertiaState {\\n  active = false\\n  isModified = false\\n  smoothEnd = false\\n  allowResume = false\\n\\n  modification!: Modification\\n  modifierCount = 0\\n  modifierArg!: modifiers.ModifierArg\\n\\n  startCoords!: Point\\n  t0 = 0\\n  v0 = 0\\n\\n  te = 0\\n  targetOffset!: Point\\n  modifiedOffset!: Point\\n  currentOffset!: Point\\n\\n  lambda_v0? = 0 // eslint-disable-line camelcase\\n  one_ve_v0? = 0 // eslint-disable-line camelcase\\n  timeout!: number\\n  readonly interaction: Interaction\\n\\n  constructor (interaction: Interaction) {\\n    this.interaction = interaction\\n  }\\n\\n  start (event: PointerEventType) {\\n    const { interaction } = this\\n    const options = getOptions(interaction)\\n\\n    if (!options || !options.enabled) {\\n      return false\\n    }\\n\\n    const { client: velocityClient } = interaction.coords.velocity\\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\\n    const modification = this.modification || (this.modification = new Modification(interaction))\\n\\n    modification.copyFrom(interaction.modification)\\n\\n    this.t0 = interaction._now()\\n    this.allowResume = options.allowResume\\n    this.v0 = pointerSpeed\\n    this.currentOffset = { x: 0, y: 0 }\\n    this.startCoords = interaction.coords.cur.page\\n\\n    this.modifierArg = modification.fillArg({\\n      pageCoords: this.startCoords,\\n      preEnd: true,\\n      phase: 'inertiastart',\\n    })\\n\\n    const thrown =\\n      this.t0 - interaction.coords.cur.timeStamp &lt; 50 &amp;&amp;\\n      pointerSpeed &gt; options.minSpeed &amp;&amp;\\n      pointerSpeed &gt; options.endSpeed\\n\\n    if (thrown) {\\n      this.startInertia()\\n    } else {\\n      modification.result = modification.setAll(this.modifierArg)\\n\\n      if (!modification.result.changed) {\\n        return false\\n      }\\n\\n      this.startSmoothEnd()\\n    }\\n\\n    // force modification change\\n    interaction.modification.result.rect = null\\n\\n    // bring inertiastart event to the target coords\\n    interaction.offsetBy(this.targetOffset)\\n    interaction._doPhase({\\n      interaction,\\n      event,\\n      phase: 'inertiastart',\\n    })\\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\\n    // force modification change\\n    interaction.modification.result.rect = null\\n\\n    this.active = true\\n    interaction.simulation = this\\n\\n    return true\\n  }\\n\\n  startInertia () {\\n    const startVelocity = this.interaction.coords.velocity.client\\n    const options = getOptions(this.interaction)\\n    const lambda = options.resistance\\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\\n\\n    this.targetOffset = {\\n      x: (startVelocity.x - inertiaDur) / lambda,\\n      y: (startVelocity.y - inertiaDur) / lambda,\\n    }\\n\\n    this.te = inertiaDur\\n    this.lambda_v0 = lambda / this.v0\\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\\n\\n    const { modification, modifierArg } = this\\n\\n    modifierArg.pageCoords = {\\n      x: this.startCoords.x + this.targetOffset.x,\\n      y: this.startCoords.y + this.targetOffset.y,\\n    }\\n\\n    modification.result = modification.setAll(modifierArg)\\n\\n    if (modification.result.changed) {\\n      this.isModified = true\\n      this.modifiedOffset = {\\n        x: this.targetOffset.x + modification.result.delta.x,\\n        y: this.targetOffset.y + modification.result.delta.y,\\n      }\\n    }\\n\\n    this.onNextFrame(() =&gt; this.inertiaTick())\\n  }\\n\\n  startSmoothEnd () {\\n    this.smoothEnd = true\\n    this.isModified = true\\n    this.targetOffset = {\\n      x: this.modification.result.delta.x,\\n      y: this.modification.result.delta.y,\\n    }\\n\\n    this.onNextFrame(() =&gt; this.smoothEndTick())\\n  }\\n\\n  onNextFrame (tickFn: () =&gt; void) {\\n    this.timeout = raf.request(() =&gt; {\\n      if (this.active) {\\n        tickFn()\\n      }\\n    })\\n  }\\n\\n  inertiaTick () {\\n    const { interaction } = this\\n    const options = getOptions(interaction)\\n    const lambda = options.resistance\\n    const t = (interaction._now() - this.t0) / 1000\\n\\n    if (t &lt; this.te) {\\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\\n      let newOffset: Point\\n\\n      if (this.isModified) {\\n        newOffset = getQuadraticCurvePoint(\\n          0,\\n          0,\\n          this.targetOffset.x,\\n          this.targetOffset.y,\\n          this.modifiedOffset.x,\\n          this.modifiedOffset.y,\\n          progress,\\n        )\\n      } else {\\n        newOffset = {\\n          x: this.targetOffset.x * progress,\\n          y: this.targetOffset.y * progress,\\n        }\\n      }\\n\\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\\n\\n      this.currentOffset.x += delta.x\\n      this.currentOffset.y += delta.y\\n\\n      interaction.offsetBy(delta)\\n      interaction.move()\\n\\n      this.onNextFrame(() =&gt; this.inertiaTick())\\n    } else {\\n      interaction.offsetBy({\\n        x: this.modifiedOffset.x - this.currentOffset.x,\\n        y: this.modifiedOffset.y - this.currentOffset.y,\\n      })\\n\\n      this.end()\\n    }\\n  }\\n\\n  smoothEndTick () {\\n    const { interaction } = this\\n    const t = interaction._now() - this.t0\\n    const { smoothEndDuration: duration } = getOptions(interaction)\\n\\n    if (t &lt; duration) {\\n      const newOffset = {\\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\\n      }\\n      const delta = {\\n        x: newOffset.x - this.currentOffset.x,\\n        y: newOffset.y - this.currentOffset.y,\\n      }\\n\\n      this.currentOffset.x += delta.x\\n      this.currentOffset.y += delta.y\\n\\n      interaction.offsetBy(delta)\\n      interaction.move({ skipModifiers: this.modifierCount })\\n\\n      this.onNextFrame(() =&gt; this.smoothEndTick())\\n    } else {\\n      interaction.offsetBy({\\n        x: this.targetOffset.x - this.currentOffset.x,\\n        y: this.targetOffset.y - this.currentOffset.y,\\n      })\\n\\n      this.end()\\n    }\\n  }\\n\\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\\n    const { interaction } = this\\n\\n    // undo inertia changes to interaction coords\\n    interaction.offsetBy({\\n      x: -this.currentOffset.x,\\n      y: -this.currentOffset.y,\\n    })\\n\\n    // update pointer at pointer down position\\n    interaction.updatePointer(pointer, event, eventTarget, true)\\n\\n    // fire resume signals and event\\n    interaction._doPhase({\\n      interaction,\\n      event,\\n      phase: 'resume',\\n    })\\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\\n\\n    this.stop()\\n  }\\n\\n  end () {\\n    this.interaction.move()\\n    this.interaction.end()\\n    this.stop()\\n  }\\n\\n  stop () {\\n    this.active = this.smoothEnd = false\\n    this.interaction.simulation = null\\n    raf.cancel(this.timeout)\\n  }\\n}\\n\\nfunction start ({ interaction, event }: DoPhaseArg&lt;ActionName, 'end'&gt;) {\\n  if (!interaction._interacting || interaction.simulation) {\\n    return null\\n  }\\n\\n  const started = interaction.inertia.start(event)\\n\\n  // prevent action end if inertia or smoothEnd\\n  return started ? false : null\\n}\\n\\n// Check if the down event hits the current inertia target\\n// control should be return to the user\\nfunction resume (arg: SignalArgs['interactions:down']) {\\n  const { interaction, eventTarget } = arg\\n  const state = interaction.inertia\\n\\n  if (!state.active) return\\n\\n  let element = eventTarget as Node\\n\\n  // climb up the DOM tree from the event target\\n  while (is.element(element)) {\\n    // if interaction element is the current inertia target element\\n    if (element === interaction.element) {\\n      state.resume(arg)\\n      break\\n    }\\n\\n    element = dom.parentNode(element)\\n  }\\n}\\n\\nfunction stop ({ interaction }: { interaction: Interaction }) {\\n  const state = interaction.inertia\\n\\n  if (state.active) {\\n    state.stop()\\n  }\\n}\\n\\nfunction getOptions ({ interactable, prepared }: Interaction) {\\n  return interactable &amp;&amp; interactable.options &amp;&amp; prepared.name &amp;&amp; interactable.options[prepared.name].inertia\\n}\\n\\nconst inertia: Plugin = {\\n  id: 'inertia',\\n  before: ['modifiers', 'actions'],\\n  install,\\n  listeners: {\\n    'interactions:new': ({ interaction }) =&gt; {\\n      interaction.inertia = new InertiaState(interaction)\\n    },\\n\\n    'interactions:before-action-end': start,\\n    'interactions:down': resume,\\n    'interactions:stop': stop,\\n\\n    'interactions:before-action-resume': arg =&gt; {\\n      const { modification } = arg.interaction\\n\\n      modification.stop(arg)\\n      modification.start(arg, arg.interaction.coords.cur.page)\\n      modification.applyToInteraction(arg)\\n    },\\n\\n    'interactions:before-action-inertiastart': arg =&gt; arg.interaction.modification.setAndApply(arg),\\n    'interactions:action-resume': modifiers.addEventModifiers,\\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\\n    'interactions:after-action-inertiastart': arg =&gt;\\n      arg.interaction.modification.restoreInteractionCoords(arg),\\n    'interactions:after-action-resume': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\\n  },\\n}\\n\\n// http://stackoverflow.com/a/5634528/2280888\\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\\n  const iT = 1 - t\\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\\n}\\n\\nfunction getQuadraticCurvePoint (\\n  startX: number,\\n  startY: number,\\n  cpX: number,\\n  cpY: number,\\n  endX: number,\\n  endY: number,\\n  position: number,\\n) {\\n  return {\\n    x: _getQBezierValue(position, startX, cpX, endX),\\n    y: _getQBezierValue(position, startY, cpY, endY),\\n  }\\n}\\n\\n// http://gizma.com/easing/\\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\\n  t /= d\\n  return -c * t * (t - 2) + b\\n}\\n\\nexport default inertia\\n\"</span>,<span class=\"code-string\">\"import type { Listener, ListenersArg, Rect } from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport extend from '@interactjs/utils/extend'\\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\\nimport normalize from '@interactjs/utils/normalizeListeners'\\n\\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\\n  for (const listener of listeners) {\\n    if (event.immediatePropagationStopped) {\\n      break\\n    }\\n\\n    listener(event)\\n  }\\n}\\n\\nexport class Eventable {\\n  options: any\\n  types: NormalizedListeners = {}\\n  propagationStopped = false\\n  immediatePropagationStopped = false\\n  global: any\\n\\n  constructor (options?: { [index: string]: any }) {\\n    this.options = extend({}, options || {})\\n  }\\n\\n  fire&lt;T extends { type: string, propagationStopped?: boolean }&gt; (event: T) {\\n    let listeners: Listener[]\\n    const global = this.global\\n\\n    // Interactable#on() listeners\\n    // tslint:disable no-conditional-assignment\\n    if ((listeners = this.types[event.type])) {\\n      fireUntilImmediateStopped(event, listeners)\\n    }\\n\\n    // interact.on() listeners\\n    if (!event.propagationStopped &amp;&amp; global &amp;&amp; (listeners = global[event.type])) {\\n      fireUntilImmediateStopped(event, listeners)\\n    }\\n  }\\n\\n  on (type: string, listener: ListenersArg) {\\n    const listeners = normalize(type, listener)\\n\\n    for (type in listeners) {\\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\\n    }\\n  }\\n\\n  off (type: string, listener: ListenersArg) {\\n    const listeners = normalize(type, listener)\\n\\n    for (type in listeners) {\\n      const eventList = this.types[type]\\n\\n      if (!eventList || !eventList.length) {\\n        continue\\n      }\\n\\n      for (const subListener of listeners[type]) {\\n        const index = eventList.indexOf(subListener)\\n\\n        if (index !== -1) {\\n          eventList.splice(index, 1)\\n        }\\n      }\\n    }\\n  }\\n\\n  getRect (_element: Element): Rect {\\n    return null\\n  }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Actions } from '@interactjs/core/scope'\\n\\nexport default function isNonNativeEvent (type: string, actions: Actions) {\\n  if (actions.phaselessTypes[type]) {\\n    return true\\n  }\\n\\n  for (const name in actions.map) {\\n    if (type.indexOf(name) === 0 &amp;&amp; type.substr(name.length) in actions.phases) {\\n      return true\\n    }\\n  }\\n\\n  return false\\n}\\n\"</span>,<span class=\"code-string\">\"/* eslint-disable no-dupe-class-members */\\nimport type { ActionMap, ActionName, Actions, Scope } from '@interactjs/core/scope'\\nimport type {\\n  Context,\\n  Element,\\n  Target,\\n  Listeners,\\n  OrBoolean,\\n  EventTypes,\\n  ListenersArg,\\n  ActionMethod,\\n} from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport browser from '@interactjs/utils/browser'\\nimport clone from '@interactjs/utils/clone'\\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\\nimport { getWindow } from '@interactjs/utils/window'\\n\\nimport { Eventable } from './Eventable'\\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults } from './defaultOptions'\\nimport { Options } from './defaultOptions'\\nimport isNonNativeEvent from './isNonNativeEvent'\\n\\ntype IgnoreValue = string | Element | boolean\\ntype DeltaSource = 'page' | 'client'\\n\\n/** */\\nexport class Interactable implements Partial&lt;Eventable&gt; {\\n  /** @internal */ get _defaults (): Defaults {\\n    return {\\n      base: {},\\n      perAction: {},\\n      actions: {} as ActionDefaults,\\n    }\\n  }\\n\\n  readonly options!: Required&lt;Options&gt;\\n  readonly _actions: Actions\\n  readonly target: Target\\n  readonly events = new Eventable()\\n  readonly _context: Context\\n  readonly _win: Window\\n  readonly _doc: Document\\n  readonly _scopeEvents: Scope['events']\\n\\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\\n\\n  /** */\\n  constructor (\\n    target: Target,\\n    options: any,\\n    defaultContext: Document | Element,\\n    scopeEvents: Scope['events'],\\n  ) {\\n    this._actions = options.actions\\n    this.target = target\\n    this._context = options.context || defaultContext\\n    this._win = getWindow(trySelector(target) ? this._context : target)\\n    this._doc = this._win.document\\n    this._scopeEvents = scopeEvents\\n\\n    this.set(options)\\n  }\\n\\n  setOnEvents (actionName: ActionName, phases: NonNullable&lt;any&gt;) {\\n    if (is.func(phases.onstart)) {\\n      this.on(`${actionName}start`, phases.onstart)\\n    }\\n    if (is.func(phases.onmove)) {\\n      this.on(`${actionName}move`, phases.onmove)\\n    }\\n    if (is.func(phases.onend)) {\\n      this.on(`${actionName}end`, phases.onend)\\n    }\\n    if (is.func(phases.oninertiastart)) {\\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\\n    }\\n\\n    return this\\n  }\\n\\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\\n    if (is.array(prev) || is.object(prev)) {\\n      this.off(actionName, prev)\\n    }\\n\\n    if (is.array(cur) || is.object(cur)) {\\n      this.on(actionName, cur)\\n    }\\n  }\\n\\n  setPerAction (actionName: ActionName, options: OrBoolean&lt;Options&gt;) {\\n    const defaults = this._defaults\\n\\n    // for all the default per-action options\\n    for (const optionName_ in options) {\\n      const optionName = optionName_ as keyof PerActionDefaults\\n      const actionOptions = this.options[actionName]\\n      const optionValue: any = options[optionName]\\n\\n      // remove old event listeners and add new ones\\n      if (optionName === 'listeners') {\\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\\n      }\\n\\n      // if the option value is an array\\n      if (is.array&lt;any&gt;(optionValue)) {\\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\\n      }\\n      // if the option value is an object\\n      else if (is.plainObject(optionValue)) {\\n        // copy the object\\n        ;(actionOptions[optionName] as any) = extend(\\n          actionOptions[optionName] || ({} as any),\\n          clone(optionValue),\\n        )\\n\\n        // set anabled field to true if it exists in the defaults\\n        if (\\n          is.object(defaults.perAction[optionName]) &amp;&amp;\\n          'enabled' in (defaults.perAction[optionName] as any)\\n        ) {\\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\\n        }\\n      }\\n      // if the option value is a boolean and the default is an object\\n      else if (is.bool(optionValue) &amp;&amp; is.object(defaults.perAction[optionName])) {\\n        ;(actionOptions[optionName] as any).enabled = optionValue\\n      }\\n      // if it's anything else, do a plain assignment\\n      else {\\n        ;(actionOptions[optionName] as any) = optionValue\\n      }\\n    }\\n  }\\n\\n  /**\\n   * The default function to get an Interactables bounding rect. Can be\\n   * overridden using {@link Interactable.rectChecker}.\\n   *\\n   * @param {Element} [element] The element to measure.\\n   * @return {Rect} The object's bounding rectangle.\\n   */\\n  getRect (element: Element) {\\n    element = element || (is.element(this.target) ? this.target : null)\\n\\n    if (is.string(this.target)) {\\n      element = element || this._context.querySelector(this.target)\\n    }\\n\\n    return getElementRect(element)\\n  }\\n\\n  /**\\n   * Returns or sets the function used to calculate the interactable's\\n   * element's rectangle\\n   *\\n   * @param {function} [checker] A function which returns this Interactable's\\n   * bounding rectangle. See {@link Interactable.getRect}\\n   * @return {function | object} The checker function or this Interactable\\n   */\\n  rectChecker(): (element: Element) =&gt; any | null\\n  rectChecker(checker: (element: Element) =&gt; any): this\\n  rectChecker (checker?: (element: Element) =&gt; any) {\\n    if (is.func(checker)) {\\n      this._rectChecker = checker\\n\\n      this.getRect = element =&gt; {\\n        const rect = extend({}, this._rectChecker(element))\\n\\n        if (!(('width' in rect) as unknown)) {\\n          rect.width = rect.right - rect.left\\n          rect.height = rect.bottom - rect.top\\n        }\\n\\n        return rect\\n      }\\n\\n      return this\\n    }\\n\\n    if (checker === null) {\\n      delete this.getRect\\n      delete this._rectChecker\\n\\n      return this\\n    }\\n\\n    return this.getRect\\n  }\\n\\n  _backCompatOption (optionName: keyof Options, newValue: any) {\\n    if (trySelector(newValue) || is.object(newValue)) {\\n      ;(this.options[optionName] as any) = newValue\\n\\n      for (const action in this._actions.map) {\\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\\n      }\\n\\n      return this\\n    }\\n\\n    return this.options[optionName]\\n  }\\n\\n  /**\\n   * Gets or sets the origin of the Interactable's element.  The x and y\\n   * of the origin will be subtracted from action event coordinates.\\n   *\\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\\n   * or any CSS selector\\n   *\\n   * @return {object} The current origin or this Interactable\\n   */\\n  origin (newValue: any) {\\n    return this._backCompatOption('origin', newValue)\\n  }\\n\\n  /**\\n   * Returns or sets the mouse coordinate types used to calculate the\\n   * movement of the pointer.\\n   *\\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\\n   * interacting; Use 'page' if you want autoScroll to work\\n   * @return {string | object} The current deltaSource or this Interactable\\n   */\\n  deltaSource(): DeltaSource\\n  deltaSource(newValue: DeltaSource): this\\n  deltaSource (newValue?: DeltaSource) {\\n    if (newValue === 'page' || newValue === 'client') {\\n      this.options.deltaSource = newValue\\n\\n      return this\\n    }\\n\\n    return this.options.deltaSource\\n  }\\n\\n  /**\\n   * Gets the selector context Node of the Interactable. The default is\\n   * `window.document`.\\n   *\\n   * @return {Node} The context Node of this Interactable\\n   */\\n  context () {\\n    return this._context\\n  }\\n\\n  inContext (element: Document | Node) {\\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\\n  }\\n\\n  testIgnoreAllow (\\n    this: Interactable,\\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\\n    targetNode: Node,\\n    eventTarget: Node,\\n  ) {\\n    return (\\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &amp;&amp;\\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\\n    )\\n  }\\n\\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\\n    if (!allowFrom) {\\n      return true\\n    }\\n\\n    if (!is.element(element)) {\\n      return false\\n    }\\n\\n    if (is.string(allowFrom)) {\\n      return matchesUpTo(element, allowFrom, targetNode)\\n    } else if (is.element(allowFrom)) {\\n      return nodeContains(allowFrom, element)\\n    }\\n\\n    return false\\n  }\\n\\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\\n    if (!ignoreFrom || !is.element(element)) {\\n      return false\\n    }\\n\\n    if (is.string(ignoreFrom)) {\\n      return matchesUpTo(element, ignoreFrom, targetNode)\\n    } else if (is.element(ignoreFrom)) {\\n      return nodeContains(ignoreFrom, element)\\n    }\\n\\n    return false\\n  }\\n\\n  /**\\n   * Calls listeners for the given InteractEvent type bound globally\\n   * and directly to this Interactable\\n   *\\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\\n   * Interactable\\n   * @return {Interactable} this Interactable\\n   */\\n  fire&lt;E extends { type: string }&gt; (iEvent: E) {\\n    this.events.fire(iEvent)\\n\\n    return this\\n  }\\n\\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\\n    if (is.object(typeArg) &amp;&amp; !is.array(typeArg)) {\\n      options = listenerArg\\n      listenerArg = null\\n    }\\n\\n    const addRemove = method === 'on' ? 'add' : 'remove'\\n    const listeners = normalizeListeners(typeArg, listenerArg)\\n\\n    for (let type in listeners) {\\n      if (type === 'wheel') {\\n        type = browser.wheelEvent\\n      }\\n\\n      for (const listener of listeners[type]) {\\n        // if it is an action event type\\n        if (isNonNativeEvent(type, this._actions)) {\\n          this.events[method](type, listener)\\n        }\\n        // delegated event\\n        else if (is.string(this.target)) {\\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\\n            this.target,\\n            this._context,\\n            type,\\n            listener,\\n            options,\\n          )\\n        }\\n        // remove listener from this Interactable's element\\n        else {\\n          this._scopeEvents[addRemove](this.target, type, listener, options)\\n        }\\n      }\\n    }\\n\\n    return this\\n  }\\n\\n  /**\\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\\n   *\\n   * @param {string | array | object} types The types of events to listen\\n   * for\\n   * @param {function | array | object} [listener] The event listener function(s)\\n   * @param {object | boolean} [options] options object or useCapture flag for\\n   * addEventListener\\n   * @return {Interactable} This Interactable\\n   */\\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\\n    return this._onOff('on', types, listener, options)\\n  }\\n\\n  /**\\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\\n   *\\n   * @param {string | array | object} types The types of events that were\\n   * listened for\\n   * @param {function | array | object} [listener] The event listener function(s)\\n   * @param {object | boolean} [options] options object or useCapture flag for\\n   * removeEventListener\\n   * @return {Interactable} This Interactable\\n   */\\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\\n    return this._onOff('off', types, listener, options)\\n  }\\n\\n  /**\\n   * Reset the options of this Interactable\\n   *\\n   * @param {object} options The new settings to apply\\n   * @return {object} This Interactable\\n   */\\n  set (options: OptionsArg) {\\n    const defaults = this._defaults\\n\\n    if (!is.object(options)) {\\n      options = {}\\n    }\\n\\n    ;(this.options as Required&lt;Options&gt;) = clone(defaults.base) as Required&lt;Options&gt;\\n\\n    for (const actionName_ in this._actions.methodDict) {\\n      const actionName = actionName_ as ActionName\\n      const methodName = this._actions.methodDict[actionName]\\n\\n      this.options[actionName] = {}\\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\\n      ;(this[methodName] as ActionMethod&lt;unknown&gt;)(options[actionName])\\n    }\\n\\n    for (const setting in options) {\\n      if (is.func((this as any)[setting])) {\\n        ;(this as any)[setting](options[setting as keyof typeof options])\\n      }\\n    }\\n\\n    return this\\n  }\\n\\n  /**\\n   * Remove this interactable from the list of interactables and remove it's\\n   * action capabilities and event listeners\\n   */\\n  unset () {\\n    if (is.string(this.target)) {\\n      // remove delegated events\\n      for (const type in this._scopeEvents.delegatedEvents) {\\n        const delegated = this._scopeEvents.delegatedEvents[type]\\n\\n        for (let i = delegated.length - 1; i &gt;= 0; i--) {\\n          const { selector, context, listeners } = delegated[i]\\n\\n          if (selector === this.target &amp;&amp; context === this._context) {\\n            delegated.splice(i, 1)\\n          }\\n\\n          for (let l = listeners.length - 1; l &gt;= 0; l--) {\\n            this._scopeEvents.removeDelegate(\\n              this.target,\\n              this._context,\\n              type,\\n              listeners[l][0],\\n              listeners[l][1],\\n            )\\n          }\\n        }\\n      }\\n    } else {\\n      this._scopeEvents.remove(this.target as Node, 'all')\\n    }\\n  }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { OptionsArg, Options } from '@interactjs/core/defaultOptions'\\nimport type { Scope } from '@interactjs/core/scope'\\nimport type { Target, Context } from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'interactable:new': {\\n      interactable: Interactable\\n      target: Target\\n      options: OptionsArg\\n      win: Window\\n    }\\n  }\\n}\\n\\ninterface InteractableScopeProp {\\n  context: Context\\n  interactable: Interactable\\n}\\n\\nexport class InteractableSet {\\n  // all set interactables\\n  list: Interactable[] = []\\n\\n  selectorMap: {\\n    [selector: string]: InteractableScopeProp[]\\n  } = {}\\n\\n  scope: Scope\\n\\n  constructor (scope: Scope) {\\n    this.scope = scope\\n    scope.addListeners({\\n      'interactable:unset': ({ interactable }) =&gt; {\\n        const { target, _context: context } = interactable\\n        const targetMappings: InteractableScopeProp[] = is.string(target)\\n          ? this.selectorMap[target]\\n          : (target as any)[this.scope.id]\\n\\n        const targetIndex = arr.findIndex(targetMappings, m =&gt; m.context === context)\\n        if (targetMappings[targetIndex]) {\\n          // Destroying mappingInfo's context and interactable\\n          targetMappings[targetIndex].context = null\\n          targetMappings[targetIndex].interactable = null\\n        }\\n        targetMappings.splice(targetIndex, 1)\\n      },\\n    })\\n  }\\n\\n  new (target: Target, options?: any): Interactable {\\n    options = extend(options || {}, {\\n      actions: this.scope.actions,\\n    })\\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\\n    const mappingInfo = { context: interactable._context, interactable }\\n\\n    this.scope.addDocument(interactable._doc)\\n    this.list.push(interactable)\\n\\n    if (is.string(target)) {\\n      if (!this.selectorMap[target]) {\\n        this.selectorMap[target] = []\\n      }\\n      this.selectorMap[target].push(mappingInfo)\\n    } else {\\n      if (!(interactable.target as any)[this.scope.id]) {\\n        Object.defineProperty(target, this.scope.id, {\\n          value: [],\\n          configurable: true,\\n        })\\n      }\\n\\n      ;(target as any)[this.scope.id].push(mappingInfo)\\n    }\\n\\n    this.scope.fire('interactable:new', {\\n      target,\\n      options,\\n      interactable,\\n      win: this.scope._win,\\n    })\\n\\n    return interactable\\n  }\\n\\n  get (target: Target, options?: Options) {\\n    const context = (options &amp;&amp; options.context) || this.scope.document\\n    const isSelector = is.string(target)\\n    const targetMappings: InteractableScopeProp[] = isSelector\\n      ? this.selectorMap[target as string]\\n      : (target as any)[this.scope.id]\\n\\n    if (!targetMappings) {\\n      return null\\n    }\\n\\n    const found = arr.find(\\n      targetMappings,\\n      m =&gt; m.context === context &amp;&amp; (isSelector || m.interactable.inContext(target as any)),\\n    )\\n\\n    return found &amp;&amp; found.interactable\\n  }\\n\\n  forEachMatch&lt;T&gt; (node: Node, callback: (interactable: Interactable) =&gt; T) {\\n    for (const interactable of this.list) {\\n      let ret: void | T\\n\\n      if (\\n        (is.string(interactable.target)\\n          ? // target is a selector and the element matches\\n          is.element(node) &amp;&amp; domUtils.matchesSelector(node, interactable.target)\\n          : // target is the element\\n          node === interactable.target) &amp;&amp;\\n        // the element is in context\\n        interactable.inContext(node)\\n      ) {\\n        ret = callback(interactable)\\n      }\\n\\n      if (ret !== undefined) {\\n        return ret\\n      }\\n    }\\n  }\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Scope } from '@interactjs/core/scope'\\nimport type { Element } from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\nimport pExtend from '@interactjs/utils/pointerExtend'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    events: ReturnType&lt;typeof install&gt;\\n  }\\n}\\n\\ntype Listener = (event: Event | FakeEvent) =&gt; any\\n\\nfunction install (scope: Scope) {\\n  const targets: Array&lt;{\\n    eventTarget: EventTarget\\n    events: { [type: string]: Listener[] }\\n  }&gt; = []\\n\\n  const delegatedEvents: {\\n    [type: string]: Array&lt;{\\n      selector: string\\n      context: Node\\n      listeners: Array&lt;[Listener, { capture: boolean, passive: boolean }]&gt;\\n    }&gt;\\n  } = {}\\n  const documents: Document[] = []\\n\\n  const eventsMethods = {\\n    add,\\n    remove,\\n\\n    addDelegate,\\n    removeDelegate,\\n\\n    delegateListener,\\n    delegateUseCapture,\\n    delegatedEvents,\\n    documents,\\n\\n    targets,\\n\\n    supportsOptions: false,\\n    supportsPassive: false,\\n  }\\n\\n  // check if browser supports passive events and options arg\\n  scope.document.createElement('div').addEventListener('test', null, {\\n    get capture () {\\n      return (eventsMethods.supportsOptions = true)\\n    },\\n    get passive () {\\n      return (eventsMethods.supportsPassive = true)\\n    },\\n  })\\n\\n  scope.events = eventsMethods\\n\\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\\n    const options = getOptions(optionalArg)\\n    let target = arr.find(targets, t =&gt; t.eventTarget === eventTarget)\\n\\n    if (!target) {\\n      target = {\\n        eventTarget,\\n        events: {},\\n      }\\n\\n      targets.push(target)\\n    }\\n\\n    if (!target.events[type]) {\\n      target.events[type] = []\\n    }\\n\\n    if (eventTarget.addEventListener &amp;&amp; !arr.contains(target.events[type], listener)) {\\n      eventTarget.addEventListener(\\n        type,\\n        listener as any,\\n        eventsMethods.supportsOptions ? options : options.capture,\\n      )\\n      target.events[type].push(listener)\\n    }\\n  }\\n\\n  function remove (\\n    eventTarget: EventTarget,\\n    type: string,\\n    listener?: 'all' | Listener,\\n    optionalArg?: boolean | any,\\n  ) {\\n    const options = getOptions(optionalArg)\\n    const targetIndex = arr.findIndex(targets, t =&gt; t.eventTarget === eventTarget)\\n    const target = targets[targetIndex]\\n\\n    if (!target || !target.events) {\\n      return\\n    }\\n\\n    if (type === 'all') {\\n      for (type in target.events) {\\n        if (target.events.hasOwnProperty(type)) {\\n          remove(eventTarget, type, 'all')\\n        }\\n      }\\n      return\\n    }\\n\\n    let typeIsEmpty = false\\n    const typeListeners = target.events[type]\\n\\n    if (typeListeners) {\\n      if (listener === 'all') {\\n        for (let i = typeListeners.length - 1; i &gt;= 0; i--) {\\n          remove(eventTarget, type, typeListeners[i], options)\\n        }\\n        return\\n      } else {\\n        for (let i = 0; i &lt; typeListeners.length; i++) {\\n          if (typeListeners[i] === listener) {\\n            eventTarget.removeEventListener(\\n              type,\\n              listener as any,\\n              eventsMethods.supportsOptions ? options : options.capture,\\n            )\\n            typeListeners.splice(i, 1)\\n\\n            if (typeListeners.length === 0) {\\n              delete target.events[type]\\n              typeIsEmpty = true\\n            }\\n\\n            break\\n          }\\n        }\\n      }\\n    }\\n\\n    if (typeIsEmpty &amp;&amp; !Object.keys(target.events).length) {\\n      targets.splice(targetIndex, 1)\\n    }\\n  }\\n\\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\\n    const options = getOptions(optionalArg)\\n    if (!delegatedEvents[type]) {\\n      delegatedEvents[type] = []\\n\\n      // add delegate listener functions\\n      for (const doc of documents) {\\n        add(doc, type, delegateListener)\\n        add(doc, type, delegateUseCapture, true)\\n      }\\n    }\\n\\n    const delegates = delegatedEvents[type]\\n    let delegate = arr.find(delegates, d =&gt; d.selector === selector &amp;&amp; d.context === context)\\n\\n    if (!delegate) {\\n      delegate = { selector, context, listeners: [] }\\n      delegates.push(delegate)\\n    }\\n\\n    delegate.listeners.push([listener, options])\\n  }\\n\\n  function removeDelegate (\\n    selector: string,\\n    context: Document | Element,\\n    type: string,\\n    listener?: Listener,\\n    optionalArg?: any,\\n  ) {\\n    const options = getOptions(optionalArg)\\n    const delegates = delegatedEvents[type]\\n    let matchFound = false\\n    let index: number\\n\\n    if (!delegates) return\\n\\n    // count from last index of delegated to 0\\n    for (index = delegates.length - 1; index &gt;= 0; index--) {\\n      const cur = delegates[index]\\n      // look for matching selector and context Node\\n      if (cur.selector === selector &amp;&amp; cur.context === context) {\\n        const { listeners } = cur\\n\\n        // each item of the listeners array is an array: [function, capture, passive]\\n        for (let i = listeners.length - 1; i &gt;= 0; i--) {\\n          const [fn, { capture, passive }] = listeners[i]\\n\\n          // check if the listener functions and capture and passive flags match\\n          if (fn === listener &amp;&amp; capture === options.capture &amp;&amp; passive === options.passive) {\\n            // remove the listener from the array of listeners\\n            listeners.splice(i, 1)\\n\\n            // if all listeners for this target have been removed\\n            // remove the target from the delegates array\\n            if (!listeners.length) {\\n              delegates.splice(index, 1)\\n\\n              // remove delegate function from context\\n              remove(context, type, delegateListener)\\n              remove(context, type, delegateUseCapture, true)\\n            }\\n\\n            // only remove one listener\\n            matchFound = true\\n            break\\n          }\\n        }\\n\\n        if (matchFound) {\\n          break\\n        }\\n      }\\n    }\\n  }\\n\\n  // bound to the interactable context when a DOM event\\n  // listener is added to a selector interactable\\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\\n    const options = getOptions(optionalArg)\\n    const fakeEvent = new FakeEvent(event as Event)\\n    const delegates = delegatedEvents[event.type]\\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\\n    let element: Node = eventTarget\\n\\n    // climb up document tree looking for selector matches\\n    while (is.element(element)) {\\n      for (let i = 0; i &lt; delegates.length; i++) {\\n        const cur = delegates[i]\\n        const { selector, context } = cur\\n\\n        if (\\n          domUtils.matchesSelector(element, selector) &amp;&amp;\\n          domUtils.nodeContains(context, eventTarget) &amp;&amp;\\n          domUtils.nodeContains(context, element)\\n        ) {\\n          const { listeners } = cur\\n\\n          fakeEvent.currentTarget = element\\n\\n          for (const [fn, { capture, passive }] of listeners) {\\n            if (capture === options.capture &amp;&amp; passive === options.passive) {\\n              fn(fakeEvent)\\n            }\\n          }\\n        }\\n      }\\n\\n      element = domUtils.parentNode(element)\\n    }\\n  }\\n\\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\\n    return delegateListener.call(this, event, true)\\n  }\\n\\n  // for type inferrence\\n  return eventsMethods\\n}\\n\\nclass FakeEvent implements Partial&lt;Event&gt; {\\n  currentTarget: Node\\n  originalEvent: Event\\n  type: string\\n\\n  constructor (originalEvent: Event) {\\n    this.originalEvent = originalEvent\\n    // duplicate the event so that currentTarget can be changed\\n    pExtend(this, originalEvent)\\n  }\\n\\n  preventOriginalDefault () {\\n    this.originalEvent.preventDefault()\\n  }\\n\\n  stopPropagation () {\\n    this.originalEvent.stopPropagation()\\n  }\\n\\n  stopImmediatePropagation () {\\n    this.originalEvent.stopImmediatePropagation()\\n  }\\n}\\n\\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\\n  if (!is.object(param)) {\\n    return { capture: !!param, passive: false }\\n  }\\n\\n  const options = extend({}, param) as any\\n\\n  options.capture = !!param.capture\\n  options.passive = !!param.passive\\n\\n  return options\\n}\\n\\nexport default {\\n  id: 'events',\\n  install,\\n}\\n\"</span>,<span class=\"code-string\">\"/** @module interact */\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { Context, EventTypes, ListenersArg, Target, Element, Listener } from '@interactjs/types/index'\\nimport browser from '@interactjs/utils/browser'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport is from '@interactjs/utils/is'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\nimport { warnOnce } from '../utils/misc'\\n\\nimport type { Interactable } from './Interactable'\\nimport type { Options } from './defaultOptions'\\nimport isNonNativeEvent from './isNonNativeEvent'\\n\\nexport interface InteractStatic {\\n  (target: Target, options?: Options): Interactable\\n  getPointerAverage: typeof pointerUtils.pointerAverage\\n  getTouchBBox: typeof pointerUtils.touchBBox\\n  getTouchDistance: typeof pointerUtils.touchDistance\\n  getTouchAngle: typeof pointerUtils.touchAngle\\n  getElementRect: typeof domUtils.getElementRect\\n  getElementClientRect: typeof domUtils.getElementClientRect\\n  matchesSelector: typeof domUtils.matchesSelector\\n  closest: typeof domUtils.closest\\n  /** @internal */ globalEvents: any\\n  version: string\\n  /** @internal */ scope: Scope\\n  use(\\n    plugin: Plugin,\\n    options?: {\\n      [key: string]: any\\n    },\\n  ): any\\n  isSet(target: Element, options?: any): boolean\\n  on(type: string | EventTypes, listener: ListenersArg, options?: object): any\\n  off(type: EventTypes, listener: any, options?: object): any\\n  debug(): any\\n  supportsTouch(): boolean\\n  supportsPointerEvent(): boolean\\n  stop(): any\\n  pointerMoveTolerance(newValue?: number): any\\n  addDocument(doc: Document, options?: object): void\\n  removeDocument(doc: Document): void\\n}\\n\\nexport function createInteractStatic (scope: Scope): InteractStatic {\\n  /**\\n   * ```js\\n   * interact('#draggable').draggable(true)\\n   *\\n   * var rectables = interact('rect')\\n   * rectables\\n   *   .gesturable(true)\\n   *   .on('gesturemove', function (event) {\\n   *       // ...\\n   *   })\\n   * ```\\n   *\\n   * The methods of this variable can be used to set elements as interactables\\n   * and also to change various default settings.\\n   *\\n   * Calling it as a function and passing an element or a valid CSS selector\\n   * string returns an Interactable object which has various methods to configure\\n   * it.\\n   *\\n   * @global\\n   *\\n   * @param {Element | string} target The HTML or SVG Element to interact with\\n   * or CSS selector\\n   * @return {Interactable}\\n   */\\n  const interact = ((target, options) =&gt; {\\n    let interactable = scope.interactables.get(target, options)\\n\\n    if (!interactable) {\\n      interactable = scope.interactables.new(target, options)\\n      interactable.events.global = interact.globalEvents\\n    }\\n\\n    return interactable\\n  }) as InteractStatic\\n\\n  // expose the functions used to calculate multi-touch properties\\n  interact.getPointerAverage = pointerUtils.pointerAverage\\n  interact.getTouchBBox = pointerUtils.touchBBox\\n  interact.getTouchDistance = pointerUtils.touchDistance\\n  interact.getTouchAngle = pointerUtils.touchAngle\\n\\n  interact.getElementRect = domUtils.getElementRect\\n  interact.getElementClientRect = domUtils.getElementClientRect\\n  interact.matchesSelector = domUtils.matchesSelector\\n  interact.closest = domUtils.closest\\n\\n  interact.globalEvents = {} as any\\n\\n  // eslint-disable-next-line no-undef\\n  interact.version = process.env.npm_package_version\\n  interact.scope = scope\\n  /**\\n   * Use a plugin\\n   *\\n   * @alias module:interact.use\\n   *\\n   */\\n  interact.use = function (plugin, options) {\\n    this.scope.usePlugin(plugin, options)\\n\\n    return this\\n  }\\n\\n  /**\\n   * Check if an element or selector has been set with the {@link interact}\\n   * function\\n   *\\n   * @alias module:interact.isSet\\n   *\\n   * @param {Target} target The Element or string being searched for\\n   * @param {object} options\\n   * @return {boolean} Indicates if the element or CSS selector was previously\\n   * passed to interact\\n   */\\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\\n    return !!this.scope.interactables.get(target, options &amp;&amp; options.context)\\n  }\\n\\n  /**\\n   * @deprecated\\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\\n   *\\n   * @alias module:interact.on\\n   *\\n   * @param {string | array | object} type The types of events to listen for\\n   * @param {function} listener The function event (s)\\n   * @param {object | boolean} [options] object or useCapture flag for\\n   * addEventListener\\n   * @return {object} interact\\n   */\\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\\n    if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\\n      type = type.trim().split(/ +/)\\n    }\\n\\n    if (is.array(type)) {\\n      for (const eventType of type as any[]) {\\n        this.on(eventType, listener, options)\\n      }\\n\\n      return this\\n    }\\n\\n    if (is.object(type)) {\\n      for (const prop in type) {\\n        this.on(prop, (type as any)[prop], listener)\\n      }\\n\\n      return this\\n    }\\n\\n    // if it is an InteractEvent type, add listener to globalEvents\\n    if (isNonNativeEvent(type, this.scope.actions)) {\\n      // if this type of event was never bound\\n      if (!this.globalEvents[type]) {\\n        this.globalEvents[type] = [listener]\\n      } else {\\n        this.globalEvents[type].push(listener)\\n      }\\n    }\\n    // If non InteractEvent type, addEventListener to document\\n    else {\\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\\n    }\\n\\n    return this\\n  }, 'The interact.on() method is being deprecated')\\n\\n  /**\\n   * @deprecated\\n   * Removes a global InteractEvent listener or DOM event from `document`\\n   *\\n   * @alias module:interact.off\\n   *\\n   * @param {string | array | object} type The types of events that were listened\\n   * for\\n   * @param {function} listener The listener function to be removed\\n   * @param {object | boolean} options [options] object or useCapture flag for\\n   * removeEventListener\\n   * @return {object} interact\\n   */\\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\\n    if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\\n      type = type.trim().split(/ +/)\\n    }\\n\\n    if (is.array(type)) {\\n      for (const eventType of type) {\\n        this.off(eventType, listener, options)\\n      }\\n\\n      return this\\n    }\\n\\n    if (is.object(type)) {\\n      for (const prop in type) {\\n        this.off(prop, type[prop], listener)\\n      }\\n\\n      return this\\n    }\\n\\n    if (isNonNativeEvent(type, this.scope.actions)) {\\n      let index: number\\n\\n      if (type in this.globalEvents &amp;&amp; (index = this.globalEvents[type].indexOf(listener)) !== -1) {\\n        this.globalEvents[type].splice(index, 1)\\n      }\\n    } else {\\n      this.scope.events.remove(this.scope.document, type, listener, options)\\n    }\\n\\n    return this\\n  }, 'The interact.off() method is being deprecated')\\n\\n  interact.debug = function () {\\n    return this.scope\\n  }\\n\\n  /**\\n   * @alias module:interact.supportsTouch\\n   *\\n   * @return {boolean} Whether or not the browser supports touch input\\n   */\\n  interact.supportsTouch = function () {\\n    return browser.supportsTouch\\n  }\\n\\n  /**\\n   * @alias module:interact.supportsPointerEvent\\n   *\\n   * @return {boolean} Whether or not the browser supports PointerEvents\\n   */\\n  interact.supportsPointerEvent = function () {\\n    return browser.supportsPointerEvent\\n  }\\n\\n  /**\\n   * Cancels all interactions (end events are not fired)\\n   *\\n   * @alias module:interact.stop\\n   *\\n   * @return {object} interact\\n   */\\n  interact.stop = function () {\\n    for (const interaction of this.scope.interactions.list) {\\n      interaction.stop()\\n    }\\n\\n    return this\\n  }\\n\\n  /**\\n   * Returns or sets the distance the pointer must be moved before an action\\n   * sequence occurs. This also affects tolerance for tap events.\\n   *\\n   * @alias module:interact.pointerMoveTolerance\\n   *\\n   * @param {number} [newValue] The movement from the start position must be greater than this value\\n   * @return {interact | number}\\n   */\\n  interact.pointerMoveTolerance = function (newValue?: number) {\\n    if (is.number(newValue)) {\\n      this.scope.interactions.pointerMoveTolerance = newValue\\n\\n      return this\\n    }\\n\\n    return this.scope.interactions.pointerMoveTolerance\\n  }\\n\\n  interact.addDocument = function (doc: Document, options?: object) {\\n    this.scope.addDocument(doc, options)\\n  }\\n\\n  interact.removeDocument = function (doc: Document) {\\n    this.scope.removeDocument(doc)\\n  }\\n\\n  return interact as any\\n}\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport type { Scope } from '@interactjs/core/scope'\\nimport type { PointerType } from '@interactjs/types/index'\\nimport * as dom from '@interactjs/utils/domUtils'\\n\\nexport interface SearchDetails {\\n  pointer: PointerType\\n  pointerId: number\\n  pointerType: string\\n  eventType: string\\n  eventTarget: EventTarget\\n  curEventTarget: EventTarget\\n  scope: Scope\\n}\\n\\nconst finder = {\\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\\n\\n  search (details: SearchDetails) {\\n    for (const method of finder.methodOrder) {\\n      const interaction = finder[method](details)\\n\\n      if (interaction) {\\n        return interaction\\n      }\\n    }\\n\\n    return null\\n  },\\n\\n  // try to resume simulation with a new pointer\\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\\n    if (!/down|start/i.test(eventType)) {\\n      return null\\n    }\\n\\n    for (const interaction of scope.interactions.list) {\\n      let element = eventTarget as Node\\n\\n      if (\\n        interaction.simulation &amp;&amp;\\n        interaction.simulation.allowResume &amp;&amp;\\n        interaction.pointerType === pointerType\\n      ) {\\n        while (element) {\\n          // if the element is the interaction element\\n          if (element === interaction.element) {\\n            return interaction\\n          }\\n          element = dom.parentNode(element)\\n        }\\n      }\\n    }\\n\\n    return null\\n  },\\n\\n  // if it's a mouse or pen interaction\\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\\n    if (pointerType !== 'mouse' &amp;&amp; pointerType !== 'pen') {\\n      return null\\n    }\\n\\n    let firstNonActive\\n\\n    for (const interaction of scope.interactions.list) {\\n      if (interaction.pointerType === pointerType) {\\n        // if it's a down event, skip interactions with running simulations\\n        if (interaction.simulation &amp;&amp; !hasPointerId(interaction, pointerId)) {\\n          continue\\n        }\\n\\n        // if the interaction is active, return it immediately\\n        if (interaction.interacting()) {\\n          return interaction\\n        }\\n        // otherwise save it and look for another active interaction\\n        else if (!firstNonActive) {\\n          firstNonActive = interaction\\n        }\\n      }\\n    }\\n\\n    // if no active mouse interaction was found use the first inactive mouse\\n    // interaction\\n    if (firstNonActive) {\\n      return firstNonActive\\n    }\\n\\n    // find any mouse or pen interaction.\\n    // ignore the interaction if the eventType is a *down, and a simulation\\n    // is active\\n    for (const interaction of scope.interactions.list) {\\n      if (interaction.pointerType === pointerType &amp;&amp; !(/down/i.test(eventType) &amp;&amp; interaction.simulation)) {\\n        return interaction\\n      }\\n    }\\n\\n    return null\\n  },\\n\\n  // get interaction that has this pointer\\n  hasPointer ({ pointerId, scope }: SearchDetails) {\\n    for (const interaction of scope.interactions.list) {\\n      if (hasPointerId(interaction, pointerId)) {\\n        return interaction\\n      }\\n    }\\n\\n    return null\\n  },\\n\\n  // get first idle interaction with a matching pointerType\\n  idle ({ pointerType, scope }: SearchDetails) {\\n    for (const interaction of scope.interactions.list) {\\n      // if there's already a pointer held down\\n      if (interaction.pointers.length === 1) {\\n        const target = interaction.interactable\\n        // don't add this pointer if there is a target interactable and it\\n        // isn't gesturable\\n        if (target &amp;&amp; !(target.options.gesture &amp;&amp; target.options.gesture.enabled)) {\\n          continue\\n        }\\n      }\\n      // maximum of 2 pointers per interaction\\n      else if (interaction.pointers.length &gt;= 2) {\\n        continue\\n      }\\n\\n      if (!interaction.interacting() &amp;&amp; pointerType === interaction.pointerType) {\\n        return interaction\\n      }\\n    }\\n\\n    return null\\n  },\\n}\\n\\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\\n  return interaction.pointers.some(({ id }) =&gt; id === pointerId)\\n}\\n\\nexport default finder\\n\"</span>,<span class=\"code-string\">\"import type { Scope, ActionName, SignalArgs, Plugin } from '@interactjs/core/scope'\\nimport type { Listener } from '@interactjs/types/index'\\nimport browser from '@interactjs/utils/browser'\\nimport domObjects from '@interactjs/utils/domObjects'\\nimport { nodeContains } from '@interactjs/utils/domUtils'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\nimport InteractionBase from './Interaction'\\nimport interactablePreventDefault from './interactablePreventDefault'\\nimport type { SearchDetails } from './interactionFinder'\\nimport finder from './interactionFinder'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    Interaction: typeof InteractionBase\\n    interactions: {\\n      new: &lt;T extends ActionName&gt;(options: any) =&gt; InteractionBase&lt;T&gt;\\n      list: Array&lt;InteractionBase&lt;ActionName&gt;&gt;\\n      listeners: { [type: string]: Listener }\\n      docEvents: Array&lt;{ type: string, listener: Listener }&gt;\\n      pointerMoveTolerance: number\\n    }\\n    prevTouchTime: number\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'interactions:find': {\\n      interaction: InteractionBase\\n      searchDetails: SearchDetails\\n    }\\n  }\\n}\\n\\nconst methodNames = [\\n  'pointerDown',\\n  'pointerMove',\\n  'pointerUp',\\n  'updatePointer',\\n  'removePointer',\\n  'windowBlur',\\n]\\n\\nfunction install (scope: Scope) {\\n  const listeners = {} as any\\n\\n  for (const method of methodNames) {\\n    listeners[method] = doOnInteractions(method, scope)\\n  }\\n\\n  const pEventTypes = browser.pEventTypes\\n  let docEvents: typeof scope.interactions.docEvents\\n\\n  if (domObjects.PointerEvent) {\\n    docEvents = [\\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\\n      { type: pEventTypes.down, listener: listeners.pointerDown },\\n      { type: pEventTypes.move, listener: listeners.pointerMove },\\n      { type: pEventTypes.up, listener: listeners.pointerUp },\\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\\n    ]\\n  } else {\\n    docEvents = [\\n      { type: 'mousedown', listener: listeners.pointerDown },\\n      { type: 'mousemove', listener: listeners.pointerMove },\\n      { type: 'mouseup', listener: listeners.pointerUp },\\n\\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\\n      { type: 'touchstart', listener: listeners.pointerDown },\\n      { type: 'touchmove', listener: listeners.pointerMove },\\n      { type: 'touchend', listener: listeners.pointerUp },\\n      { type: 'touchcancel', listener: listeners.pointerUp },\\n    ]\\n  }\\n\\n  docEvents.push({\\n    type: 'blur',\\n    listener (event) {\\n      for (const interaction of scope.interactions.list) {\\n        interaction.documentBlur(event)\\n      }\\n    },\\n  })\\n\\n  // for ignoring browser's simulated mouse events\\n  scope.prevTouchTime = 0\\n\\n  scope.Interaction = class &lt;T extends ActionName&gt; extends InteractionBase&lt;T&gt; {\\n    get pointerMoveTolerance () {\\n      return scope.interactions.pointerMoveTolerance\\n    }\\n\\n    set pointerMoveTolerance (value) {\\n      scope.interactions.pointerMoveTolerance = value\\n    }\\n\\n    _now () {\\n      return scope.now()\\n    }\\n  }\\n\\n  scope.interactions = {\\n    // all active and idle interactions\\n    list: [],\\n    new&lt;T extends ActionName&gt; (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\\n      options.scopeFire = (name, arg) =&gt; scope.fire(name, arg)\\n\\n      const interaction = new scope.Interaction&lt;T&gt;(options as Required&lt;typeof options&gt;)\\n\\n      scope.interactions.list.push(interaction)\\n      return interaction\\n    },\\n    listeners,\\n    docEvents,\\n    pointerMoveTolerance: 1,\\n  }\\n\\n  function releasePointersOnRemovedEls () {\\n    // for all inactive touch interactions with pointers down\\n    for (const interaction of scope.interactions.list) {\\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\\n        continue\\n      }\\n\\n      // if a pointer is down on an element that is no longer in the DOM tree\\n      for (const pointer of interaction.pointers) {\\n        if (!scope.documents.some(({ doc }) =&gt; nodeContains(doc, pointer.downTarget))) {\\n          // remove the pointer from the interaction\\n          interaction.removePointer(pointer.pointer, pointer.event)\\n        }\\n      }\\n    }\\n  }\\n\\n  scope.usePlugin(interactablePreventDefault)\\n}\\n\\nfunction doOnInteractions (method: string, scope: Scope) {\\n  return function (event: Event) {\\n    const interactions = scope.interactions.list\\n\\n    const pointerType = pointerUtils.getPointerType(event)\\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\\n    const matches: any[] = [] // [ [pointer, interaction], ...]\\n\\n    if (/^touch/.test(event.type)) {\\n      scope.prevTouchTime = scope.now()\\n\\n      // @ts-expect-error\\n      for (const changedTouch of event.changedTouches) {\\n        const pointer = changedTouch\\n        const pointerId = pointerUtils.getPointerId(pointer)\\n        const searchDetails: SearchDetails = {\\n          pointer,\\n          pointerId,\\n          pointerType,\\n          eventType: event.type,\\n          eventTarget,\\n          curEventTarget,\\n          scope,\\n        }\\n        const interaction = getInteraction(searchDetails)\\n\\n        matches.push([\\n          searchDetails.pointer,\\n          searchDetails.eventTarget,\\n          searchDetails.curEventTarget,\\n          interaction,\\n        ])\\n      }\\n    } else {\\n      let invalidPointer = false\\n\\n      if (!browser.supportsPointerEvent &amp;&amp; /mouse/.test(event.type)) {\\n        // ignore mouse events while touch interactions are active\\n        for (let i = 0; i &lt; interactions.length &amp;&amp; !invalidPointer; i++) {\\n          invalidPointer = interactions[i].pointerType !== 'mouse' &amp;&amp; interactions[i].pointerIsDown\\n        }\\n\\n        // try to ignore mouse events that are simulated by the browser\\n        // after a touch event\\n        invalidPointer =\\n          invalidPointer ||\\n          scope.now() - scope.prevTouchTime &lt; 500 ||\\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\\n          event.timeStamp === 0\\n      }\\n\\n      if (!invalidPointer) {\\n        const searchDetails = {\\n          pointer: event as PointerEvent,\\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\\n          pointerType,\\n          eventType: event.type,\\n          curEventTarget,\\n          eventTarget,\\n          scope,\\n        }\\n\\n        const interaction = getInteraction(searchDetails)\\n\\n        matches.push([\\n          searchDetails.pointer,\\n          searchDetails.eventTarget,\\n          searchDetails.curEventTarget,\\n          interaction,\\n        ])\\n      }\\n    }\\n\\n    // eslint-disable-next-line no-shadow\\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\\n      interaction[method](pointer, event, eventTarget, curEventTarget)\\n    }\\n  }\\n}\\n\\nfunction getInteraction (searchDetails: SearchDetails) {\\n  const { pointerType, scope } = searchDetails\\n\\n  const foundInteraction = finder.search(searchDetails)\\n  const signalArg = { interaction: foundInteraction, searchDetails }\\n\\n  scope.fire('interactions:find', signalArg)\\n\\n  return signalArg.interaction || scope.interactions.new({ pointerType })\\n}\\n\\nfunction onDocSignal&lt;T extends 'scope:add-document' | 'scope:remove-document'&gt; (\\n  { doc, scope, options }: SignalArgs[T],\\n  eventMethodName: 'add' | 'remove',\\n) {\\n  const {\\n    interactions: { docEvents },\\n    events,\\n  } = scope\\n  const eventMethod = events[eventMethodName]\\n\\n  if (scope.browser.isIOS &amp;&amp; !options.events) {\\n    options.events = { passive: false }\\n  }\\n\\n  // delegate event listener\\n  for (const eventType in events.delegatedEvents) {\\n    eventMethod(doc, eventType, events.delegateListener)\\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\\n  }\\n\\n  const eventOptions = options &amp;&amp; options.events\\n\\n  for (const { type, listener } of docEvents) {\\n    eventMethod(doc, type, listener, eventOptions)\\n  }\\n}\\n\\nconst interactions: Plugin = {\\n  id: 'core/interactions',\\n  install,\\n  listeners: {\\n    'scope:add-document': arg =&gt; onDocSignal(arg, 'add'),\\n    'scope:remove-document': arg =&gt; onDocSignal(arg, 'remove'),\\n    'interactable:unset': ({ interactable }, scope) =&gt; {\\n      // Stop and destroy related interactions when an Interactable is unset\\n      for (let i = scope.interactions.list.length - 1; i &gt;= 0; i--) {\\n        const interaction = scope.interactions.list[i]\\n\\n        if (interaction.interactable !== interactable) {\\n          continue\\n        }\\n\\n        interaction.stop()\\n        scope.fire('interactions:destroy', { interaction })\\n        interaction.destroy()\\n\\n        if (scope.interactions.list.length &gt; 2) {\\n          scope.interactions.list.splice(i, 1)\\n        }\\n      }\\n    },\\n  },\\n  onDocSignal,\\n  doOnInteractions,\\n  methodNames,\\n}\\n\\nexport default interactions\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport browser from '@interactjs/utils/browser'\\nimport clone from '@interactjs/utils/clone'\\nimport domObjects from '@interactjs/utils/domObjects'\\nimport extend from '@interactjs/utils/extend'\\nimport raf from '@interactjs/utils/raf'\\nimport * as win from '@interactjs/utils/window'\\n\\nimport { Eventable } from './Eventable'\\nimport type { PhaseMap } from './InteractEvent'\\nimport { InteractEvent } from './InteractEvent'\\nimport type { Interactable } from './Interactable'\\nimport { Interactable as InteractableBase } from './Interactable'\\nimport { InteractableSet } from './InteractableSet'\\nimport type { OptionsArg } from './defaultOptions'\\nimport { defaults } from './defaultOptions'\\nimport events from './events'\\nimport { createInteractStatic } from './interactStatic'\\nimport interactions from './interactions'\\n\\nexport interface SignalArgs {\\n  'scope:add-document': DocSignalArg\\n  'scope:remove-document': DocSignalArg\\n  'interactable:unset': { interactable: InteractableBase }\\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\\n  'interactions:destroy': { interaction: Interaction }\\n}\\n\\nexport type ListenerName = keyof SignalArgs\\n\\nexport type ListenerMap = {\\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) =&gt; void | boolean\\n}\\n\\ninterface DocSignalArg {\\n  doc: Document\\n  window: Window\\n  scope: Scope\\n  options: Record&lt;string, any&gt;\\n}\\n\\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\\nexport interface ActionMap {}\\nexport type ActionName = keyof ActionMap\\n\\nexport interface Actions {\\n  map: ActionMap\\n  phases: PhaseMap\\n  methodDict: { [P in ActionName]?: keyof Interactable }\\n  phaselessTypes: { [type: string]: true }\\n}\\n\\nexport interface Plugin {\\n  [key: string]: any\\n  id?: string\\n  listeners?: ListenerMap\\n  before?: string[]\\n  install?(scope: Scope, options?: any): void\\n}\\n\\nexport class Scope {\\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\\n  isInitialized = false\\n  listenerMaps: Array&lt;{\\n    map: ListenerMap\\n    id: string\\n  }&gt; = []\\n\\n  browser = browser\\n  defaults = clone(defaults) as typeof defaults\\n  Eventable = Eventable\\n  actions: Actions = {\\n    map: {},\\n    phases: {\\n      start: true,\\n      move: true,\\n      end: true,\\n    },\\n    methodDict: {},\\n    phaselessTypes: {},\\n  }\\n\\n  interactStatic = createInteractStatic(this)\\n  InteractEvent = InteractEvent\\n  Interactable: typeof InteractableBase\\n  interactables = new InteractableSet(this)\\n\\n  // main window\\n  _win!: Window\\n\\n  // main document\\n  document!: Document\\n\\n  // main window\\n  window!: Window\\n\\n  // all documents being listened to\\n  documents: Array&lt;{ doc: Document, options: any }&gt; = []\\n\\n  _plugins: {\\n    list: Plugin[]\\n    map: { [id: string]: Plugin }\\n  } = {\\n    list: [],\\n    map: {},\\n  }\\n\\n  constructor () {\\n    const scope = this\\n\\n    this.Interactable = class extends InteractableBase {\\n      get _defaults () {\\n        return scope.defaults\\n      }\\n\\n      set&lt;T extends InteractableBase&gt; (this: T, options: OptionsArg) {\\n        super.set(options)\\n\\n        scope.fire('interactable:set', {\\n          options,\\n          interactable: this,\\n        })\\n\\n        return this\\n      }\\n\\n      unset (this: InteractableBase) {\\n        super.unset()\\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\\n\\n        scope.fire('interactable:unset', { interactable: this })\\n      }\\n    }\\n  }\\n\\n  addListeners (map: ListenerMap, id?: string) {\\n    this.listenerMaps.push({ id, map })\\n  }\\n\\n  fire&lt;T extends ListenerName&gt; (name: T, arg: SignalArgs[T]): void | false {\\n    for (const {\\n      map: { [name]: listener },\\n    } of this.listenerMaps) {\\n      if (!!listener &amp;&amp; listener(arg as any, this, name as never) === false) {\\n        return false\\n      }\\n    }\\n  }\\n\\n  onWindowUnload = (event: BeforeUnloadEvent) =&gt; this.removeDocument(event.target as Document)\\n\\n  init (window: Window) {\\n    return this.isInitialized ? this : initScope(this, window)\\n  }\\n\\n  pluginIsInstalled (plugin: Plugin) {\\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\\n  }\\n\\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\\n    if (!this.isInitialized) {\\n      return this\\n    }\\n\\n    if (this.pluginIsInstalled(plugin)) {\\n      return this\\n    }\\n\\n    if (plugin.id) {\\n      this._plugins.map[plugin.id] = plugin\\n    }\\n    this._plugins.list.push(plugin)\\n\\n    if (plugin.install) {\\n      plugin.install(this, options)\\n    }\\n\\n    if (plugin.listeners &amp;&amp; plugin.before) {\\n      let index = 0\\n      const len = this.listenerMaps.length\\n      const before = plugin.before.reduce((acc, id) =&gt; {\\n        acc[id] = true\\n        acc[pluginIdRoot(id)] = true\\n        return acc\\n      }, {})\\n\\n      for (; index &lt; len; index++) {\\n        const otherId = this.listenerMaps[index].id\\n\\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\\n          break\\n        }\\n      }\\n\\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\\n    } else if (plugin.listeners) {\\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\\n    }\\n\\n    return this\\n  }\\n\\n  addDocument (doc: Document, options?: any): void | false {\\n    // do nothing if document is already known\\n    if (this.getDocIndex(doc) !== -1) {\\n      return false\\n    }\\n\\n    const window = win.getWindow(doc)\\n\\n    options = options ? extend({}, options) : {}\\n\\n    this.documents.push({ doc, options })\\n    this.events.documents.push(doc)\\n\\n    // don't add an unload event for the main document\\n    // so that the page may be cached in browser history\\n    if (doc !== this.document) {\\n      this.events.add(window, 'unload', this.onWindowUnload)\\n    }\\n\\n    this.fire('scope:add-document', { doc, window, scope: this, options })\\n  }\\n\\n  removeDocument (doc: Document) {\\n    const index = this.getDocIndex(doc)\\n\\n    const window = win.getWindow(doc)\\n    const options = this.documents[index].options\\n\\n    this.events.remove(window, 'unload', this.onWindowUnload)\\n\\n    this.documents.splice(index, 1)\\n    this.events.documents.splice(index, 1)\\n\\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\\n  }\\n\\n  getDocIndex (doc: Document) {\\n    for (let i = 0; i &lt; this.documents.length; i++) {\\n      if (this.documents[i].doc === doc) {\\n        return i\\n      }\\n    }\\n\\n    return -1\\n  }\\n\\n  getDocOptions (doc: Document) {\\n    const docIndex = this.getDocIndex(doc)\\n\\n    return docIndex === -1 ? null : this.documents[docIndex].options\\n  }\\n\\n  now () {\\n    return (((this.window as any).Date as typeof Date) || Date).now()\\n  }\\n}\\n\\nexport function initScope (scope: Scope, window: Window) {\\n  scope.isInitialized = true\\n  win.init(window)\\n  domObjects.init(window)\\n  browser.init(window)\\n  raf.init(window)\\n\\n  scope.window = window\\n  scope.document = window.document\\n\\n  scope.usePlugin(interactions)\\n  scope.usePlugin(events)\\n\\n  return scope\\n}\\n\\nfunction pluginIdRoot (id: string) {\\n  return id &amp;&amp; id.replace(/\\\\/.*$/, '')\\n}\\n\"</span>,<span class=\"code-string\">\"import { Scope } from '@interactjs/core/scope'\\n\\nconst scope = new Scope()\\n\\nconst interact = scope.interactStatic\\n\\nexport default interact\\n\\nexport const init = (win: Window) =&gt; scope.init(win)\\n\\nif (typeof window === 'object' &amp;&amp; !!window) {\\n  init(window)\\n}\\n\"</span>,<span class=\"code-string\">\"export default () =&gt; {}\\n\"</span>,<span class=\"code-string\">\"export default () =&gt; {}\\n\"</span>,<span class=\"code-string\">\"import type { Rect, Point } from '@interactjs/types/index'\\n\\nimport type { SnapFunction, SnapTarget } from '../modifiers/snap/pointer'\\n\\nexport type GridOptions = (Partial&lt;Rect&gt; | Point) &amp; {\\n  range?: number\\n  limits?: Rect\\n  offset?: Point\\n}\\n\\nexport default (grid: GridOptions) =&gt; {\\n  const coordFields = ([\\n    ['x', 'y'],\\n    ['left', 'top'],\\n    ['right', 'bottom'],\\n    ['width', 'height'],\\n  ] as const).filter(([xField, yField]) =&gt; xField in grid || yField in grid)\\n\\n  const gridFunc: SnapFunction &amp; {\\n    grid: typeof grid\\n    coordFields: typeof coordFields\\n  } = (x, y) =&gt; {\\n    const {\\n      range,\\n      limits = {\\n        left: -Infinity,\\n        right: Infinity,\\n        top: -Infinity,\\n        bottom: Infinity,\\n      },\\n      offset = { x: 0, y: 0 },\\n    } = grid\\n\\n    const result: SnapTarget &amp; {\\n      grid: typeof grid\\n    } = { range, grid, x: null as number, y: null as number }\\n\\n    for (const [xField, yField] of coordFields) {\\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\\n\\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\\n    }\\n\\n    return result\\n  }\\n\\n  gridFunc.grid = grid\\n  gridFunc.coordFields = coordFields\\n\\n  return gridFunc\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Plugin } from '@interactjs/core/scope'\\nimport extend from '@interactjs/utils/extend'\\n\\nimport * as allSnappers from './all'\\n\\ndeclare module '@interactjs/core/interactStatic' {\\n  export interface InteractStatic {\\n    snappers: typeof allSnappers\\n    createSnapGrid: typeof allSnappers.grid\\n  }\\n}\\n\\nconst snappersPlugin: Plugin = {\\n  id: 'snappers',\\n  install (scope) {\\n    const { interactStatic: interact } = scope\\n\\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\\n    interact.createSnapGrid = interact.snappers.grid\\n  },\\n}\\n\\nexport default snappersPlugin\\n\"</span>,<span class=\"code-string\">\"/**\\n * @module modifiers/aspectRatio\\n *\\n * @description\\n * This module forces elements to be resized with a specified dx/dy ratio.\\n *\\n * ```js\\n * interact(target).resizable({\\n *   modifiers: [\\n *     interact.modifiers.snapSize({\\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\\n *     }),\\n *     interact.aspectRatio({ ratio: 'preserve' }),\\n *   ],\\n * });\\n * ```\\n */\\n\\nimport type { Point, Rect, EdgeOptions } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport { addEdges } from '@interactjs/utils/rect'\\n\\nimport Modification from './Modification'\\nimport type { Modifier, ModifierModule, ModifierState } from './base'\\nimport { makeModifier } from './base'\\n\\nexport interface AspectRatioOptions {\\n  ratio?: number | 'preserve'\\n  equalDelta?: boolean\\n  modifiers?: Modifier[]\\n  enabled?: boolean\\n}\\n\\nexport type AspectRatioState = ModifierState&lt;\\nAspectRatioOptions,\\n{\\n  startCoords: Point\\n  startRect: Rect\\n  linkedEdges: EdgeOptions\\n  ratio: number\\n  equalDelta: boolean\\n  xIsPrimaryAxis: boolean\\n  edgeSign: 1 | -1\\n  subModification: Modification\\n}\\n&gt;\\n\\nconst aspectRatio: ModifierModule&lt;AspectRatioOptions, AspectRatioState&gt; = {\\n  start (arg) {\\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\\n    let { ratio } = state.options\\n    const { equalDelta, modifiers } = state.options\\n\\n    if (ratio === 'preserve') {\\n      ratio = rect.width / rect.height\\n    }\\n\\n    state.startCoords = extend({}, coords)\\n    state.startRect = extend({}, rect)\\n    state.ratio = ratio\\n    state.equalDelta = equalDelta\\n\\n    const linkedEdges = (state.linkedEdges = {\\n      top: originalEdges.top || (originalEdges.left &amp;&amp; !originalEdges.bottom),\\n      left: originalEdges.left || (originalEdges.top &amp;&amp; !originalEdges.right),\\n      bottom: originalEdges.bottom || (originalEdges.right &amp;&amp; !originalEdges.top),\\n      right: originalEdges.right || (originalEdges.bottom &amp;&amp; !originalEdges.left),\\n    })\\n\\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\\n\\n    if (state.equalDelta) {\\n      state.edgeSign = ((linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)) as 1 | -1\\n    } else {\\n      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left\\n      state.edgeSign = negativeSecondaryEdge ? -1 : 1\\n    }\\n\\n    extend(arg.edges, linkedEdges)\\n\\n    if (!modifiers || !modifiers.length) return\\n\\n    const subModification = new Modification(arg.interaction)\\n\\n    subModification.copyFrom(arg.interaction.modification)\\n    subModification.prepareStates(modifiers)\\n\\n    state.subModification = subModification\\n    subModification.startAll({ ...arg })\\n  },\\n\\n  set (arg) {\\n    const { state, rect, coords } = arg\\n    const initialCoords = extend({}, coords)\\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\\n\\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\\n\\n    if (!state.subModification) {\\n      return null\\n    }\\n\\n    const correctedRect = extend({}, rect)\\n\\n    addEdges(state.linkedEdges, correctedRect, {\\n      x: coords.x - initialCoords.x,\\n      y: coords.y - initialCoords.y,\\n    })\\n\\n    const result = state.subModification.setAll({\\n      ...arg,\\n      rect: correctedRect,\\n      edges: state.linkedEdges,\\n      pageCoords: coords,\\n      prevCoords: coords,\\n      prevRect: correctedRect,\\n    })\\n\\n    const { delta } = result\\n\\n    if (result.changed) {\\n      const xIsCriticalAxis = Math.abs(delta.x) &gt; Math.abs(delta.y)\\n\\n      // do aspect modification again with critical edge axis as primary\\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\\n      extend(coords, result.coords)\\n    }\\n\\n    return result.eventProps\\n  },\\n\\n  defaults: {\\n    ratio: 'preserve',\\n    equalDelta: false,\\n    modifiers: [],\\n    enabled: false,\\n  },\\n}\\n\\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\\n  if (xIsPrimaryAxis) {\\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign\\n  } else {\\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign\\n  }\\n}\\n\\nfunction setRatio (\\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\\n  xIsPrimaryAxis: boolean,\\n  coords: Point,\\n  rect: Rect,\\n) {\\n  if (xIsPrimaryAxis) {\\n    const newHeight = rect.width / ratio\\n\\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign\\n  } else {\\n    const newWidth = rect.height * ratio\\n\\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign\\n  }\\n}\\n\\nexport default makeModifier(aspectRatio, 'aspectRatio')\\nexport { aspectRatio }\\n\"</span>,<span class=\"code-string\">\"import type { ModifierFunction } from './base'\\n\\nconst noop = ((() =&gt; {}) as unknown) as ModifierFunction&lt;any, any, 'noop'&gt;\\n\\nnoop._defaults = {}\\n\\nexport default noop\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport type { RectResolvable, Rect, Point } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\nimport type { ModifierArg, ModifierModule, ModifierState } from '../base'\\nimport { makeModifier } from '../base'\\n\\nexport interface RestrictOptions {\\n  // where to drag over\\n  restriction: RectResolvable&lt;[number, number, Interaction]&gt;\\n  // what part of self is allowed to drag over\\n  elementRect: Rect\\n  offset: Rect\\n  // restrict just before the end drag\\n  endOnly: boolean\\n  enabled?: boolean\\n}\\n\\nexport type RestrictState = ModifierState&lt;\\nRestrictOptions,\\n{\\n  offset: Rect\\n}\\n&gt;\\n\\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg&lt;RestrictState&gt;) {\\n  const { options } = state\\n  const { elementRect } = options\\n  const offset: Rect = extend(\\n    {\\n      left: 0,\\n      top: 0,\\n      right: 0,\\n      bottom: 0,\\n    },\\n    options.offset || {},\\n  )\\n\\n  if (rect &amp;&amp; elementRect) {\\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\\n\\n    if (restriction) {\\n      const widthDiff = restriction.right - restriction.left - rect.width\\n      const heightDiff = restriction.bottom - restriction.top - rect.height\\n\\n      if (widthDiff &lt; 0) {\\n        offset.left += widthDiff\\n        offset.right += widthDiff\\n      }\\n      if (heightDiff &lt; 0) {\\n        offset.top += heightDiff\\n        offset.bottom += heightDiff\\n      }\\n    }\\n\\n    offset.left += startOffset.left - rect.width * elementRect.left\\n    offset.top += startOffset.top - rect.height * elementRect.top\\n\\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\\n  }\\n\\n  state.offset = offset\\n}\\n\\nfunction set ({ coords, interaction, state }: ModifierArg&lt;RestrictState&gt;) {\\n  const { options, offset } = state\\n\\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\\n\\n  if (!restriction) return\\n\\n  const rect = rectUtils.xywhToTlbr(restriction)\\n\\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\\n}\\n\\nexport function getRestrictionRect (\\n  value: RectResolvable&lt;[number, number, Interaction]&gt;,\\n  interaction: Interaction,\\n  coords?: Point,\\n) {\\n  if (is.func(value)) {\\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\\n      coords.x,\\n      coords.y,\\n      interaction,\\n    ])\\n  } else {\\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\\n  }\\n}\\n\\nconst defaults: RestrictOptions = {\\n  restriction: null,\\n  elementRect: null,\\n  offset: null,\\n  endOnly: false,\\n  enabled: false,\\n}\\n\\nconst restrict: ModifierModule&lt;RestrictOptions, RestrictState&gt; = {\\n  start,\\n  set,\\n  defaults,\\n}\\n\\nexport default makeModifier(restrict, 'restrict')\\nexport { restrict }\\n\"</span>,<span class=\"code-string\">\"// This module adds the options.resize.restrictEdges setting which sets min and\\n// max for the top, left, bottom and right edges of the target being resized.\\n//\\n// interact(target).resize({\\n//   edges: { top: true, left: true },\\n//   restrictEdges: {\\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\\n//   },\\n// })\\n\\nimport type { Point, Rect } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\nimport type { ModifierArg, ModifierState } from '../base'\\nimport { makeModifier } from '../base'\\n\\nimport type { RestrictOptions } from './pointer'\\nimport { getRestrictionRect } from './pointer'\\n\\nexport interface RestrictEdgesOptions {\\n  inner: RestrictOptions['restriction']\\n  outer: RestrictOptions['restriction']\\n  offset?: RestrictOptions['offset']\\n  endOnly: boolean\\n  enabled?: boolean\\n}\\n\\nexport type RestrictEdgesState = ModifierState&lt;\\nRestrictEdgesOptions,\\n{\\n  inner: Rect\\n  outer: Rect\\n  offset: RestrictEdgesOptions['offset']\\n}\\n&gt;\\n\\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\\n\\nfunction start ({ interaction, startOffset, state }: ModifierArg&lt;RestrictEdgesState&gt;) {\\n  const { options } = state\\n  let offset: Point\\n\\n  if (options) {\\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\\n\\n    offset = rectUtils.rectToXY(offsetRect)\\n  }\\n\\n  offset = offset || { x: 0, y: 0 }\\n\\n  state.offset = {\\n    top: offset.y + startOffset.top,\\n    left: offset.x + startOffset.left,\\n    bottom: offset.y - startOffset.bottom,\\n    right: offset.x - startOffset.right,\\n  }\\n}\\n\\nfunction set ({ coords, edges, interaction, state }: ModifierArg&lt;RestrictEdgesState&gt;) {\\n  const { offset, options } = state\\n\\n  if (!edges) {\\n    return\\n  }\\n\\n  const page = extend({}, coords)\\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\\n\\n  fixRect(inner, noInner)\\n  fixRect(outer, noOuter)\\n\\n  if (edges.top) {\\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\\n  } else if (edges.bottom) {\\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\\n  }\\n  if (edges.left) {\\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\\n  } else if (edges.right) {\\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\\n  }\\n}\\n\\nfunction fixRect (rect: Rect, defaults: Rect) {\\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\\n    if (!(edge in rect)) {\\n      rect[edge] = defaults[edge]\\n    }\\n  }\\n\\n  return rect\\n}\\n\\nconst defaults: RestrictEdgesOptions = {\\n  inner: null,\\n  outer: null,\\n  offset: null,\\n  endOnly: false,\\n  enabled: false,\\n}\\n\\nconst restrictEdges = {\\n  noInner,\\n  noOuter,\\n  start,\\n  set,\\n  defaults,\\n}\\n\\nexport default makeModifier(restrictEdges, 'restrictEdges')\\nexport { restrictEdges }\\n\"</span>,<span class=\"code-string\">\"import extend from '@interactjs/utils/extend'\\n\\nimport { makeModifier } from '../base'\\n\\nimport { restrict } from './pointer'\\n\\nconst defaults = extend(\\n  {\\n    get elementRect () {\\n      return { top: 0, left: 0, bottom: 1, right: 1 }\\n    },\\n    set elementRect (_) {},\\n  },\\n  restrict.defaults,\\n)\\n\\nconst restrictRect = {\\n  start: restrict.start,\\n  set: restrict.set,\\n  defaults,\\n}\\n\\nexport default makeModifier(restrictRect, 'restrictRect')\\nexport { restrictRect }\\n\"</span>,<span class=\"code-string\">\"import type { Point, Rect, Size } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport * as rectUtils from '@interactjs/utils/rect'\\n\\nimport type { ModifierArg, ModifierState } from '../base'\\nimport { makeModifier } from '../base'\\n\\nimport type { RestrictEdgesState } from './edges'\\nimport { restrictEdges } from './edges'\\nimport type { RestrictOptions } from './pointer'\\nimport { getRestrictionRect } from './pointer'\\n\\nconst noMin = { width: -Infinity, height: -Infinity }\\nconst noMax = { width: +Infinity, height: +Infinity }\\n\\nexport interface RestrictSizeOptions {\\n  min?: Size | Point | RestrictOptions['restriction']\\n  max?: Size | Point | RestrictOptions['restriction']\\n  endOnly: boolean\\n  enabled?: boolean\\n}\\n\\nfunction start (arg: ModifierArg&lt;RestrictEdgesState&gt;) {\\n  return restrictEdges.start(arg)\\n}\\n\\nexport type RestrictSizeState = RestrictEdgesState &amp;\\nModifierState&lt;\\nRestrictSizeOptions &amp; { inner: Rect, outer: Rect },\\n{\\n  min: Rect\\n  max: Rect\\n}\\n&gt;\\n\\nfunction set (arg: ModifierArg&lt;RestrictSizeState&gt;) {\\n  const { interaction, state, rect, edges } = arg\\n  const { options } = state\\n\\n  if (!edges) {\\n    return\\n  }\\n\\n  const minSize =\\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\\n  const maxSize =\\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\\n\\n  state.options = {\\n    endOnly: options.endOnly,\\n    inner: extend({}, restrictEdges.noInner),\\n    outer: extend({}, restrictEdges.noOuter),\\n  }\\n\\n  if (edges.top) {\\n    state.options.inner.top = rect.bottom - minSize.height\\n    state.options.outer.top = rect.bottom - maxSize.height\\n  } else if (edges.bottom) {\\n    state.options.inner.bottom = rect.top + minSize.height\\n    state.options.outer.bottom = rect.top + maxSize.height\\n  }\\n  if (edges.left) {\\n    state.options.inner.left = rect.right - minSize.width\\n    state.options.outer.left = rect.right - maxSize.width\\n  } else if (edges.right) {\\n    state.options.inner.right = rect.left + minSize.width\\n    state.options.outer.right = rect.left + maxSize.width\\n  }\\n\\n  restrictEdges.set(arg)\\n\\n  state.options = options\\n}\\n\\nconst defaults: RestrictSizeOptions = {\\n  min: null,\\n  max: null,\\n  endOnly: false,\\n  enabled: false,\\n}\\n\\nconst restrictSize = {\\n  start,\\n  set,\\n  defaults,\\n}\\n\\nexport default makeModifier(restrictSize, 'restrictSize')\\nexport { restrictSize }\\n\"</span>,<span class=\"code-string\">\"import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\\nimport type { ActionName } from '@interactjs/core/scope'\\nimport type { Point, RectResolvable, Element } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\nimport getOriginXY from '@interactjs/utils/getOriginXY'\\nimport hypot from '@interactjs/utils/hypot'\\nimport is from '@interactjs/utils/is'\\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\\n\\nimport type { ModifierArg, ModifierState } from '../base'\\nimport { makeModifier } from '../base'\\n\\nexport interface Offset {\\n  x: number\\n  y: number\\n  index: number\\n  relativePoint?: Point | null\\n}\\n\\nexport interface SnapPosition {\\n  x?: number\\n  y?: number\\n  range?: number\\n  offset?: Offset\\n  [index: string]: any\\n}\\n\\nexport type SnapFunction = (\\n  x: number,\\n  y: number,\\n  interaction: InteractionProxy&lt;ActionName&gt;,\\n  offset: Offset,\\n  index: number,\\n) =&gt; SnapPosition\\nexport type SnapTarget = SnapPosition | SnapFunction\\nexport interface SnapOptions {\\n  targets: SnapTarget[] | null\\n  // target range\\n  range: number\\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\\n  relativePoints: Point[] | null\\n  // startCoords = offset snapping from drag start page position\\n  offset: Point | RectResolvable&lt;[Interaction]&gt; | 'startCoords' | null\\n  offsetWithOrigin?: boolean\\n  origin: RectResolvable&lt;[Element]&gt; | Point | null\\n  endOnly?: boolean\\n  enabled?: boolean\\n}\\n\\nexport type SnapState = ModifierState&lt;\\nSnapOptions,\\n{\\n  offsets?: Offset[]\\n  closest?: any\\n  targetFields?: string[][]\\n}\\n&gt;\\n\\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\\n  const { interaction, interactable, element, rect, state, startOffset } = arg\\n  const { options } = state\\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\\n\\n  let snapOffset: Point\\n\\n  if (options.offset === 'startCoords') {\\n    snapOffset = {\\n      x: interaction.coords.start.page.x,\\n      y: interaction.coords.start.page.y,\\n    }\\n  } else {\\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\\n\\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\\n    snapOffset.x += origin.x\\n    snapOffset.y += origin.y\\n  }\\n\\n  const { relativePoints } = options\\n\\n  state.offsets =\\n    rect &amp;&amp; relativePoints &amp;&amp; relativePoints.length\\n      ? relativePoints.map((relativePoint, index) =&gt; ({\\n        index,\\n        relativePoint,\\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\\n      }))\\n      : [\\n        {\\n          index: 0,\\n          relativePoint: null,\\n          x: snapOffset.x,\\n          y: snapOffset.y,\\n        },\\n      ]\\n}\\n\\nfunction set (arg: ModifierArg&lt;SnapState&gt;) {\\n  const { interaction, coords, state } = arg\\n  const { options, offsets } = state\\n\\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\\n  const page = extend({}, coords)\\n  const targets = []\\n\\n  if (!options.offsetWithOrigin) {\\n    page.x -= origin.x\\n    page.y -= origin.y\\n  }\\n\\n  for (const offset of offsets) {\\n    const relativeX = page.x - offset.x\\n    const relativeY = page.y - offset.y\\n\\n    for (let index = 0, len = options.targets.length; index &lt; len; index++) {\\n      const snapTarget = options.targets[index]\\n      let target: SnapPosition\\n\\n      if (is.func(snapTarget)) {\\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\\n      } else {\\n        target = snapTarget\\n      }\\n\\n      if (!target) {\\n        continue\\n      }\\n\\n      targets.push({\\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\\n\\n        range: is.number(target.range) ? target.range : options.range,\\n        source: snapTarget,\\n        index,\\n        offset,\\n      })\\n    }\\n  }\\n\\n  const closest = {\\n    target: null,\\n    inRange: false,\\n    distance: 0,\\n    range: 0,\\n    delta: { x: 0, y: 0 },\\n  }\\n\\n  for (const target of targets) {\\n    const range = target.range\\n    const dx = target.x - page.x\\n    const dy = target.y - page.y\\n    const distance = hypot(dx, dy)\\n    let inRange = distance &lt;= range\\n\\n    // Infinite targets count as being out of range\\n    // compared to non infinite ones that are in range\\n    if (range === Infinity &amp;&amp; closest.inRange &amp;&amp; closest.range !== Infinity) {\\n      inRange = false\\n    }\\n\\n    if (\\n      !closest.target ||\\n      (inRange\\n        ? // is the closest target in range?\\n        closest.inRange &amp;&amp; range !== Infinity\\n          ? // the pointer is relatively deeper in this target\\n          distance / range &lt; closest.distance / closest.range\\n          : // this target has Infinite range and the closest doesn't\\n          (range === Infinity &amp;&amp; closest.range !== Infinity) ||\\n            // OR this target is closer that the previous closest\\n            distance &lt; closest.distance\\n        : // The other is not in range and the pointer is closer to this target\\n        !closest.inRange &amp;&amp; distance &lt; closest.distance)\\n    ) {\\n      closest.target = target\\n      closest.distance = distance\\n      closest.range = range\\n      closest.inRange = inRange\\n      closest.delta.x = dx\\n      closest.delta.y = dy\\n    }\\n  }\\n\\n  if (closest.inRange) {\\n    coords.x = closest.target.x\\n    coords.y = closest.target.y\\n  }\\n\\n  state.closest = closest\\n  return closest\\n}\\n\\nfunction getOrigin (arg: Partial&lt;ModifierArg&lt;SnapState&gt;&gt;) {\\n  const { element } = arg.interaction\\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\\n\\n  return origin\\n}\\n\\nconst defaults: SnapOptions = {\\n  range: Infinity,\\n  targets: null,\\n  offset: null,\\n  offsetWithOrigin: true,\\n  origin: null,\\n  relativePoints: null,\\n  endOnly: false,\\n  enabled: false,\\n}\\nconst snap = {\\n  start,\\n  set,\\n  defaults,\\n}\\n\\nexport default makeModifier(snap, 'snap')\\nexport { snap }\\n\"</span>,<span class=\"code-string\">\"// This module allows snapping of the size of targets during resize\\n// interactions.\\n\\nimport extend from '@interactjs/utils/extend'\\nimport is from '@interactjs/utils/is'\\n\\nimport type { ModifierArg } from '../base'\\nimport { makeModifier } from '../base'\\n\\nimport type { SnapOptions, SnapState } from './pointer'\\nimport { snap } from './pointer'\\n\\nexport type SnapSizeOptions = Pick&lt;SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'&gt;\\n\\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\\n  const { state, edges } = arg\\n  const { options } = state\\n\\n  if (!edges) {\\n    return null\\n  }\\n\\n  arg.state = {\\n    options: {\\n      targets: null,\\n      relativePoints: [\\n        {\\n          x: edges.left ? 0 : 1,\\n          y: edges.top ? 0 : 1,\\n        },\\n      ],\\n      offset: options.offset || 'self',\\n      origin: { x: 0, y: 0 },\\n      range: options.range,\\n    },\\n  }\\n\\n  state.targetFields = state.targetFields || [\\n    ['width', 'height'],\\n    ['x', 'y'],\\n  ]\\n\\n  snap.start(arg)\\n  state.offsets = arg.state.offsets\\n\\n  arg.state = state\\n}\\n\\nfunction set (arg) {\\n  const { interaction, state, coords } = arg\\n  const { options, offsets } = state\\n  const relative = {\\n    x: coords.x - offsets[0].x,\\n    y: coords.y - offsets[0].y,\\n  }\\n\\n  state.options = extend({}, options)\\n  state.options.targets = []\\n\\n  for (const snapTarget of options.targets || []) {\\n    let target\\n\\n    if (is.func(snapTarget)) {\\n      target = snapTarget(relative.x, relative.y, interaction)\\n    } else {\\n      target = snapTarget\\n    }\\n\\n    if (!target) {\\n      continue\\n    }\\n\\n    for (const [xField, yField] of state.targetFields) {\\n      if (xField in target || yField in target) {\\n        target.x = target[xField]\\n        target.y = target[yField]\\n\\n        break\\n      }\\n    }\\n\\n    state.options.targets.push(target)\\n  }\\n\\n  const returnValue = snap.set(arg)\\n\\n  state.options = options\\n\\n  return returnValue\\n}\\n\\nconst defaults: SnapSizeOptions = {\\n  range: Infinity,\\n  targets: null,\\n  offset: null,\\n  endOnly: false,\\n  enabled: false,\\n}\\n\\nconst snapSize = {\\n  start,\\n  set,\\n  defaults,\\n}\\n\\nexport default makeModifier(snapSize, 'snapSize')\\nexport { snapSize }\\n\"</span>,<span class=\"code-string\">\"/**\\n * @module modifiers/snapEdges\\n *\\n * @description\\n * WOW&gt; This module allows snapping of the edges of targets during resize\\n * interactions.\\n *\\n * ```js\\n * interact(target).resizable({\\n *   snapEdges: {\\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\\n *   },\\n * })\\n *\\n * interact(target).resizable({\\n *   snapEdges: {\\n *     targets: [\\n *       interact.snappers.grid({\\n *        top: 50,\\n *        left: 50,\\n *        bottom: 100,\\n *        right: 100,\\n *       }),\\n *     ],\\n *   },\\n * })\\n * ```\\n */\\n\\nimport clone from '@interactjs/utils/clone'\\nimport extend from '@interactjs/utils/extend'\\n\\nimport type { ModifierArg, ModifierModule } from '../base'\\nimport { makeModifier } from '../base'\\n\\nimport type { SnapOptions, SnapState } from './pointer'\\nimport { snapSize } from './size'\\n\\nexport type SnapEdgesOptions = Pick&lt;SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'&gt;\\n\\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\\n  const { edges } = arg\\n\\n  if (!edges) {\\n    return null\\n  }\\n\\n  arg.state.targetFields = arg.state.targetFields || [\\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\\n  ]\\n\\n  return snapSize.start(arg)\\n}\\n\\nconst snapEdges: ModifierModule&lt;SnapEdgesOptions, SnapState, ReturnType&lt;typeof snapSize.set&gt;&gt; = {\\n  start,\\n  set: snapSize.set,\\n  defaults: extend(clone(snapSize.defaults), {\\n    targets: null,\\n    range: null,\\n    offset: { x: 0, y: 0 },\\n  } as const),\\n}\\n\\nexport default makeModifier(snapEdges, 'snapEdges')\\nexport { snapEdges }\\n\"</span>,<span class=\"code-string\">\"/* eslint-disable node/no-extraneous-import */\\nimport aspectRatio from './aspectRatio'\\nimport avoid from './avoid'\\nimport restrictEdges from './restrict/edges'\\nimport restrict from './restrict/pointer'\\nimport restrictRect from './restrict/rect'\\nimport restrictSize from './restrict/size'\\nimport rubberband from './rubberband'\\nimport snapEdges from './snap/edges'\\nimport snap from './snap/pointer'\\nimport snapSize from './snap/size'\\nimport spring from './spring'\\nimport transform from './transform'\\n\\nexport default {\\n  aspectRatio,\\n  restrictEdges,\\n  restrict,\\n  restrictRect,\\n  restrictSize,\\n  snapEdges,\\n  snap,\\n  snapSize,\\n\\n  spring,\\n  avoid,\\n  transform,\\n  rubberband,\\n}\\n\"</span>,<span class=\"code-string\">\"import type { Plugin } from '@interactjs/core/scope'\\nimport snappers from '@interactjs/snappers/plugin'\\n\\nimport all from './all'\\nimport base from './base'\\n\\ndeclare module '@interactjs/core/interactStatic' {\\n  export interface InteractStatic {\\n    modifiers: typeof all\\n  }\\n}\\n\\nconst modifiers: Plugin = {\\n  id: 'modifiers',\\n  install (scope) {\\n    const { interactStatic: interact } = scope\\n\\n    scope.usePlugin(base)\\n    scope.usePlugin(snappers)\\n\\n    interact.modifiers = all\\n\\n    // for backwrads compatibility\\n    for (const type in all) {\\n      const { _defaults, _methods } = all[type as keyof typeof all]\\n\\n      ;(_defaults as any)._methods = _methods\\n      ;(scope.defaults.perAction as any)[type] = _defaults\\n    }\\n  },\\n}\\n\\nexport default modifiers\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport type { PointerEventType, PointerType, Point } from '@interactjs/types/index'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\n\\nimport { BaseEvent } from '../core/BaseEvent'\\n\\nexport default class PointerEvent&lt;T extends string = any&gt; extends BaseEvent&lt;never&gt; {\\n  type: T\\n  originalEvent: PointerEventType\\n  pointerId: number\\n  pointerType: string\\n  double: boolean\\n  pageX: number\\n  pageY: number\\n  clientX: number\\n  clientY: number\\n  dt: number\\n  eventable: any;\\n  [key: string]: any\\n\\n  /** */\\n  constructor (\\n    type: T,\\n    pointer: PointerType | PointerEvent&lt;any&gt;,\\n    event: PointerEventType,\\n    eventTarget: Node,\\n    interaction: Interaction&lt;never&gt;,\\n    timeStamp: number,\\n  ) {\\n    super(interaction)\\n    pointerUtils.pointerExtend(this, event)\\n\\n    if (event !== pointer) {\\n      pointerUtils.pointerExtend(this, pointer)\\n    }\\n\\n    this.timeStamp = timeStamp\\n    this.originalEvent = event\\n    this.type = type\\n    this.pointerId = pointerUtils.getPointerId(pointer)\\n    this.pointerType = pointerUtils.getPointerType(pointer)\\n    this.target = eventTarget\\n    this.currentTarget = null\\n\\n    if (type === 'tap') {\\n      const pointerIndex = interaction.getPointerIndex(pointer)\\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\\n\\n      const interval = this.timeStamp - interaction.tapTime\\n\\n      this.double = !!(\\n        interaction.prevTap &amp;&amp;\\n        interaction.prevTap.type !== 'doubletap' &amp;&amp;\\n        interaction.prevTap.target === this.target &amp;&amp;\\n        interval &lt; 500\\n      )\\n    } else if (type === 'doubletap') {\\n      this.dt = (pointer as PointerEvent&lt;'tap'&gt;).timeStamp - interaction.tapTime\\n    }\\n  }\\n\\n  _subtractOrigin ({ x: originX, y: originY }: Point) {\\n    this.pageX -= originX\\n    this.pageY -= originY\\n    this.clientX -= originX\\n    this.clientY -= originY\\n\\n    return this\\n  }\\n\\n  _addOrigin ({ x: originX, y: originY }: Point) {\\n    this.pageX += originX\\n    this.pageY += originY\\n    this.clientX += originX\\n    this.clientY += originY\\n\\n    return this\\n  }\\n\\n  /**\\n   * Prevent the default behaviour of the original Event\\n   */\\n  preventDefault () {\\n    this.originalEvent.preventDefault()\\n  }\\n}\\n\\nexport { PointerEvent }\\n\"</span>,<span class=\"code-string\">\"import type { Eventable } from '@interactjs/core/Eventable'\\nimport type { Interaction } from '@interactjs/core/Interaction'\\nimport type { PerActionDefaults } from '@interactjs/core/defaultOptions'\\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/types'\\nimport * as domUtils from '@interactjs/utils/domUtils'\\nimport extend from '@interactjs/utils/extend'\\nimport getOriginXY from '@interactjs/utils/getOriginXY'\\n\\nimport { PointerEvent } from './PointerEvent'\\n\\nexport type EventTargetList = Array&lt;{\\n  node: Node\\n  eventable: Eventable\\n  props: { [key: string]: any }\\n}&gt;\\n\\nexport interface PointerEventOptions extends PerActionDefaults {\\n  enabled?: undefined // not used\\n  holdDuration?: number\\n  ignoreFrom?: any\\n  allowFrom?: any\\n  origin?: Point | string | Element\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface Scope {\\n    pointerEvents: typeof pointerEvents\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    prevTap?: PointerEvent&lt;string&gt;\\n    tapTime?: number\\n  }\\n}\\n\\ndeclare module '@interactjs/core/PointerInfo' {\\n  interface PointerInfo {\\n    hold?: {\\n      duration: number\\n      timeout: any\\n    }\\n  }\\n}\\n\\ndeclare module '@interactjs/core/defaultOptions' {\\n  interface ActionDefaults {\\n    pointerEvents: Options\\n  }\\n}\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'pointerEvents:new': { pointerEvent: PointerEvent&lt;any&gt; }\\n    'pointerEvents:fired': {\\n      interaction: Interaction&lt;null&gt;\\n      pointer: PointerType | PointerEvent&lt;any&gt;\\n      event: PointerEventType | PointerEvent&lt;any&gt;\\n      eventTarget: Node\\n      pointerEvent: PointerEvent&lt;any&gt;\\n      targets?: EventTargetList\\n      type: string\\n    }\\n    'pointerEvents:collect-targets': {\\n      interaction: Interaction&lt;any&gt;\\n      pointer: PointerType | PointerEvent&lt;any&gt;\\n      event: PointerEventType | PointerEvent&lt;any&gt;\\n      eventTarget: Node\\n      targets?: EventTargetList\\n      type: string\\n      path: Node[]\\n      node: null\\n    }\\n  }\\n}\\n\\nconst defaults: PointerEventOptions = {\\n  holdDuration: 600,\\n  ignoreFrom: null,\\n  allowFrom: null,\\n  origin: { x: 0, y: 0 },\\n}\\n\\nconst pointerEvents: Plugin = {\\n  id: 'pointer-events/base',\\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\\n  install,\\n  listeners: {\\n    'interactions:new': addInteractionProps,\\n    'interactions:update-pointer': addHoldInfo,\\n    'interactions:move': moveAndClearHold,\\n    'interactions:down': (arg, scope) =&gt; {\\n      downAndStartHold(arg, scope)\\n      fire(arg, scope)\\n    },\\n    'interactions:up': (arg, scope) =&gt; {\\n      clearHold(arg)\\n      fire(arg, scope)\\n      tapAfterUp(arg, scope)\\n    },\\n    'interactions:cancel': (arg, scope) =&gt; {\\n      clearHold(arg)\\n      fire(arg, scope)\\n    },\\n  },\\n  PointerEvent,\\n  fire,\\n  collectEventTargets,\\n  defaults,\\n  types: {\\n    down: true,\\n    move: true,\\n    up: true,\\n    cancel: true,\\n    tap: true,\\n    doubletap: true,\\n    hold: true,\\n  } as { [type: string]: true },\\n}\\n\\nfunction fire&lt;T extends string&gt; (\\n  arg: {\\n    pointer: PointerType | PointerEvent&lt;any&gt;\\n    event: PointerEventType | PointerEvent&lt;any&gt;\\n    eventTarget: Node\\n    interaction: Interaction&lt;never&gt;\\n    type: T\\n    targets?: EventTargetList\\n  },\\n  scope: Scope,\\n) {\\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\\n\\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\\n\\n  scope.fire('pointerEvents:new', { pointerEvent })\\n\\n  const signalArg = {\\n    interaction,\\n    pointer,\\n    event,\\n    eventTarget,\\n    targets,\\n    type,\\n    pointerEvent,\\n  }\\n\\n  for (let i = 0; i &lt; targets.length; i++) {\\n    const target = targets[i]\\n\\n    for (const prop in target.props || {}) {\\n      ;(pointerEvent as any)[prop] = target.props[prop]\\n    }\\n\\n    const origin = getOriginXY(target.eventable, target.node)\\n\\n    pointerEvent._subtractOrigin(origin)\\n    pointerEvent.eventable = target.eventable\\n    pointerEvent.currentTarget = target.node\\n\\n    target.eventable.fire(pointerEvent)\\n\\n    pointerEvent._addOrigin(origin)\\n\\n    if (\\n      pointerEvent.immediatePropagationStopped ||\\n      (pointerEvent.propagationStopped &amp;&amp;\\n        i + 1 &lt; targets.length &amp;&amp;\\n        targets[i + 1].node !== pointerEvent.currentTarget)\\n    ) {\\n      break\\n    }\\n  }\\n\\n  scope.fire('pointerEvents:fired', signalArg)\\n\\n  if (type === 'tap') {\\n    // if pointerEvent should make a double tap, create and fire a doubletap\\n    // PointerEvent and use that as the prevTap\\n    const prevTap = pointerEvent.double\\n      ? fire(\\n        {\\n          interaction,\\n          pointer,\\n          event,\\n          eventTarget,\\n          type: 'doubletap',\\n        },\\n        scope,\\n      )\\n      : pointerEvent\\n\\n    interaction.prevTap = prevTap\\n    interaction.tapTime = prevTap.timeStamp\\n  }\\n\\n  return pointerEvent\\n}\\n\\nfunction collectEventTargets&lt;T extends string&gt; (\\n  {\\n    interaction,\\n    pointer,\\n    event,\\n    eventTarget,\\n    type,\\n  }: {\\n    interaction: Interaction&lt;any&gt;\\n    pointer: PointerType | PointerEvent&lt;any&gt;\\n    event: PointerEventType | PointerEvent&lt;any&gt;\\n    eventTarget: Node\\n    type: T\\n  },\\n  scope: Scope,\\n) {\\n  const pointerIndex = interaction.getPointerIndex(pointer)\\n  const pointerInfo = interaction.pointers[pointerIndex]\\n\\n  // do not fire a tap event if the pointer was moved before being lifted\\n  if (\\n    type === 'tap' &amp;&amp;\\n    (interaction.pointerWasMoved ||\\n      // or if the pointerup target is different to the pointerdown target\\n      !(pointerInfo &amp;&amp; pointerInfo.downTarget === eventTarget))\\n  ) {\\n    return []\\n  }\\n\\n  const path = domUtils.getPath(eventTarget as Element | Document)\\n  const signalArg = {\\n    interaction,\\n    pointer,\\n    event,\\n    eventTarget,\\n    type,\\n    path,\\n    targets: [] as EventTargetList,\\n    node: null,\\n  }\\n\\n  for (const node of path) {\\n    signalArg.node = node\\n\\n    scope.fire('pointerEvents:collect-targets', signalArg)\\n  }\\n\\n  if (type === 'hold') {\\n    signalArg.targets = signalArg.targets.filter(\\n      target =&gt; target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold.duration,\\n    )\\n  }\\n\\n  return signalArg.targets\\n}\\n\\nfunction addInteractionProps ({ interaction }) {\\n  interaction.prevTap = null // the most recent tap event on this interaction\\n  interaction.tapTime = 0 // time of the most recent tap event\\n}\\n\\nfunction addHoldInfo ({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\\n  if (!down &amp;&amp; pointerInfo.hold) {\\n    return\\n  }\\n\\n  pointerInfo.hold = { duration: Infinity, timeout: null }\\n}\\n\\nfunction clearHold ({ interaction, pointerIndex }) {\\n  const hold = interaction.pointers[pointerIndex].hold\\n\\n  if (hold &amp;&amp; hold.timeout) {\\n    clearTimeout(hold.timeout)\\n    hold.timeout = null\\n  }\\n}\\n\\nfunction moveAndClearHold (arg: SignalArgs['interactions:move'], scope: Scope) {\\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\\n\\n  if (!duplicate &amp;&amp; (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\\n    if (interaction.pointerIsDown) {\\n      clearHold(arg)\\n    }\\n\\n    fire(\\n      {\\n        interaction,\\n        pointer,\\n        event,\\n        eventTarget: eventTarget as Element,\\n        type: 'move',\\n      },\\n      scope,\\n    )\\n  }\\n}\\n\\nfunction downAndStartHold (\\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\\n  scope: Scope,\\n) {\\n  const timer = interaction.pointers[pointerIndex].hold\\n  const path = domUtils.getPath(eventTarget as Element | Document)\\n  const signalArg = {\\n    interaction,\\n    pointer,\\n    event,\\n    eventTarget,\\n    type: 'hold',\\n    targets: [] as EventTargetList,\\n    path,\\n    node: null,\\n  }\\n\\n  for (const node of path) {\\n    signalArg.node = node\\n\\n    scope.fire('pointerEvents:collect-targets', signalArg)\\n  }\\n\\n  if (!signalArg.targets.length) return\\n\\n  let minDuration = Infinity\\n\\n  for (const target of signalArg.targets) {\\n    const holdDuration = target.eventable.options.holdDuration\\n\\n    if (holdDuration &lt; minDuration) {\\n      minDuration = holdDuration\\n    }\\n  }\\n\\n  timer.duration = minDuration\\n  timer.timeout = setTimeout(() =&gt; {\\n    fire(\\n      {\\n        interaction,\\n        eventTarget,\\n        pointer,\\n        event,\\n        type: 'hold',\\n      },\\n      scope,\\n    )\\n  }, minDuration)\\n}\\n\\nfunction tapAfterUp (\\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\\n  scope: Scope,\\n) {\\n  if (!interaction.pointerWasMoved) {\\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  scope.pointerEvents = pointerEvents\\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\\n}\\n\\nexport default pointerEvents\\n\"</span>,<span class=\"code-string\">\"import type Interaction from '@interactjs/core/Interaction'\\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\\n\\nimport type PointerEvent from './PointerEvent'\\nimport basePlugin from './base'\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    holdIntervalHandle?: any\\n  }\\n}\\n\\ndeclare module '@interactjs/pointer-events/PointerEvent' {\\n  interface PointerEvent&lt;T extends string = any&gt; {\\n    count?: number\\n  }\\n}\\n\\ndeclare module '@interactjs/pointer-events/base' {\\n  interface PointerEventOptions {\\n    holdRepeatInterval?: number\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  scope.usePlugin(basePlugin)\\n\\n  const { pointerEvents } = scope\\n\\n  // don't repeat by default\\n  pointerEvents.defaults.holdRepeatInterval = 0\\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\\n}\\n\\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent&lt;any&gt; }) {\\n  if (pointerEvent.type !== 'hold') return\\n\\n  pointerEvent.count = (pointerEvent.count || 0) + 1\\n}\\n\\nfunction onFired (\\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\\n  scope: Scope,\\n) {\\n  if (pointerEvent.type !== 'hold' || !targets.length) return\\n\\n  // get the repeat interval from the first eventable\\n  const interval = targets[0].eventable.options.holdRepeatInterval\\n\\n  // don't repeat if the interval is 0 or less\\n  if (interval &lt;= 0) return\\n\\n  // set a timeout to fire the holdrepeat event\\n  interaction.holdIntervalHandle = setTimeout(() =&gt; {\\n    scope.pointerEvents.fire(\\n      {\\n        interaction,\\n        eventTarget,\\n        type: 'hold',\\n        pointer: pointerEvent,\\n        event: pointerEvent,\\n      },\\n      scope,\\n    )\\n  }, interval)\\n}\\n\\nfunction endHoldRepeat ({ interaction }: { interaction: Interaction }) {\\n  // set the interaction's holdStopTime property\\n  // to stop further holdRepeat events\\n  if (interaction.holdIntervalHandle) {\\n    clearInterval(interaction.holdIntervalHandle)\\n    interaction.holdIntervalHandle = null\\n  }\\n}\\n\\nconst holdRepeat: Plugin = {\\n  id: 'pointer-events/holdRepeat',\\n  install,\\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\\n    (acc, enderTypes) =&gt; {\\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\\n      return acc\\n    },\\n    {\\n      'pointerEvents:new': onNew,\\n      'pointerEvents:fired': onFired,\\n    } as ListenerMap,\\n  ),\\n}\\n\\nexport default holdRepeat\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { Scope, Plugin } from '@interactjs/core/scope'\\nimport type { Element } from '@interactjs/types/index'\\nimport extend from '@interactjs/utils/extend'\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    pointerEvents: typeof pointerEventsMethod\\n    __backCompatOption: (optionName: string, newValue: any) =&gt; any\\n  }\\n}\\n\\nfunction install (scope: Scope) {\\n  const { Interactable } = scope\\n\\n  Interactable.prototype.pointerEvents = pointerEventsMethod\\n\\n  const __backCompatOption = Interactable.prototype._backCompatOption\\n\\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\\n    const ret = __backCompatOption.call(this, optionName, newValue)\\n\\n    if (ret === this) {\\n      this.events.options[optionName] = newValue\\n    }\\n\\n    return ret\\n  }\\n}\\n\\nfunction pointerEventsMethod (this: Interactable, options: any) {\\n  extend(this.events.options, options)\\n\\n  return this\\n}\\n\\nconst plugin: Plugin = {\\n  id: 'pointer-events/interactableTargets',\\n  install,\\n  listeners: {\\n    'pointerEvents:collect-targets': ({ targets, node, type, eventTarget }, scope) =&gt; {\\n      scope.interactables.forEachMatch(node, (interactable: Interactable) =&gt; {\\n        const eventable = interactable.events\\n        const options = eventable.options\\n\\n        if (\\n          eventable.types[type] &amp;&amp;\\n          eventable.types[type].length &amp;&amp;\\n          interactable.testIgnoreAllow(options, node, eventTarget)\\n        ) {\\n          targets.push({\\n            node,\\n            eventable,\\n            props: { interactable },\\n          })\\n        }\\n      })\\n    },\\n\\n    'interactable:new': ({ interactable }) =&gt; {\\n      interactable.events.getRect = function (element: Element) {\\n        return interactable.getRect(element)\\n      }\\n    },\\n\\n    'interactable:set': ({ interactable, options }, scope) =&gt; {\\n      extend(interactable.events.options, scope.pointerEvents.defaults)\\n      extend(interactable.events.options, options.pointerEvents || {})\\n    },\\n  },\\n}\\n\\nexport default plugin\\n\"</span>,<span class=\"code-string\">\"import type { Plugin } from '@interactjs/core/scope'\\n\\nimport * as pointerEvents from './base'\\nimport holdRepeat from './holdRepeat'\\nimport interactableTargets from './interactableTargets'\\n\\nconst plugin: Plugin = {\\n  id: 'pointer-events',\\n  install (scope) {\\n    scope.usePlugin(pointerEvents)\\n    scope.usePlugin(holdRepeat)\\n    scope.usePlugin(interactableTargets)\\n  },\\n}\\n\\nexport default plugin\\n\"</span>,<span class=\"code-string\">\"import type { Interactable } from '@interactjs/core/Interactable'\\nimport type { ActionProps, DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\\nimport type { Element } from '@interactjs/types/index'\\nimport * as arr from '@interactjs/utils/arr'\\nimport is from '@interactjs/utils/is'\\nimport { copyAction } from '@interactjs/utils/misc'\\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\\nimport { tlbrToXywh } from '@interactjs/utils/rect'\\n\\ndeclare module '@interactjs/core/scope' {\\n  interface SignalArgs {\\n    'interactions:before-action-reflow': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\\n    'interactions:action-reflow': DoAnyPhaseArg\\n    'interactions:after-action-reflow': DoAnyPhaseArg\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interactable' {\\n  interface Interactable {\\n    reflow: &lt;T extends ActionName&gt;(action: ActionProps&lt;T&gt;) =&gt; ReturnType&lt;typeof doReflow&gt;\\n  }\\n}\\n\\ndeclare module '@interactjs/core/Interaction' {\\n  interface Interaction {\\n    _reflowPromise: Promise&lt;void&gt;\\n    _reflowResolve: (...args: unknown[]) =&gt; void\\n  }\\n}\\n\\ndeclare module '@interactjs/core/InteractEvent' {\\n  interface PhaseMap {\\n    reflow?: true\\n  }\\n}\\n\\nexport function install (scope: Scope) {\\n  const {\\n    /** @lends Interactable */\\n    Interactable,\\n  } = scope\\n\\n  scope.actions.phases.reflow = true\\n\\n  /**\\n   * ```js\\n   * const interactable = interact(target)\\n   * const drag = { name: drag, axis: 'x' }\\n   * const resize = { name: resize, edges: { left: true, bottom: true }\\n   *\\n   * interactable.reflow(drag)\\n   * interactable.reflow(resize)\\n   * ```\\n   *\\n   * Start an action sequence to re-apply modifiers, check drops, etc.\\n   *\\n   * @param { Object } action The action to begin\\n   * @param { string } action.name The name of the action\\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\\n   */\\n  Interactable.prototype.reflow = function (action: ActionProps) {\\n    return doReflow(this, action, scope)\\n  }\\n}\\n\\nfunction doReflow&lt;T extends ActionName&gt; (\\n  interactable: Interactable,\\n  action: ActionProps&lt;T&gt;,\\n  scope: Scope,\\n): Promise&lt;Interactable&gt; {\\n  const elements = (is.string(interactable.target)\\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\\n    : [interactable.target]) as Element[]\\n\\n  // tslint:disable-next-line variable-name\\n  const Promise = (scope.window as any).Promise\\n  const promises: Array&lt;Promise&lt;null&gt;&gt; | null = Promise ? [] : null\\n\\n  for (const element of elements) {\\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\\n\\n    if (!rect) {\\n      break\\n    }\\n\\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) =&gt; {\\n      return (\\n        interaction.interacting() &amp;&amp;\\n        interaction.interactable === interactable &amp;&amp;\\n        interaction.element === element &amp;&amp;\\n        interaction.prepared.name === action.name\\n      )\\n    })\\n    let reflowPromise: Promise&lt;null&gt;\\n\\n    if (runningInteraction) {\\n      runningInteraction.move()\\n\\n      if (promises) {\\n        reflowPromise =\\n          runningInteraction._reflowPromise ||\\n          new Promise((resolve: any) =&gt; {\\n            runningInteraction._reflowResolve = resolve\\n          })\\n      }\\n    } else {\\n      const xywh = tlbrToXywh(rect)\\n      const coords = {\\n        page: { x: xywh.x, y: xywh.y },\\n        client: { x: xywh.x, y: xywh.y },\\n        timeStamp: scope.now(),\\n      }\\n\\n      const event = pointerUtils.coordsToEvent(coords)\\n      reflowPromise = startReflow&lt;T&gt;(scope, interactable, element, action, event)\\n    }\\n\\n    if (promises) {\\n      promises.push(reflowPromise)\\n    }\\n  }\\n\\n  return promises &amp;&amp; Promise.all(promises).then(() =&gt; interactable)\\n}\\n\\nfunction startReflow&lt;T extends ActionName&gt; (\\n  scope: Scope,\\n  interactable: Interactable,\\n  element: Element,\\n  action: ActionProps&lt;T&gt;,\\n  event: any,\\n) {\\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\\n  const signalArg = {\\n    interaction,\\n    event,\\n    pointer: event,\\n    eventTarget: element,\\n    phase: 'reflow',\\n  } as const\\n\\n  interaction.interactable = interactable\\n  interaction.element = element\\n  interaction.prevEvent = event\\n  interaction.updatePointer(event, event, element, true)\\n  pointerUtils.setZeroCoords(interaction.coords.delta)\\n\\n  copyAction(interaction.prepared, action)\\n  interaction._doPhase(signalArg)\\n\\n  const { Promise } = (scope.window as unknown) as { Promise: PromiseConstructor }\\n  const reflowPromise = Promise\\n    ? new Promise&lt;undefined&gt;(resolve =&gt; {\\n      interaction._reflowResolve = resolve\\n    })\\n    : undefined\\n\\n  interaction._reflowPromise = reflowPromise\\n  interaction.start(action, interactable, element)\\n\\n  if (interaction._interacting) {\\n    interaction.move(signalArg)\\n    interaction.end(event)\\n  } else {\\n    interaction.stop()\\n    interaction._reflowResolve()\\n  }\\n\\n  interaction.removePointer(event, event)\\n\\n  return reflowPromise\\n}\\n\\nconst reflow: Plugin = {\\n  id: 'reflow',\\n  install,\\n  listeners: {\\n    // remove completed reflow interactions\\n    'interactions:stop': ({ interaction }, scope) =&gt; {\\n      if (interaction.pointerType === 'reflow') {\\n        if (interaction._reflowResolve) {\\n          interaction._reflowResolve()\\n        }\\n\\n        arr.remove(scope.interactions.list, interaction)\\n      }\\n    },\\n  },\\n}\\n\\nexport default reflow\\n\"</span>,<span class=\"code-string\">\"import actions from '@interactjs/actions/plugin'\\nimport arrange from '@interactjs/arrange/plugin'\\nimport autoScroll from '@interactjs/auto-scroll/plugin'\\nimport autoStart from '@interactjs/auto-start/plugin'\\nimport clone from '@interactjs/clone/plugin'\\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\\nimport devTools from '@interactjs/dev-tools/plugin'\\nimport feedback from '@interactjs/feedback/plugin'\\nimport inertia from '@interactjs/inertia/plugin'\\nimport interact from '@interactjs/interact'\\nimport modifiers from '@interactjs/modifiers/plugin'\\nimport multiTarget from '@interactjs/multi-target/plugin'\\nimport offset from '@interactjs/offset/plugin'\\nimport pointerEvents from '@interactjs/pointer-events/plugin'\\nimport reactComponents from '@interactjs/react/plugin'\\nimport reflow from '@interactjs/reflow/plugin'\\nimport vueComponents from '@interactjs/vue/plugin'\\n\\ninteract.use(multiTarget)\\n\\ninteract.use(interactablePreventDefault)\\n\\ninteract.use(offset)\\n\\n// interaction element cloning\\ninteract.use(clone)\\n\\n// sortable and swappable\\ninteract.use(arrange)\\n\\n// pointerEvents\\ninteract.use(pointerEvents)\\n\\n// inertia\\ninteract.use(inertia)\\n\\n// snap, resize, etc.\\ninteract.use(modifiers)\\n\\n// autoStart, hold\\ninteract.use(autoStart)\\n\\n// drag and drop, resize, gesture\\ninteract.use(actions)\\n\\n// autoScroll\\ninteract.use(autoScroll)\\n\\n// reflow\\ninteract.use(reflow)\\n\\ninteract.use(feedback)\\n\\ninteract.use(vueComponents)\\n\\ninteract.use(reactComponents)\\n\\n// eslint-disable-next-line no-undef\\nif (process.env.NODE_ENV !== 'production') {\\n  interact.use(devTools)\\n}\\n\\nexport default interact\\n\\nif (typeof module === 'object' &amp;&amp; !!module) {\\n  try {\\n    module.exports = interact\\n  } catch {}\\n}\\n\\n;(interact as any).default = interact\\n\"</span>,<span class=\"code-string\">\"// eslint-disable-next-line import/no-extraneous-dependencies\\nimport interact from '@interactjs/interactjs/index'\\n\\nexport default interact\\n\\nif (typeof module === 'object' &amp;&amp; !!module) {\\n  try {\\n    module.exports = interact\\n  } catch {}\\n}\\n\\n;(interact as any).default = interact\\n\"</span>,<span class=\"code-string\">\"\\nreturn _$index_84;\\n\\n});\\n\"</span>]}"]}}}</script></head><body><div id="root"><style data-emotion-css="gtfibm">html{box-sizing:border-box;}*,*:before,*:after{box-sizing:inherit;}html,body,#root{height:100%;margin:0;}body{font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;font-size:16px;line-height:1.5;overflow-wrap:break-word;background:white;color:black;}code{font-family:Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace;}th,td{padding:0;}select{font-size:inherit;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}</style><style data-emotion-css="1r6h1r6">.code-listing{background:#fbfdff;color:#383a42;}.code-comment,.code-quote{color:#a0a1a7;font-style:italic;}.code-doctag,.code-keyword,.code-link,.code-formula{color:#a626a4;}.code-section,.code-name,.code-selector-tag,.code-deletion,.code-subst{color:#e45649;}.code-literal{color:#0184bb;}.code-string,.code-regexp,.code-addition,.code-attribute,.code-meta-string{color:#50a14f;}.code-built_in,.code-class .code-title{color:#c18401;}.code-attr,.code-variable,.code-template-variable,.code-type,.code-selector-class,.code-selector-attr,.code-selector-pseudo,.code-number{color:#986801;}.code-symbol,.code-bullet,.code-meta,.code-selector-id,.code-title{color:#4078f2;}.code-emphasis{font-style:italic;}.code-strong{font-weight:bold;}</style><style data-emotion-css="1c3h18e">.css-1c3h18e{-webkit-flex:1 0 auto;-ms-flex:1 0 auto;flex:1 0 auto;}</style><div class="css-1c3h18e"><style data-emotion-css="1cfuj1t">.css-1cfuj1t{max-width:940px;padding:0 20px;margin:0 auto;}</style><div class="css-1cfuj1t"><style data-emotion-css="i51og3">.css-i51og3{margin-top:2rem;}</style><header class="css-i51og3"><style data-emotion-css="1y7u1xh">.css-1y7u1xh{text-align:center;font-size:3rem;-webkit-letter-spacing:0.05em;-moz-letter-spacing:0.05em;-ms-letter-spacing:0.05em;letter-spacing:0.05em;}</style><h1 class="css-1y7u1xh"><style data-emotion-css="1ydg16i">.css-1ydg16i{color:#000;-webkit-text-decoration:none;text-decoration:none;}</style><a href="/" class="css-1ydg16i">UNPKG</a></h1></header></div><div class="css-1cfuj1t"><style data-emotion-css="93o42g">.css-93o42g{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}@media (max-width:700px){.css-93o42g{-webkit-flex-direction:column-reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}}</style><header class="css-93o42g"><style data-emotion-css="1dlpvgi">.css-1dlpvgi{font-size:1.5rem;font-weight:normal;-webkit-flex:1;-ms-flex:1;flex:1;word-break:break-all;}</style><h1 class="css-1dlpvgi"><nav><style data-emotion-css="xt128v">.css-xt128v{color:#0076ff;-webkit-text-decoration:none;text-decoration:none;}.css-xt128v:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><a href="/browse/interactjs@1.10.3/" class="css-xt128v">interactjs</a><style data-emotion-css="lllnmq">.css-lllnmq{padding-left:5px;padding-right:5px;}</style><span class="css-lllnmq">/</span><a href="/browse/interactjs@1.10.3/dist/" class="css-xt128v">dist</a><span class="css-lllnmq">/</span><strong>interact.min.js.map</strong></nav></h1><style data-emotion-css="1nr3dab">.css-1nr3dab{margin-left:20px;}@media (max-width:700px){.css-1nr3dab{margin-left:0;margin-bottom:0;}}</style><p class="css-1nr3dab"><label>Version:<!-- --> <style data-emotion-css="un3bt6">.css-un3bt6{-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;padding:4px 24px 4px 8px;font-weight:600;font-size:0.9em;color:#24292e;border:1px solid rgba(27,31,35,.2);border-radius:3px;background-color:#eff3f6;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAKCAYAAAC9vt6cAAAAAXNSR0IArs4c6QAAARFJREFUKBVjZAACNS39RhBNKrh17WI9o4quoT3Dn78HSNUMUs/CzOTI/O7Vi4dCYpJ3/jP+92BkYGAlyiBGhm8MjIxJt65e3MQM0vDu9YvLYmISILYZELOBxHABRkaGr0yMzF23r12YDFIDNgDEePv65SEhEXENBkYGFSAXuyGMjF8Z/jOsvX3tYiFIDwgwQSgIaaijnvj/P8M5IO8HsjiY/f//D4b//88A1SQhywG9jQr09PS4v/1mPAeUUPzP8B8cJowMjL+Bqu6xMQmaXL164AuyDgwDQJLa2qYSP//9vARkCoMVMzK8YeVkNbh+9uxzMB+JwGoASF5Vx0jz/98/18BqmZi171w9D2EjaaYKEwAEK00XQLdJuwAAAABJRU5ErkJggg==);background-position:right 8px center;background-repeat:no-repeat;background-size:auto 25%;}.css-un3bt6:hover{background-color:#e6ebf1;border-color:rgba(27,31,35,.35);}.css-un3bt6:active{background-color:#e9ecef;border-color:rgba(27,31,35,.35);box-shadow:inset 0 0.15em 0.3em rgba(27,31,35,.15);}</style><select name="version" class="css-un3bt6"><option value="1.2.7">1.2.7</option><option value="1.2.8">1.2.8</option><option value="1.2.9">1.2.9</option><option value="1.3.0-alpha.0">1.3.0-alpha.0</option><option value="1.3.0-alpha.1">1.3.0-alpha.1</option><option value="1.3.0-alpha.2">1.3.0-alpha.2</option><option value="1.3.0-alpha.3">1.3.0-alpha.3</option><option value="1.3.0-alpha.5">1.3.0-alpha.5</option><option value="1.3.0-alpha.6">1.3.0-alpha.6</option><option value="1.3.0-alpha.7">1.3.0-alpha.7</option><option value="1.3.0-rc.0">1.3.0-rc.0</option><option value="1.3.0-rc.1">1.3.0-rc.1</option><option value="1.3.0-rc.2">1.3.0-rc.2</option><option value="1.3.0-rc.3">1.3.0-rc.3</option><option value="1.3.0-rc.4">1.3.0-rc.4</option><option value="1.3.0">1.3.0</option><option value="1.3.1">1.3.1</option><option value="1.3.2">1.3.2</option><option value="1.3.3">1.3.3</option><option value="1.3.4">1.3.4</option><option value="1.4.0-alpha.0">1.4.0-alpha.0</option><option value="1.4.0-alpha.1">1.4.0-alpha.1</option><option value="1.4.0-alpha.2">1.4.0-alpha.2</option><option value="1.4.0-alpha.3">1.4.0-alpha.3</option><option value="1.4.0-alpha.4">1.4.0-alpha.4</option><option value="1.4.0-alpha.5">1.4.0-alpha.5</option><option value="1.4.0-alpha.6">1.4.0-alpha.6</option><option value="1.4.0-alpha.7">1.4.0-alpha.7</option><option value="1.4.0-alpha.8">1.4.0-alpha.8</option><option value="1.4.0-alpha.9">1.4.0-alpha.9</option><option value="1.4.0-alpha.10">1.4.0-alpha.10</option><option value="1.4.0-alpha.12">1.4.0-alpha.12</option><option value="1.4.0-alpha.13">1.4.0-alpha.13</option><option value="1.4.0-alpha.14">1.4.0-alpha.14</option><option value="1.4.0-alpha.15">1.4.0-alpha.15</option><option value="1.4.0-alpha.16">1.4.0-alpha.16</option><option value="1.4.0-alpha.17">1.4.0-alpha.17</option><option value="1.4.0-alpha.18">1.4.0-alpha.18</option><option value="1.4.0-alpha.19">1.4.0-alpha.19</option><option value="1.4.0-alpha.20">1.4.0-alpha.20</option><option value="1.4.0-alpha.21">1.4.0-alpha.21</option><option value="1.4.0-alpha.22">1.4.0-alpha.22</option><option value="1.4.0-alpha.23">1.4.0-alpha.23</option><option value="1.4.0-alpha.24">1.4.0-alpha.24</option><option value="1.4.0-alpha.25">1.4.0-alpha.25</option><option value="1.4.0-alpha.26">1.4.0-alpha.26</option><option value="1.4.0-alpha.27">1.4.0-alpha.27</option><option value="1.4.0-alpha.28">1.4.0-alpha.28</option><option value="1.4.0-alpha.29">1.4.0-alpha.29</option><option value="1.4.0-alpha.30">1.4.0-alpha.30</option><option value="1.4.0-alpha.31">1.4.0-alpha.31</option><option value="1.4.0-alpha.32">1.4.0-alpha.32</option><option value="1.4.0-alpha.33">1.4.0-alpha.33</option><option value="1.4.0-beta.0">1.4.0-beta.0</option><option value="1.4.0-beta.1">1.4.0-beta.1</option><option value="1.4.0-beta.2">1.4.0-beta.2</option><option value="1.4.0-beta.3">1.4.0-beta.3</option><option value="1.4.0-beta.4">1.4.0-beta.4</option><option value="1.4.0-rc.0">1.4.0-rc.0</option><option value="1.4.0-rc.1">1.4.0-rc.1</option><option value="1.4.0-rc.2">1.4.0-rc.2</option><option value="1.4.0-rc.3">1.4.0-rc.3</option><option value="1.4.0-rc.4">1.4.0-rc.4</option><option value="1.4.0-rc.5">1.4.0-rc.5</option><option value="1.4.0-rc.6">1.4.0-rc.6</option><option value="1.4.0-rc.7">1.4.0-rc.7</option><option value="1.4.0-rc.8">1.4.0-rc.8</option><option value="1.4.0-rc.9">1.4.0-rc.9</option><option value="1.4.0-rc.10">1.4.0-rc.10</option><option value="1.4.0-rc.11">1.4.0-rc.11</option><option value="1.4.0-rc.12">1.4.0-rc.12</option><option value="1.4.0-rc.13">1.4.0-rc.13</option><option value="1.4.0">1.4.0</option><option value="1.4.1">1.4.1</option><option value="1.4.2">1.4.2</option><option value="1.4.3">1.4.3</option><option value="1.4.4">1.4.4</option><option value="1.4.5">1.4.5</option><option value="1.4.6">1.4.6</option><option value="1.4.7">1.4.7</option><option value="1.4.8">1.4.8</option><option value="1.4.9">1.4.9</option><option value="1.4.10">1.4.10</option><option value="1.4.11">1.4.11</option><option value="1.4.12">1.4.12</option><option value="1.4.13">1.4.13</option><option value="1.4.14">1.4.14</option><option value="1.5.0">1.5.0</option><option value="1.5.1">1.5.1</option><option value="1.5.2">1.5.2</option><option value="1.5.3">1.5.3</option><option value="1.5.4">1.5.4</option><option value="1.6.0">1.6.0</option><option value="1.6.1-0">1.6.1-0</option><option value="1.6.1">1.6.1</option><option value="1.6.2">1.6.2</option><option value="1.6.3">1.6.3</option><option value="1.7.0">1.7.0</option><option value="1.7.1">1.7.1</option><option value="1.7.2">1.7.2</option><option value="1.7.3">1.7.3</option><option value="1.8.0-alpha.0">1.8.0-alpha.0</option><option value="1.8.0-alpha.1">1.8.0-alpha.1</option><option value="1.8.0-alpha.2">1.8.0-alpha.2</option><option value="1.8.0-alpha.3">1.8.0-alpha.3</option><option value="1.8.0-alpha.4">1.8.0-alpha.4</option><option value="1.8.0-alpha.5">1.8.0-alpha.5</option><option value="1.8.0-alpha.6">1.8.0-alpha.6</option><option value="1.8.0-alpha.7">1.8.0-alpha.7</option><option value="1.8.0-rc.0">1.8.0-rc.0</option><option value="1.8.0-rc.1">1.8.0-rc.1</option><option value="1.8.0-rc.2">1.8.0-rc.2</option><option value="1.8.0-rc.3">1.8.0-rc.3</option><option value="1.8.0">1.8.0</option><option value="1.8.1">1.8.1</option><option value="1.8.2">1.8.2</option><option value="1.8.3">1.8.3</option><option value="1.8.4">1.8.4</option><option value="1.8.5">1.8.5</option><option value="1.9.0">1.9.0</option><option value="1.9.1">1.9.1</option><option value="1.9.2">1.9.2</option><option value="1.9.3">1.9.3</option><option value="1.9.4">1.9.4</option><option value="1.9.5">1.9.5</option><option value="1.9.6">1.9.6</option><option value="1.9.7">1.9.7</option><option value="1.9.8">1.9.8</option><option value="1.9.9">1.9.9</option><option value="1.9.10">1.9.10</option><option value="1.9.11">1.9.11</option><option value="1.9.12">1.9.12</option><option value="1.9.13">1.9.13</option><option value="1.9.14">1.9.14</option><option value="1.9.15">1.9.15</option><option value="1.9.16">1.9.16</option><option value="1.9.17">1.9.17</option><option value="1.9.18">1.9.18</option><option value="1.9.19">1.9.19</option><option value="1.9.20">1.9.20</option><option value="1.9.21">1.9.21</option><option value="1.9.22">1.9.22</option><option value="1.10.0">1.10.0</option><option value="1.10.1">1.10.1</option><option value="1.10.2">1.10.2</option><option selected="" value="1.10.3">1.10.3</option></select></label></p></header></div><style data-emotion-css="107j3ms">.css-107j3ms{max-width:940px;padding:0 20px;margin:0 auto;}@media (max-width:700px){.css-107j3ms{padding:0;margin:0;}}</style><div class="css-107j3ms"><style data-emotion-css="q3frg4">.css-q3frg4{border:1px solid #dfe2e5;border-radius:3px;}@media (max-width:700px){.css-q3frg4{border-right-width:0;border-left-width:0;}}</style><div class="css-q3frg4"><style data-emotion-css="10o5omr">.css-10o5omr{padding:10px;background:#f6f8fa;color:#424242;border:1px solid #d1d5da;border-top-left-radius:3px;border-top-right-radius:3px;margin:-1px -1px 0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}@media (max-width:700px){.css-10o5omr{padding-right:20px;padding-left:20px;}}</style><div class="css-10o5omr"><span>394 kB</span><span>Source Map (JSON)</span><span><style data-emotion-css="18x593j">.css-18x593j{display:inline-block;margin-left:8px;padding:2px 8px;-webkit-text-decoration:none;text-decoration:none;font-weight:600;font-size:0.9rem;color:#24292e;background-color:#eff3f6;border:1px solid rgba(27,31,35,.2);border-radius:3px;}.css-18x593j:hover{background-color:#e6ebf1;border-color:rgba(27,31,35,.35);}.css-18x593j:active{background-color:#e9ecef;border-color:rgba(27,31,35,.35);box-shadow:inset 0 0.15em 0.3em rgba(27,31,35,.15);}</style><a href="/interactjs@1.10.3/dist/interact.min.js.map" class="css-18x593j">View Raw</a></span></div><style data-emotion-css="1i31ihw">.css-1i31ihw{overflow-x:auto;overflow-y:hidden;padding-top:5px;padding-bottom:5px;}</style><div class="code-listing css-1i31ihw"><style data-emotion-css="173nir8">.css-173nir8{border:none;border-collapse:collapse;border-spacing:0;}</style><table class="css-173nir8"><tbody><tr><style data-emotion-css="a4x74f">.css-a4x74f{padding-left:10px;padding-right:10px;color:rgba(27,31,35,.3);text-align:right;vertical-align:top;width:1%;min-width:50px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}</style><td id="L1" class="css-a4x74f"><span>1</span></td><style data-emotion-css="1dcdqdg">.css-1dcdqdg{padding-left:10px;padding-right:10px;color:#24292e;white-space:pre;}</style><td id="LC1" class="css-1dcdqdg"><code>{<span class="code-attr">"version"</span>:<span class="code-number">3</span>,<span class="code-attr">"sources"</span>:[<span class="code-string">"_header.js"</span>,<span class="code-string">"node_modules/browser-pack-flat/_prelude"</span>,<span class="code-string">"packages/@interactjs/utils/isWindow.ts"</span>,<span class="code-string">"packages/@interactjs/utils/window.ts"</span>,<span class="code-string">"packages/@interactjs/utils/is.ts"</span>,<span class="code-string">"packages/@interactjs/actions/drag/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/utils/domObjects.ts"</span>,<span class="code-string">"packages/@interactjs/utils/browser.ts"</span>,<span class="code-string">"packages/@interactjs/utils/domUtils.ts"</span>,<span class="code-string">"packages/@interactjs/utils/extend.ts"</span>,<span class="code-string">"packages/@interactjs/utils/rect.ts"</span>,<span class="code-string">"packages/@interactjs/utils/getOriginXY.ts"</span>,<span class="code-string">"packages/@interactjs/utils/normalizeListeners.ts"</span>,<span class="code-string">"packages/@interactjs/utils/hypot.ts"</span>,<span class="code-string">"packages/@interactjs/utils/pointerExtend.ts"</span>,<span class="code-string">"packages/@interactjs/utils/pointerUtils.ts"</span>,<span class="code-string">"packages/@interactjs/core/BaseEvent.ts"</span>,<span class="code-string">"packages/@interactjs/utils/arr.ts"</span>,<span class="code-string">"packages/@interactjs/actions/drop/DropEvent.ts"</span>,<span class="code-string">"packages/@interactjs/actions/drop/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/actions/gesture/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/actions/resize/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/actions/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/arrange/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/utils/raf.ts"</span>,<span class="code-string">"packages/@interactjs/auto-scroll/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/utils/misc.ts"</span>,<span class="code-string">"packages/@interactjs/auto-start/InteractableMethods.ts"</span>,<span class="code-string">"packages/@interactjs/auto-start/base.ts"</span>,<span class="code-string">"packages/@interactjs/auto-start/dragAxis.ts"</span>,<span class="code-string">"packages/@interactjs/auto-start/hold.ts"</span>,<span class="code-string">"packages/@interactjs/auto-start/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/clone/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/core/interactablePreventDefault.ts"</span>,<span class="code-string">"packages/@interactjs/dev-tools/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/utils/clone.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/Modification.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/base.ts"</span>,<span class="code-string">"packages/@interactjs/core/defaultOptions.ts"</span>,<span class="code-string">"packages/@interactjs/core/InteractEvent.ts"</span>,<span class="code-string">"packages/@interactjs/core/PointerInfo.ts"</span>,<span class="code-string">"packages/@interactjs/core/Interaction.ts"</span>,<span class="code-string">"packages/@interactjs/offset/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/inertia/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/core/Eventable.ts"</span>,<span class="code-string">"packages/@interactjs/core/isNonNativeEvent.ts"</span>,<span class="code-string">"packages/@interactjs/core/Interactable.ts"</span>,<span class="code-string">"packages/@interactjs/core/InteractableSet.ts"</span>,<span class="code-string">"packages/@interactjs/core/events.ts"</span>,<span class="code-string">"packages/@interactjs/core/interactStatic.ts"</span>,<span class="code-string">"packages/@interactjs/core/interactionFinder.ts"</span>,<span class="code-string">"packages/@interactjs/core/interactions.ts"</span>,<span class="code-string">"packages/@interactjs/core/scope.ts"</span>,<span class="code-string">"packages/@interactjs/interact/index.ts"</span>,<span class="code-string">"packages/@interactjs/snappers/edgeTarget.ts"</span>,<span class="code-string">"packages/@interactjs/snappers/elements.ts"</span>,<span class="code-string">"packages/@interactjs/snappers/grid.ts"</span>,<span class="code-string">"packages/@interactjs/snappers/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/aspectRatio.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/noop.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/restrict/pointer.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/restrict/edges.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/restrict/rect.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/restrict/size.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/snap/pointer.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/snap/size.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/snap/edges.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/all.ts"</span>,<span class="code-string">"packages/@interactjs/modifiers/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/pointer-events/PointerEvent.ts"</span>,<span class="code-string">"packages/@interactjs/pointer-events/base.ts"</span>,<span class="code-string">"packages/@interactjs/pointer-events/holdRepeat.ts"</span>,<span class="code-string">"packages/@interactjs/pointer-events/interactableTargets.ts"</span>,<span class="code-string">"packages/@interactjs/pointer-events/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/reflow/plugin.ts"</span>,<span class="code-string">"packages/@interactjs/interactjs/index.ts"</span>,<span class="code-string">"packages/interactjs/index.ts"</span>,<span class="code-string">"node_modules/browser-pack-flat/_postlude"</span>],<span class="code-attr">"names"</span>:[],<span class="code-attr">"mappings"</span>:<span class="code-string">"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"</span>,<span class="code-attr">"file"</span>:<span class="code-string">"interact.min.js"</span>,<span class="code-attr">"sourceRoot"</span>:<span class="code-string">""</span>,<span class="code-attr">"sourcesContent"</span>:[<span class="code-string">"/* interact.js 1.10.3 | https://raw.github.com/taye/interact.js/master/LICENSE */\n"</span>,<span class="code-string">"(function(f){if(typeof exports===\"object\"&amp;&amp;typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;\n"</span>,<span class="code-string">"export default (thing: any) =&gt; !!(thing &amp;&amp; thing.Window) &amp;&amp; thing instanceof thing.Window\n"</span>,<span class="code-string">"import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window &amp; { wrap?: (...args: any[]) =&gt; any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document &amp;&amp; typeof window.wrap === 'function' &amp;&amp; window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' &amp;&amp; !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n"</span>,<span class="code-string">"import type { Element } from '@interactjs/types/index'\n\nimport isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window =&gt; thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment =&gt; object(thing) &amp;&amp; thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } =&gt; !!thing &amp;&amp; typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) =&gt; any =&gt; typeof thing === 'function'\n\nconst number = (thing: any): thing is number =&gt; typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean =&gt; typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string =&gt; typeof thing === 'string'\n\nconst element = (thing: any): thing is Element =&gt; {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  // eslint-disable-next-line import/no-named-as-default-member\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 &amp;&amp; typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =&gt;\n  object(thing) &amp;&amp; !!thing.constructor &amp;&amp; /function Object\\b/.test(thing.constructor.toString())\n\nconst array = &lt;T extends unknown&gt;(thing: any): thing is T[] =&gt;\n  object(thing) &amp;&amp; typeof thing.length !== 'undefined' &amp;&amp; func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n"</span>,<span class="code-string">"import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, DraggableOptions, DropzoneOptions } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent&lt;'drag'&gt;\n\nexport type DraggableMethod = ActionMethod&lt;DraggableOptions&gt;\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y = 0\n  } else if (axis === 'y') {\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (\n  this: Interactable,\n  options?: DraggableOptions | boolean,\n): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': arg =&gt; {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions &amp;&amp; dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &amp;&amp;\n          /mouse|pointer/.test(interaction.pointerType) &amp;&amp;\n          (buttons &amp; interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis: 'xy',\n    lockAxis: 'xy',\n  } as DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n"</span>,<span class="code-string">"const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n"</span>,<span class="code-string">"import domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator = win.window.navigator\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) &amp;&amp; domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false &amp;&amp; !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) &amp;&amp; /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' &amp;&amp; browser.supportsTouch &amp;&amp; /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector') as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n"</span>,<span class="code-string">"import type { Rect, Target, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) &amp;&amp; is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) =&gt; el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf&lt;globalThis.Element&gt;) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i &lt; elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &amp;&amp;\n      currentNode instanceof domObjects.SVGElement &amp;&amp;\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &amp;&amp;\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    let child = parents[0].lastChild\n\n    while (child) {\n      if (child === parents[1]) {\n        deepestNodeIndex = i\n        deepestNodeParents = currentNodeParents\n\n        break\n      } else if (child === parents[2]) {\n        break\n      }\n\n      child = child.previousSibling\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) &amp;&amp; parent !== limit &amp;&amp; parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex &gt;= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required&lt;Rect&gt; {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect &amp;&amp; {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 &amp;&amp; clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n"</span>,<span class="code-string">"export default function extend&lt;T, U extends object&gt; (dest: U &amp; Partial&lt;T&gt;, source: T): T &amp; U {\n  for (const prop in source) {\n    ;((dest as unknown) as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T &amp; U\n\n  return ret\n}\n"</span>,<span class="code-string">"import type { HasGetRect, RectResolvable, Rect, Element, Point, FullRect, EdgeOptions } from '../types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike&lt;T extends any[]&gt; (\n  value: RectResolvable&lt;T&gt;,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect &amp;&amp; {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr&lt;T extends Partial&lt;Rect &amp; Point&gt;&gt; (rect: T) {\n  if (rect &amp;&amp; !('left' in rect &amp;&amp; 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect &amp; T\n}\n\nexport function tlbrToXywh (rect: Rect &amp; Partial&lt;Point&gt;) {\n  if (rect &amp;&amp; !('x' in rect &amp;&amp; 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect &amp; Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n"</span>,<span class="code-string">"import type { PerActionDefaults } from '@interactjs/core/defaultOptions'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { HasGetRect } from '@interactjs/types/index'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect &amp; { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions &amp;&amp; actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target &amp;&amp; element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n"</span>,<span class="code-string">"import type { EventTypes, Listener, ListenersArg } from '@interactjs/types/index'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce&lt;NormalizedListeners&gt;((acc, t) =&gt; extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -&gt; ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map(p =&gt; `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n"</span>,<span class="code-string">"export default (x: number, y: number) =&gt; Math.sqrt(x * x + y * y)\n"</span>,<span class="code-string">"function pointerExtend&lt;T&gt; (dest: Partial&lt;T&gt;, source: T) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 &amp;&amp; prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated &amp;&amp; typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  moz: /(Pressure)$/,\n} as { [prefix: string]: RegExp }\n\nexport default pointerExtend\n"</span>,<span class="code-string">"import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/types/index'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as keyof PointerType]\n  xy.y = pointer[(type + 'Y') as keyof PointerType]\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile &amp;&amp; isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile &amp;&amp; isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length &gt; 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : ((event as unknown) as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event &amp; PointerType &amp; PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nexport class BaseEvent&lt;T extends ActionName | null = never&gt; {\n  type: string\n  target: EventTarget\n  currentTarget: Node\n  interactable: Interactable\n  _interaction: Interaction&lt;T&gt;\n  timeStamp: any\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction&lt;T&gt;) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent&lt;T extends ActionName&gt; {\n  interaction: InteractionProxy&lt;T&gt;\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n"</span>,<span class="code-string">"type Filter&lt;T&gt; = (element: T, index: number, array: T[]) =&gt; boolean\n\nexport const contains = &lt;T&gt;(array: T[], target: T) =&gt; array.indexOf(target) !== -1\n\nexport const remove = &lt;T&gt;(array: T[], target: T) =&gt; array.splice(array.indexOf(target), 1)\n\nexport const merge = &lt;T, U&gt;(target: Array&lt;T | U&gt;, source: U[]) =&gt; {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = &lt;T = any&gt;(source: ArrayLike&lt;T&gt;) =&gt; merge([] as T[], source as T[])\n\nexport const findIndex = &lt;T&gt;(array: T[], func: Filter&lt;T&gt;) =&gt; {\n  for (let i = 0; i &lt; array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = &lt;T = any&gt;(array: T[], func: Filter&lt;T&gt;) =&gt; array[findIndex(array, func)]\n"</span>,<span class="code-string">"import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\n\nimport type { DropState } from './plugin'\n\nexport class DropEvent extends BaseEvent&lt;'drag'&gt; {\n  target: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent&lt;'drag'&gt;\n  relatedTarget: Element\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: DropState, dragEvent: InteractEvent&lt;'drag'&gt;, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\n\n    this.type = type\n    this.target = element\n    this.currentTarget = element\n    this.dropzone = dropzone\n    this.dragEvent = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable = dragEvent.interactable\n    this.timeStamp = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      this.type !== 'dropactivate' &amp;&amp;\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\n    ) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(\n        activeDrops,\n        ({ dropzone, element }) =&gt; dropzone === this.dropzone &amp;&amp; element === this.target,\n      )\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    } else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n"</span>,<span class="code-string">"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { DropzoneOptions, Element, PointerEventType, Rect } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ) =&gt; boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) =&gt; boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction&lt;'drag'&gt;\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interactable, options?: DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped &amp;&amp; event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging &amp;&amp; scope.dynamicDrop !== newValue &amp;&amp; !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) &amp;&amp; accept !== draggableElement) ||\n      (is.string(accept) &amp;&amp; !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) &amp;&amp; !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = (is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : is.array(dropzone.target)\n        ? dropzone.target\n        : [dropzone.target]) as Element[]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop (\n  { dropState, interactable: draggable, element: dragElement }: Partial&lt;Interaction&gt;,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n        ? dropzoneElement\n        : null,\n    )\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' &amp;&amp; dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' &amp;&amp; dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial&lt;\nRecord&lt;'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent&gt;\n&gt;\n\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\n  const { dropState } = interaction\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg&lt;'drag', EventPhase&gt;, scope: Scope) {\n  if (iEvent.type !== 'dragmove' &amp;&amp; iEvent.type !== 'dragend') {\n    return\n  }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &amp;&amp;\n    !!dropResult &amp;&amp;\n    dropResult.dropzone === dropState.cur.dropzone &amp;&amp;\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult &amp;&amp; dropResult.dropzone\n  dropState.cur.element = dropResult &amp;&amp; dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) =&gt; {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n        dragEvent,\n        event,\n        dropped,\n        interactable,\n        dropElement,\n        draggable,\n        draggableElement,\n      )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x &gt; rect.left &amp;&amp; page.x &lt; rect.right\n    const vertical = page.y &gt; rect.top &amp;&amp; page.y &lt; rect.bottom\n\n    dropped = horizontal &amp;&amp; vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect &amp;&amp; dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx &gt;= rect.left &amp;&amp; cx &lt;= rect.right &amp;&amp; cy &gt;= rect.top &amp;&amp; cy &lt;= rect.bottom\n  }\n\n  if (dragRect &amp;&amp; is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio &gt;= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) =&gt; {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg&lt;'drag', EventPhase&gt;,\n      scope,\n    ) =&gt; {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg&lt;'drag', EventPhase&gt;,\n      scope,\n    ) =&gt; {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg&lt;'drag', EventPhase&gt;, scope) =&gt; {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) =&gt; {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n"</span>,<span class="code-string">"import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Options } from '@interactjs/core/defaultOptions'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, GesturableOptions, Rect, PointerType } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod&lt;GesturableOptions&gt;\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends InteractEvent&lt;'gesture'&gt; {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg&lt;'gesture', EventPhase&gt; {\n  iEvent: GestureEvent\n  interaction: Interaction&lt;'gesture'&gt;\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType&lt;typeof Interactable&gt;,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map(p =&gt; p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) &amp;&amp; iEvent.scale !== Infinity &amp;&amp; !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': arg =&gt; {\n      if (arg.interaction.pointers.length &lt; 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions &amp;&amp; gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n"</span>,<span class="code-string">"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type {\n  ActionMethod,\n  ResizableOptions,\n  FullRect,\n  OrBoolean,\n  Point,\n  Rect,\n} from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod&lt;ResizableOptions&gt;\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent&lt;P extends EventPhase = EventPhase&gt; extends InteractEvent&lt;'resize', P&gt; {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) {\n    return undefined\n  }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions &amp;&amp; resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &amp;&amp;\n      /mouse|pointer/.test(interaction.pointerType) &amp;&amp;\n      (buttons &amp; resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(\n        edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin,\n      )\n    }\n\n    resizeEdges.left = resizeEdges.left &amp;&amp; !resizeEdges.right\n    resizeEdges.top = resizeEdges.top &amp;&amp; !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  } else {\n    const right = resizeOptions.axis !== 'y' &amp;&amp; page.x &gt; rect.right - resize.defaultMargin\n    const bottom = resizeOptions.axis !== 'x' &amp;&amp; page.y &gt; rect.bottom - resize.defaultMargin\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean&lt;ResizableOptions&gt; | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) &amp;&amp; /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    } else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    } else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) {\n    return false\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width &lt; 0) {\n      if (name === 'left') {\n        name = 'right'\n      } else if (name === 'right') {\n        name = 'left'\n      }\n    }\n    if (height &lt; 0) {\n      if (name === 'top') {\n        name = 'bottom'\n      } else if (name === 'bottom') {\n        name = 'top'\n      }\n    }\n\n    if (name === 'left') {\n      return page.x &lt; (width &gt;= 0 ? rect.left : rect.right) + margin\n    }\n    if (name === 'top') {\n      return page.y &lt; (height &gt;= 0 ? rect.top : rect.bottom) + margin\n    }\n\n    if (name === 'right') {\n      return page.x &gt; (width &gt;= 0 ? rect.right : rect.left) - margin\n    }\n    if (name === 'bottom') {\n      return page.y &gt; (height &gt;= 0 ? rect.bottom : rect.top) - margin\n    }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) {\n    return false\n  }\n\n  return is.element(value)\n    ? // the value is an element to use as a resize handle\n    value === element\n    : // otherwise check if element matches value as selector\n    dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return browser.isIe9\n    ? {\n      x: 'e-resize',\n      y: 's-resize',\n      xy: 'se-resize',\n\n      top: 'n-resize',\n      left: 'w-resize',\n      bottom: 's-resize',\n      right: 'e-resize',\n      topleft: 'se-resize',\n      bottomright: 'se-resize',\n      topright: 'ne-resize',\n      bottomleft: 'ne-resize',\n    }\n    : {\n      x: 'ew-resize',\n      y: 'ns-resize',\n      xy: 'nwse-resize',\n\n      top: 'ns-resize',\n      left: 'ew-resize',\n      bottom: 'ns-resize',\n      right: 'ew-resize',\n      topleft: 'nwse-resize',\n      bottomright: 'nwse-resize',\n      topright: 'nesw-resize',\n      bottomleft: 'nesw-resize',\n    }\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right: 0,\n      width: 0,\n      top: 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top &gt; corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left &gt; corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left = Math.min(current.left, startRect.right)\n    corrected.right = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width = corrected.right - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent&lt;any, any&gt;, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent&lt;any, any&gt;\n  interaction: Interaction\n}) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    } else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  } else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    } else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': arg =&gt; {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': arg =&gt; {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType&lt;typeof initCursors&gt;,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    } else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n"</span>,<span class="code-string">"import type { Scope } from '@interactjs/core/scope'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n"</span>,<span class="code-string">"export type ArrangeEvent = {}\nexport type ArrangeMode = {}\n\nexport default {}\n"</span>,<span class="code-string">"let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (window: Window) {\n  request = window.requestAnimationFrame\n  cancel = window.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = window[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        window[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        window[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request &amp;&amp; request.bind(window)\n  cancel = cancel &amp;&amp; cancel.bind(window)\n\n  if (!request) {\n    request = callback =&gt; {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = window.setTimeout(() =&gt; {\n        // eslint-disable-next-line node/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token\n    }\n\n    cancel = token =&gt; clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) =&gt; request(callback),\n  cancel: (token: number) =&gt; cancel(token),\n  init,\n}\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () =&gt; scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s &gt;= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove&lt;T extends ActionName&gt; ({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction&lt;T&gt;\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() &amp;&amp; autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX &lt; autoScroll.margin\n      top = pointer.clientY &lt; autoScroll.margin\n      right = pointer.clientX &gt; container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY &gt; container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX &lt; rect.left + autoScroll.margin\n      top = pointer.clientY &lt; rect.top + autoScroll.margin\n      right = pointer.clientX &gt; rect.right - autoScroll.margin\n      bottom = pointer.clientY &gt; rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta&lt;T extends ActionName&gt; (\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial&lt;Interaction&lt;T&gt;&gt;\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction &amp;&amp; interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) =&gt; {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) =&gt; autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n"</span>,<span class="code-string">"import type { ActionProps } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\n\nimport { window } from './window'\n\nexport function warnOnce&lt;T&gt; (this: T, method: (...args: any[]) =&gt; any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction&lt;T extends ActionName&gt; (dest: ActionProps&lt;any&gt;, src: ActionProps&lt;T&gt;) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) =&gt; ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, ActionProps } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, ActionName, Plugin } from '@interactjs/core/scope'\nimport type { CursorChecker, PointerType, PointerEventType, Element } from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) =&gt; any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit&lt;SignalArgs['interactions:move'], 'interaction'&gt; &amp; {\n      interaction: Interaction&lt;ActionName&gt;\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps&lt;ActionName&gt;\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue &lt;= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) =&gt; maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction&lt;ActionName&gt;).prepared.name\n\n  if (actionName &amp;&amp; interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable &amp;&amp; interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction&lt;T extends ActionName&gt; (\n  action: ActionProps&lt;T&gt;,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &amp;&amp;\n    interactable.options[action.name].enabled &amp;&amp;\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i &lt; len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction&lt;ActionName&gt;(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action &amp;&amp; !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps&lt;any&gt;\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable &amp;&amp; action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit&lt;T extends ActionName&gt; (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps&lt;T&gt;,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions &amp;&amp; maxPerElement &amp;&amp; autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions &gt;= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount &gt;= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name &amp;&amp; elementCount &gt;= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax &gt; 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement &amp;&amp; prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor&lt;T extends ActionName&gt; (interaction: Interaction&lt;T&gt;, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' &amp;&amp; interactable &amp;&amp; interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) =&gt; {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope, ActionName } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX &gt; absY ? 'x' : absX &lt; absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' &amp;&amp; startAxis !== 'xy' &amp;&amp; startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction&lt;ActionName&gt;).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart &amp;&amp; interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &amp;&amp;\n          action.name === 'drag' &amp;&amp;\n          checkStartAxis(currentAxis, interactable) &amp;&amp;\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction&lt;ActionName&gt;).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared &amp;&amp; interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) =&gt; {\n      const hold = getHoldDuration(interaction)\n\n      if (hold &gt; 0) {\n        interaction.autoStartHoldTimer = setTimeout(() =&gt; {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) =&gt; {\n      if (interaction.autoStartHoldTimer &amp;&amp; interaction.pointerWasMoved &amp;&amp; !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down-&gt;move autoStart\n    'autoStart:before-start': ({ interaction }) =&gt; {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration &gt; 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n"</span>,<span class="code-string">"import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n"</span>,<span class="code-string">"export default {}\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/types/index'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) =&gt; void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive &amp;&amp; /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions &amp;&amp; docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &amp;&amp;\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &amp;&amp;\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) =&gt; {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n"</span>,<span class="code-string">"/* eslint-disable no-console */\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element, OptionMethod } from '@interactjs/types/index'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as win from '@interactjs/utils/window'\n\nimport type visualizer from './visualizer/plugin'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    logger: Logger\n  }\n}\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    visializer: typeof visualizer\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    devTools?: DevToolsOptions\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    devTools: OptionMethod&lt;DevToolsOptions&gt;\n  }\n}\n\nexport interface DevToolsOptions {\n  ignore: { [P in keyof typeof CheckName]?: boolean }\n}\n\nexport interface Logger {\n  warn: (...args: any[]) =&gt; void\n  error: (...args: any[]) =&gt; void\n  log: (...args: any[]) =&gt; void\n}\n\nexport interface Check {\n  name: CheckName\n  text: string\n  perform: (interaction: Interaction) =&gt; boolean\n  getInfo: (interaction: Interaction) =&gt; any[]\n}\n\nenum CheckName {\n  touchAction = 'touchAction',\n  boxSizing = 'boxSizing',\n  noListeners = 'noListeners',\n}\n\nconst prefix = '[interact.js] '\nconst links = {\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\n}\n\n// eslint-disable-next-line no-undef\nconst isProduction = process.env.NODE_ENV === 'production'\n\n// eslint-disable-next-line no-restricted-syntax\nfunction install (scope: Scope, { logger }: { logger?: Logger } = {}) {\n  const { Interactable, defaults } = scope\n\n  scope.logger = logger || console\n\n  defaults.base.devTools = {\n    ignore: {},\n  }\n\n  Interactable.prototype.devTools = function (options?: object) {\n    if (options) {\n      extend(this.options.devTools, options)\n      return this\n    }\n\n    return this.options.devTools\n  }\n}\n\nconst checks: Check[] = [\n  {\n    name: CheckName.touchAction,\n    perform ({ element }) {\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\n    },\n    getInfo ({ element }) {\n      return [element, links.touchAction]\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n',\n  },\n\n  {\n    name: CheckName.boxSizing,\n    perform (interaction) {\n      const { element } = interaction\n\n      return (\n        interaction.prepared.name === 'resize' &amp;&amp;\n        element instanceof domObjects.HTMLElement &amp;&amp;\n        !hasStyle(element, 'boxSizing', /border-box/)\n      )\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo ({ element }) {\n      return [element, links.boxSizing]\n    },\n  },\n\n  {\n    name: CheckName.noListeners,\n    perform (interaction) {\n      const actionName = interaction.prepared.name\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\n\n      return !moveListeners.length\n    },\n    getInfo (interaction) {\n      return [interaction.prepared.name, interaction.interactable]\n    },\n    text: 'There are no listeners set for this action',\n  },\n]\n\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\n  return styleRe.test((value || '').toString())\n}\n\nfunction parentHasStyle (element: Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  let parent = element as HTMLElement\n\n  while (is.element(parent)) {\n    if (hasStyle(parent, prop, styleRe)) {\n      return true\n    }\n\n    parent = parentNode(parent) as HTMLElement\n  }\n\n  return false\n}\n\nconst id = 'dev-tools'\nconst defaultExport: Plugin = isProduction\n  ? { id, install: () =&gt; {} }\n  : {\n    id,\n    install,\n    listeners: {\n      'interactions:action-start': ({ interaction }, scope) =&gt; {\n        for (const check of checks) {\n          const options = interaction.interactable &amp;&amp; interaction.interactable.options\n\n          if (\n            !(options &amp;&amp; options.devTools &amp;&amp; options.devTools.ignore[check.name]) &amp;&amp;\n              check.perform(interaction)\n          ) {\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\n          }\n        }\n      },\n    },\n    checks,\n    CheckName,\n    links,\n    prefix,\n  }\n\nexport default defaultExport\n"</span>,<span class="code-string">"import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone&lt;T extends Object&gt; (source: T): Partial&lt;T&gt; {\n  const dest = {} as Partial&lt;T&gt;\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n"</span>,<span class="code-string">"import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './base'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  edges!: EdgeOptions\n  readonly interaction: Readonly&lt;Interaction&gt;\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg (arg: Partial&lt;ModifierArg&gt;) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll (arg: MethodArg &amp; Partial&lt;ModifierArg&gt;) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg &amp; Partial&lt;ModifierArg&gt;): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set &amp;&amp; this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg&lt;never&gt;)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords &amp;&amp; prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (\n    arg: Partial&lt;DoAnyPhaseArg&gt; &amp; {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &amp;&amp;\n      (!skipModifiers || skipModifiers &lt; this.states.length) &amp;&amp;\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit&lt;DoAnyPhaseArg, 'iEvent'&gt; &amp; { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd &amp;&amp; methods.beforeEnd((arg as unknown) as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend &amp;&amp; this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial&lt;ModifierArg&gt; = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index &lt; modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly &amp;&amp; !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly &amp;&amp; !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' &amp;&amp; !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map(s =&gt; clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers &amp;&amp; actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map(type =&gt; {\n      const options = actionOptions[type]\n\n      return (\n        options &amp;&amp;\n        options.enabled &amp;&amp; {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter(m =&gt; !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left: coords.x - rect.left,\n      top: coords.y - rect.top,\n      right: rect.right - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    }\n}\n"</span>,<span class="code-string">"import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/types/index'\n\nimport Modification from './Modification'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array&lt;{\n      name: string\n      [key: string]: any\n    }&gt;\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport interface Modifier&lt;\n  Defaults = any,\n  State extends ModifierState = any,\n  Name extends string = any,\n  Result = any\n&gt; {\n  options: Defaults\n  methods: {\n    start?: (arg: ModifierArg&lt;State&gt;) =&gt; void\n    set?: (arg: ModifierArg&lt;State&gt;) =&gt; Result\n    beforeEnd?: (arg: ModifierArg&lt;State&gt;) =&gt; Point | void\n    stop?: (arg: ModifierArg&lt;State&gt;) =&gt; void\n  }\n  name?: Name\n  enable: () =&gt; Modifier&lt;Defaults, State, Name, Result&gt;\n  disable: () =&gt; Modifier&lt;Defaults, State, Name, Result&gt;\n}\n\nexport type ModifierState&lt;Defaults = unknown, StateProps = unknown, Name extends string = any&gt; = {\n  options: Defaults\n  methods?: Modifier&lt;Defaults&gt;['methods']\n  index?: number\n  name?: Name\n} &amp; StateProps\n\nexport interface ModifierArg&lt;State extends ModifierState = ModifierState&gt; {\n  interaction: Interaction\n  interactable: Interactable\n  phase: EventPhase\n  rect: FullRect\n  edges: EdgeOptions\n  state: State\n  element: Element\n  pageCoords: Point\n  prevCoords: Point\n  prevRect?: FullRect\n  coords: Point\n  startOffset: Rect\n  preEnd?: boolean\n}\n\nexport interface ModifierModule&lt;\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Result = unknown\n&gt; {\n  defaults?: Defaults\n  start?(arg: ModifierArg&lt;State&gt;): void\n  set?(arg: ModifierArg&lt;State&gt;): Result\n  beforeEnd?(arg: ModifierArg&lt;State&gt;): Point | void\n  stop?(arg: ModifierArg&lt;State&gt;): void\n}\n\nexport interface ModifierFunction&lt;\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string\n&gt; {\n  (_options?: Partial&lt;Defaults&gt;): Modifier&lt;Defaults, State, Name&gt;\n  _defaults: Defaults\n  _methods: ModifierModule&lt;Defaults, State&gt;\n}\n\nexport function makeModifier&lt;\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n  Result\n&gt; (module: ModifierModule&lt;Defaults, State, Result&gt;, name?: Name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial&lt;Defaults&gt;) =&gt; {\n    const options = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        ;(options as any)[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier&lt;Defaults, State, Name, Result&gt; = {\n      options,\n      methods,\n      name,\n      enable: () =&gt; {\n        options.enabled = true\n        return m\n      },\n      disable: () =&gt; {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name &amp;&amp; typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent&lt;any&gt;\n  interaction: Interaction&lt;any&gt;\n}) {\n  const result = interaction.modification!.result\n\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: scope =&gt; {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': arg =&gt; {\n      const modification = arg.interaction.modification!\n\n      modification.start(arg, arg.interaction.coords.start.page)\n      arg.interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': arg =&gt; arg.interaction.modification.setAndApply(arg),\n\n    'interactions:before-action-end': arg =&gt; arg.interaction.modification.beforeEnd(arg),\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': arg =&gt; arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n"</span>,<span class="code-string">"import type { Point, Listeners, OrBoolean, Element } from '@interactjs/types/index'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial&lt;BaseDefaults&gt; &amp;\nPartial&lt;PerActionDefaults&gt; &amp;\n{\n  [P in keyof ActionDefaults]?: Partial&lt;ActionDefaults[P]&gt;\n}\n\n// export interface Options extends BaseDefaults, PerActionDefaults {}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean&lt;Partial&lt;ActionDefaults&gt;&gt; {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n"</span>,<span class="code-string">"import type { ActionName } from '@interactjs/core/scope'\nimport type { Point, FullRect, PointerEventType, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './defaultOptions'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent&lt;\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase\n&gt; extends BaseEvent&lt;T&gt; {\n  target: Element\n  currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType&lt;InteractEvent&lt;T&gt;['getSwipe']&gt;\n  timeStamp: any\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction&lt;T&gt;,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target &amp;&amp; target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed &lt; 600 || this.timeStamp - interaction.prevEvent.timeStamp &gt; 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle &lt; 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap &lt;= angle &amp;&amp; angle &lt; 225 + overlap\n    const up = 225 - overlap &lt;= angle &amp;&amp; angle &lt; 315 + overlap\n\n    const right = !left &amp;&amp; (315 - overlap &lt;= angle || angle &lt; 45 + overlap)\n    const down = !up &amp;&amp; 45 - overlap &lt;= angle &amp;&amp; angle &lt; 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n"</span>,<span class="code-string">"import type { PointerEventType, PointerType } from '@interactjs/types/index'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n"</span>,<span class="code-string">"import type { ActionDefaults } from '@interactjs/core/defaultOptions'\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionName, Scope } from './scope'\n\nexport interface ActionProps&lt;T extends ActionName | null = never&gt; {\n  name: T\n  axis?: 'x' | 'y' | 'xy' | null\n  edges?: EdgeOptions | null\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps&lt;T extends {} = {}&gt; = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction&lt;never&gt;\n} &amp; T\n\nexport interface DoPhaseArg&lt;T extends ActionName, P extends EventPhase&gt; {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction&lt;T&gt;\n  iEvent: InteractEvent&lt;T, P&gt;\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg&lt;ActionName, EventPhase&gt;\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction&lt;ActionName&gt; }\n    'interactions:down': PointerArgProps&lt;{\n      type: 'down'\n    }&gt;\n    'interactions:move': PointerArgProps&lt;{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }&gt;\n    'interactions:up': PointerArgProps&lt;{\n      type: 'up'\n      curEventTarget: EventTarget\n    }&gt;\n    'interactions:cancel': SignalArgs['interactions:up'] &amp; {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps&lt;{\n      down: boolean\n    }&gt;\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction&lt;never&gt;, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy&lt;T extends ActionName | null = never&gt; = Pick&lt;\nInteraction&lt;T&gt;,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n&gt;\n\nlet idCounter = 0\n\nexport class Interaction&lt;T extends ActionName | null = ActionName&gt; {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Element = null\n  rect: FullRect\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps&lt;T&gt; = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent&lt;T, EventPhase&gt; = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy&lt;T&gt; = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy&lt;T&gt;\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) =&gt; that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down-&gt;move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.&lt;action&gt;able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start&lt;A extends ActionName&gt; (action: ActionProps&lt;A&gt;, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length &lt; (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) &amp;&amp; !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation &amp;&amp; !(this.modification &amp;&amp; this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &amp;&amp;\n      this.coords.cur.page.y === this.coords.prev.page.y &amp;&amp;\n      this.coords.cur.client.x === this.coords.prev.client.x &amp;&amp;\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown &amp;&amp; !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) &gt; this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove &amp;&amp; !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX &gt; 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, curPointer =&gt; curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map(p =&gt; p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: (this as unknown) as Interaction&lt;never&gt;,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent&lt;P extends EventPhase&gt; (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent&lt;T, P&gt;(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent&lt;P extends EventPhase&gt; (iEvent: InteractEvent&lt;T, P&gt;) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp &gt;= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase&lt;P extends EventPhase&gt; (\n    signalArg: Omit&lt;DoPhaseArg&lt;T, P&gt;, 'iEvent'&gt; &amp; { iEvent?: InteractEvent&lt;T, P&gt; },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect &amp;&amp; phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport { _ProxyMethods } from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { Point } from '@interactjs/types/index'\nimport * as rectUtils from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    offsetBy?: typeof offsetBy\n    offset: {\n      total: Point\n      pending: Point\n    }\n  }\n\n  enum _ProxyMethods {\n    offsetBy = '',\n  }\n}\n\n;(_ProxyMethods as any).offsetBy = ''\n\nexport function addTotal (interaction: Interaction) {\n  if (!interaction.pointerIsDown) {\n    return\n  }\n\n  addToCoords(interaction.coords.cur, interaction.offset.total)\n\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nfunction beforeAction ({ interaction }: { interaction: Interaction }) {\n  applyPending(interaction)\n}\n\nfunction beforeEnd ({ interaction }: { interaction: Interaction }): boolean | void {\n  const hadPending = applyPending(interaction)\n\n  if (!hadPending) return\n\n  interaction.move({ offset: true })\n  interaction.end()\n\n  return false\n}\n\nfunction end ({ interaction }: { interaction: Interaction }) {\n  interaction.offset.total.x = 0\n  interaction.offset.total.y = 0\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nexport function applyPending (interaction: Interaction) {\n  if (!hasPending(interaction)) {\n    return false\n  }\n\n  const { pending } = interaction.offset\n\n  addToCoords(interaction.coords.cur, pending)\n  addToCoords(interaction.coords.delta, pending)\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\n\n  pending.x = 0\n  pending.y = 0\n\n  return true\n}\n\nfunction offsetBy (this: Interaction, { x, y }: Point) {\n  this.offset.pending.x += x\n  this.offset.pending.y += y\n\n  this.offset.total.x += x\n  this.offset.total.y += y\n}\n\nfunction addToCoords ({ page, client }, { x, y }: Point) {\n  page.x += x\n  page.y += y\n  client.x += x\n  client.y += y\n}\n\nfunction hasPending (interaction: Interaction) {\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\n}\n\nconst offset: Plugin = {\n  id: 'offset',\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\n  install (scope) {\n    scope.Interaction.prototype.offsetBy = offsetBy\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.offset = {\n        total: { x: 0, y: 0 },\n        pending: { x: 0, y: 0 },\n      }\n    },\n    'interactions:update-pointer': ({ interaction }) =&gt; addTotal(interaction),\n    'interactions:before-action-start': beforeAction,\n    'interactions:before-action-move': beforeAction,\n    'interactions:before-action-end': beforeEnd,\n    'interactions:stop': end,\n  },\n}\n\nexport default offset\n"</span>,<span class="code-string">"import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport offset from '@interactjs/offset/plugin'\nimport type { Point, PointerEventType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number // the lambda in exponential decay\n      minSpeed?: number // target speed must be above this for inertia to start\n      endSpeed?: number // the speed at which inertia is slow enough to stop\n      allowResume?: true // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit&lt;DoPhaseArg&lt;ActionName, 'inertiastart'&gt;, 'iEvent'&gt;\n    'interactions:action-inertiastart': DoPhaseArg&lt;ActionName, 'inertiastart'&gt;\n    'interactions:after-action-inertiastart': DoPhaseArg&lt;ActionName, 'inertiastart'&gt;\n    'interactions:before-action-resume': Omit&lt;DoPhaseArg&lt;ActionName, 'resume'&gt;, 'iEvent'&gt;\n    'interactions:action-resume': DoPhaseArg&lt;ActionName, 'resume'&gt;\n    'interactions:after-action-resume': DoPhaseArg&lt;ActionName, 'resume'&gt;\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled: false,\n    resistance: 10, // the lambda in exponential decay\n    minSpeed: 100, // target speed must be above this for inertia to start\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\n    allowResume: true, // allow resuming an action in inertia phase\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification!: Modification\n  modifierCount = 0\n  modifierArg!: modifiers.ModifierArg\n\n  startCoords!: Point\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset!: Point\n  modifiedOffset!: Point\n  currentOffset!: Point\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout!: number\n  readonly interaction: Interaction\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = modification.fillArg({\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    })\n\n    const thrown =\n      this.t0 - interaction.coords.cur.timeStamp &lt; 50 &amp;&amp;\n      pointerSpeed &gt; options.minSpeed &amp;&amp;\n      pointerSpeed &gt; options.endSpeed\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() =&gt; this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() =&gt; this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () =&gt; void) {\n    this.timeout = raf.request(() =&gt; {\n      if (this.active) {\n        tickFn()\n      }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t &lt; this.te) {\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0,\n          0,\n          this.targetOffset.x,\n          this.targetOffset.y,\n          this.modifiedOffset.x,\n          this.modifiedOffset.y,\n          progress,\n        )\n      } else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() =&gt; this.inertiaTick())\n    } else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t &lt; duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() =&gt; this.smoothEndTick())\n    } else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: DoPhaseArg&lt;ActionName, 'end'&gt;) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) return\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interaction) {\n  return interactable &amp;&amp; interactable.options &amp;&amp; prepared.name &amp;&amp; interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) =&gt; {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': arg =&gt; {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': arg =&gt; arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': arg =&gt;\n      arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': arg =&gt; arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number,\n  startY: number,\n  cpX: number,\n  cpY: number,\n  endX: number,\n  endY: number,\n  position: number,\n) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n"</span>,<span class="code-string">"import type { Listener, ListenersArg, Rect } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire&lt;T extends { type: string, propagationStopped?: boolean }&gt; (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped &amp;&amp; global &amp;&amp; (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n"</span>,<span class="code-string">"import type { Actions } from '@interactjs/core/scope'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 &amp;&amp; type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n"</span>,<span class="code-string">"/* eslint-disable no-dupe-class-members */\nimport type { ActionMap, ActionName, Actions, Scope } from '@interactjs/core/scope'\nimport type {\n  Context,\n  Element,\n  Target,\n  Listeners,\n  OrBoolean,\n  EventTypes,\n  ListenersArg,\n  ActionMethod,\n} from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults } from './defaultOptions'\nimport { Options } from './defaultOptions'\nimport isNonNativeEvent from './isNonNativeEvent'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial&lt;Eventable&gt; {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required&lt;Options&gt;\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable&lt;any&gt;) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean&lt;Options&gt;) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array&lt;any&gt;(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &amp;&amp;\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) &amp;&amp; is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) =&gt; any | null\n  rectChecker(checker: (element: Element) =&gt; any): this\n  rectChecker (checker?: (element: Element) =&gt; any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = element =&gt; {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &amp;&amp;\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire&lt;E extends { type: string }&gt; (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) &amp;&amp; !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required&lt;Options&gt;) = clone(defaults.base) as Required&lt;Options&gt;\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod&lt;unknown&gt;)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i &gt;= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target &amp;&amp; context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l &gt;= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/defaultOptions'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) =&gt; {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, m =&gt; m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options &amp;&amp; options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      m =&gt; m.context === context &amp;&amp; (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found &amp;&amp; found.interactable\n  }\n\n  forEachMatch&lt;T&gt; (node: Node, callback: (interactable: Interactable) =&gt; T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) &amp;&amp; domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &amp;&amp;\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n"</span>,<span class="code-string">"import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType&lt;typeof install&gt;\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) =&gt; any\n\nfunction install (scope: Scope) {\n  const targets: Array&lt;{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }&gt; = []\n\n  const delegatedEvents: {\n    [type: string]: Array&lt;{\n      selector: string\n      context: Node\n      listeners: Array&lt;[Listener, { capture: boolean, passive: boolean }]&gt;\n    }&gt;\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, t =&gt; t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener &amp;&amp; !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, t =&gt; t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i &gt;= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i &lt; typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty &amp;&amp; !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, d =&gt; d.selector === selector &amp;&amp; d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index &gt;= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector &amp;&amp; cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i &gt;= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener &amp;&amp; capture === options.capture &amp;&amp; passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i &lt; delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &amp;&amp;\n          domUtils.nodeContains(context, eventTarget) &amp;&amp;\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture &amp;&amp; passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial&lt;Event&gt; {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n"</span>,<span class="code-string">"/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, ListenersArg, Target, Element, Listener } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport { warnOnce } from '../utils/misc'\n\nimport type { Interactable } from './Interactable'\nimport type { Options } from './defaultOptions'\nimport isNonNativeEvent from './isNonNativeEvent'\n\nexport interface InteractStatic {\n  (target: Target, options?: Options): Interactable\n  getPointerAverage: typeof pointerUtils.pointerAverage\n  getTouchBBox: typeof pointerUtils.touchBBox\n  getTouchDistance: typeof pointerUtils.touchDistance\n  getTouchAngle: typeof pointerUtils.touchAngle\n  getElementRect: typeof domUtils.getElementRect\n  getElementClientRect: typeof domUtils.getElementClientRect\n  matchesSelector: typeof domUtils.matchesSelector\n  closest: typeof domUtils.closest\n  /** @internal */ globalEvents: any\n  version: string\n  /** @internal */ scope: Scope\n  use(\n    plugin: Plugin,\n    options?: {\n      [key: string]: any\n    },\n  ): any\n  isSet(target: Element, options?: any): boolean\n  on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n  off(type: EventTypes, listener: any, options?: object): any\n  debug(): any\n  supportsTouch(): boolean\n  supportsPointerEvent(): boolean\n  stop(): any\n  pointerMoveTolerance(newValue?: number): any\n  addDocument(doc: Document, options?: object): void\n  removeDocument(doc: Document): void\n}\n\nexport function createInteractStatic (scope: Scope): InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target, options) =&gt; {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options &amp;&amp; options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) &amp;&amp; type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents &amp;&amp; (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact as any\n}\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &amp;&amp;\n        interaction.simulation.allowResume &amp;&amp;\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' &amp;&amp; pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation &amp;&amp; !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType &amp;&amp; !(/down/i.test(eventType) &amp;&amp; interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target &amp;&amp; !(target.options.gesture &amp;&amp; target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length &gt;= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() &amp;&amp; pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) =&gt; id === pointerId)\n}\n\nexport default finder\n"</span>,<span class="code-string">"import type { Scope, ActionName, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Listener } from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: &lt;T extends ActionName&gt;(options: any) =&gt; InteractionBase&lt;T&gt;\n      list: Array&lt;InteractionBase&lt;ActionName&gt;&gt;\n      listeners: { [type: string]: Listener }\n      docEvents: Array&lt;{ type: string, listener: Listener }&gt;\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class &lt;T extends ActionName&gt; extends InteractionBase&lt;T&gt; {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new&lt;T extends ActionName&gt; (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) =&gt; scope.fire(name, arg)\n\n      const interaction = new scope.Interaction&lt;T&gt;(options as Required&lt;typeof options&gt;)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) =&gt; nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent &amp;&amp; /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i &lt; interactions.length &amp;&amp; !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' &amp;&amp; interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime &lt; 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal&lt;T extends 'scope:add-document' | 'scope:remove-document'&gt; (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS &amp;&amp; !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options &amp;&amp; options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': arg =&gt; onDocSignal(arg, 'add'),\n    'scope:remove-document': arg =&gt; onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) =&gt; {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i &gt;= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length &gt; 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport type { PhaseMap } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport type { OptionsArg } from './defaultOptions'\nimport { defaults } from './defaultOptions'\nimport events from './events'\nimport { createInteractStatic } from './interactStatic'\nimport interactions from './interactions'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) =&gt; void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record&lt;string, any&gt;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionMap {}\nexport type ActionName = keyof ActionMap\n\nexport interface Actions {\n  map: ActionMap\n  phases: PhaseMap\n  methodDict: { [P in ActionName]?: keyof Interactable }\n  phaselessTypes: { [type: string]: true }\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array&lt;{\n    map: ListenerMap\n    id: string\n  }&gt; = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {},\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array&lt;{ doc: Document, options: any }&gt; = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set&lt;T extends InteractableBase&gt; (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\n\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire&lt;T extends ListenerName&gt; (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener &amp;&amp; listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) =&gt; this.removeDocument(event.target as Document)\n\n  init (window: Window) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners &amp;&amp; plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) =&gt; {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index &lt; len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i &lt; this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window) {\n  scope.isInitialized = true\n  win.init(window)\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id &amp;&amp; id.replace(/\\/.*$/, '')\n}\n"</span>,<span class="code-string">"import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nexport const init = (win: Window) =&gt; scope.init(win)\n\nif (typeof window === 'object' &amp;&amp; !!window) {\n  init(window)\n}\n"</span>,<span class="code-string">"export default () =&gt; {}\n"</span>,<span class="code-string">"export default () =&gt; {}\n"</span>,<span class="code-string">"import type { Rect, Point } from '@interactjs/types/index'\n\nimport type { SnapFunction, SnapTarget } from '../modifiers/snap/pointer'\n\nexport type GridOptions = (Partial&lt;Rect&gt; | Point) &amp; {\n  range?: number\n  limits?: Rect\n  offset?: Point\n}\n\nexport default (grid: GridOptions) =&gt; {\n  const coordFields = ([\n    ['x', 'y'],\n    ['left', 'top'],\n    ['right', 'bottom'],\n    ['width', 'height'],\n  ] as const).filter(([xField, yField]) =&gt; xField in grid || yField in grid)\n\n  const gridFunc: SnapFunction &amp; {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) =&gt; {\n    const {\n      range,\n      limits = {\n        left: -Infinity,\n        right: Infinity,\n        top: -Infinity,\n        bottom: Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: SnapTarget &amp; {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n"</span>,<span class="code-string">"import type { Plugin } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n"</span>,<span class="code-string">"/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * ```js\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n * ```\n */\n\nimport type { Point, Rect, EdgeOptions } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport type { Modifier, ModifierModule, ModifierState } from './base'\nimport { makeModifier } from './base'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState&lt;\nAspectRatioOptions,\n{\n  startCoords: Point\n  startRect: Rect\n  linkedEdges: EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: 1 | -1\n  subModification: Modification\n}\n&gt;\n\nconst aspectRatio: ModifierModule&lt;AspectRatioOptions, AspectRatioState&gt; = {\n  start (arg) {\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\n    let { ratio } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = (state.linkedEdges = {\n      top: originalEdges.top || (originalEdges.left &amp;&amp; !originalEdges.bottom),\n      left: originalEdges.left || (originalEdges.top &amp;&amp; !originalEdges.right),\n      bottom: originalEdges.bottom || (originalEdges.right &amp;&amp; !originalEdges.top),\n      right: originalEdges.right || (originalEdges.bottom &amp;&amp; !originalEdges.left),\n    })\n\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\n\n    if (state.equalDelta) {\n      state.edgeSign = ((linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)) as 1 | -1\n    } else {\n      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left\n      state.edgeSign = negativeSecondaryEdge ? -1 : 1\n    }\n\n    extend(arg.edges, linkedEdges)\n\n    if (!modifiers || !modifiers.length) return\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) {\n      return null\n    }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(state.linkedEdges, correctedRect, {\n      x: coords.x - initialCoords.x,\n      y: coords.y - initialCoords.y,\n    })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: state.linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) &gt; Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign\n  } else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign\n  }\n}\n\nfunction setRatio (\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\n  xIsPrimaryAxis: boolean,\n  coords: Point,\n  rect: Rect,\n) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign\n  } else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n"</span>,<span class="code-string">"import type { ModifierFunction } from './base'\n\nconst noop = ((() =&gt; {}) as unknown) as ModifierFunction&lt;any, any, 'noop'&gt;\n\nnoop._defaults = {}\n\nexport default noop\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport type { RectResolvable, Rect, Point } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierModule, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: RectResolvable&lt;[number, number, Interaction]&gt;\n  // what part of self is allowed to drag over\n  elementRect: Rect\n  offset: Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState&lt;\nRestrictOptions,\n{\n  offset: Rect\n}\n&gt;\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg&lt;RestrictState&gt;) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Rect = extend(\n    {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    },\n    options.offset || {},\n  )\n\n  if (rect &amp;&amp; elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = restriction.right - restriction.left - rect.width\n      const heightDiff = restriction.bottom - restriction.top - rect.height\n\n      if (widthDiff &lt; 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff &lt; 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - rect.width * elementRect.left\n    offset.top += startOffset.top - rect.height * elementRect.top\n\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg&lt;RestrictState&gt;) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) return\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: RectResolvable&lt;[number, number, Interaction]&gt;,\n  interaction: Interaction,\n  coords?: Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\n      coords.x,\n      coords.y,\n      interaction,\n    ])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule&lt;RestrictOptions, RestrictState&gt; = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n"</span>,<span class="code-string">"// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport type { Point, Rect } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState&lt;\nRestrictEdgesOptions,\n{\n  inner: Rect\n  outer: Rect\n  offset: RestrictEdgesOptions['offset']\n}\n&gt;\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg&lt;RestrictEdgesState&gt;) {\n  const { options } = state\n  let offset: Point\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top: offset.y + startOffset.top,\n    left: offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right: offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg&lt;RestrictEdgesState&gt;) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\n  } else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\n  } else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\n  }\n}\n\nfunction fixRect (rect: Rect, defaults: Rect) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n"</span>,<span class="code-string">"import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend(\n  {\n    get elementRect () {\n      return { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    set elementRect (_) {},\n  },\n  restrict.defaults,\n)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n"</span>,<span class="code-string">"import type { Point, Rect, Size } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { RestrictEdgesState } from './edges'\nimport { restrictEdges } from './edges'\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Size | Point | RestrictOptions['restriction']\n  max?: Size | Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg&lt;RestrictEdgesState&gt;) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState = RestrictEdgesState &amp;\nModifierState&lt;\nRestrictSizeOptions &amp; { inner: Rect, outer: Rect },\n{\n  min: Rect\n  max: Rect\n}\n&gt;\n\nfunction set (arg: ModifierArg&lt;RestrictSizeState&gt;) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  } else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  } else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n"</span>,<span class="code-string">"import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/scope'\nimport type { Point, RectResolvable, Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport type { ModifierArg, ModifierState } from '../base'\nimport { makeModifier } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy&lt;ActionName&gt;,\n  offset: Offset,\n  index: number,\n) =&gt; SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[] | null\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[] | null\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable&lt;[Interaction]&gt; | 'startCoords' | null\n  offsetWithOrigin?: boolean\n  origin: RectResolvable&lt;[Element]&gt; | Point | null\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState&lt;\nSnapOptions,\n{\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}\n&gt;\n\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect &amp;&amp; relativePoints &amp;&amp; relativePoints.length\n      ? relativePoints.map((relativePoint, index) =&gt; ({\n        index,\n        relativePoint,\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n      }))\n      : [\n        {\n          index: 0,\n          relativePoint: null,\n          x: snapOffset.x,\n          y: snapOffset.y,\n        },\n      ]\n}\n\nfunction set (arg: ModifierArg&lt;SnapState&gt;) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index &lt; len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance &lt;= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity &amp;&amp; closest.inRange &amp;&amp; closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n        closest.inRange &amp;&amp; range !== Infinity\n          ? // the pointer is relatively deeper in this target\n          distance / range &lt; closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n          (range === Infinity &amp;&amp; closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance &lt; closest.distance\n        : // The other is not in range and the pointer is closer to this target\n        !closest.inRange &amp;&amp; distance &lt; closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial&lt;ModifierArg&lt;SnapState&gt;&gt;) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"</span>,<span class="code-string">"// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport type { ModifierArg } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snap } from './pointer'\n\nexport type SnapSizeOptions = Pick&lt;SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'&gt;\n\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [\n        {\n          x: edges.left ? 0 : 1,\n          y: edges.top ? 0 : 1,\n        },\n      ],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of options.targets || []) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    } else {\n      target = snapTarget\n    }\n\n    if (!target) {\n      continue\n    }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n"</span>,<span class="code-string">"/**\n * @module modifiers/snapEdges\n *\n * @description\n * WOW&gt; This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * ```js\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n * ```\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport type { ModifierArg, ModifierModule } from '../base'\nimport { makeModifier } from '../base'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick&lt;SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'&gt;\n\nfunction start (arg: ModifierArg&lt;SnapState&gt;) {\n  const { edges } = arg\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule&lt;SnapEdgesOptions, SnapState, ReturnType&lt;typeof snapSize.set&gt;&gt; = {\n  start,\n  set: snapSize.set,\n  defaults: extend(clone(snapSize.defaults), {\n    targets: null,\n    range: null,\n    offset: { x: 0, y: 0 },\n  } as const),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n"</span>,<span class="code-string">"/* eslint-disable node/no-extraneous-import */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring'\nimport transform from './transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n"</span>,<span class="code-string">"import type { Plugin } from '@interactjs/core/scope'\nimport snappers from '@interactjs/snappers/plugin'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport type { PointerEventType, PointerType, Point } from '@interactjs/types/index'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport { BaseEvent } from '../core/BaseEvent'\n\nexport default class PointerEvent&lt;T extends string = any&gt; extends BaseEvent&lt;never&gt; {\n  type: T\n  originalEvent: PointerEventType\n  pointerId: number\n  pointerType: string\n  double: boolean\n  pageX: number\n  pageY: number\n  clientX: number\n  clientY: number\n  dt: number\n  eventable: any;\n  [key: string]: any\n\n  /** */\n  constructor (\n    type: T,\n    pointer: PointerType | PointerEvent&lt;any&gt;,\n    event: PointerEventType,\n    eventTarget: Node,\n    interaction: Interaction&lt;never&gt;,\n    timeStamp: number,\n  ) {\n    super(interaction)\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.timeStamp = timeStamp\n    this.originalEvent = event\n    this.type = type\n    this.pointerId = pointerUtils.getPointerId(pointer)\n    this.pointerType = pointerUtils.getPointerType(pointer)\n    this.target = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double = !!(\n        interaction.prevTap &amp;&amp;\n        interaction.prevTap.type !== 'doubletap' &amp;&amp;\n        interaction.prevTap.target === this.target &amp;&amp;\n        interval &lt; 500\n      )\n    } else if (type === 'doubletap') {\n      this.dt = (pointer as PointerEvent&lt;'tap'&gt;).timeStamp - interaction.tapTime\n    }\n  }\n\n  _subtractOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX -= originX\n    this.pageY -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  _addOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX += originX\n    this.pageY += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n}\n\nexport { PointerEvent }\n"</span>,<span class="code-string">"import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/defaultOptions'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array&lt;{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}&gt;\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent&lt;string&gt;\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent&lt;any&gt; }\n    'pointerEvents:fired': {\n      interaction: Interaction&lt;null&gt;\n      pointer: PointerType | PointerEvent&lt;any&gt;\n      event: PointerEventType | PointerEvent&lt;any&gt;\n      eventTarget: Node\n      pointerEvent: PointerEvent&lt;any&gt;\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction&lt;any&gt;\n      pointer: PointerType | PointerEvent&lt;any&gt;\n      event: PointerEventType | PointerEvent&lt;any&gt;\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) =&gt; {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) =&gt; {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) =&gt; {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire&lt;T extends string&gt; (\n  arg: {\n    pointer: PointerType | PointerEvent&lt;any&gt;\n    event: PointerEventType | PointerEvent&lt;any&gt;\n    eventTarget: Node\n    interaction: Interaction&lt;never&gt;\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i &lt; targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &amp;&amp;\n        i + 1 &lt; targets.length &amp;&amp;\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n        {\n          interaction,\n          pointer,\n          event,\n          eventTarget,\n          type: 'doubletap',\n        },\n        scope,\n      )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets&lt;T extends string&gt; (\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction&lt;any&gt;\n    pointer: PointerType | PointerEvent&lt;any&gt;\n    event: PointerEventType | PointerEvent&lt;any&gt;\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &amp;&amp;\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo &amp;&amp; pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      target =&gt; target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down &amp;&amp; pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold &amp;&amp; hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate &amp;&amp; (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold (\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration &lt; minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() =&gt; {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n"</span>,<span class="code-string">"import type Interaction from '@interactjs/core/Interaction'\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\n\nimport type PointerEvent from './PointerEvent'\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent&lt;T extends string = any&gt; {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.usePlugin(basePlugin)\n\n  const { pointerEvents } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent&lt;any&gt; }) {\n  if (pointerEvent.type !== 'hold') return\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired (\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\n  scope: Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) return\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval &lt;= 0) return\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() =&gt; {\n    scope.pointerEvents.fire(\n      {\n        interaction,\n        eventTarget,\n        type: 'hold',\n        pointer: pointerEvent,\n        event: pointerEvent,\n      },\n      scope,\n    )\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }: { interaction: Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) =&gt; {\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) =&gt; any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nconst plugin: Plugin = {\n  id: 'pointer-events/interactableTargets',\n  install,\n  listeners: {\n    'pointerEvents:collect-targets': ({ targets, node, type, eventTarget }, scope) =&gt; {\n      scope.interactables.forEachMatch(node, (interactable: Interactable) =&gt; {\n        const eventable = interactable.events\n        const options = eventable.options\n\n        if (\n          eventable.types[type] &amp;&amp;\n          eventable.types[type].length &amp;&amp;\n          interactable.testIgnoreAllow(options, node, eventTarget)\n        ) {\n          targets.push({\n            node,\n            eventable,\n            props: { interactable },\n          })\n        }\n      })\n    },\n\n    'interactable:new': ({ interactable }) =&gt; {\n      interactable.events.getRect = function (element: Element) {\n        return interactable.getRect(element)\n      }\n    },\n\n    'interactable:set': ({ interactable, options }, scope) =&gt; {\n      extend(interactable.events.options, scope.pointerEvents.defaults)\n      extend(interactable.events.options, options.pointerEvents || {})\n    },\n  },\n}\n\nexport default plugin\n"</span>,<span class="code-string">"import type { Plugin } from '@interactjs/core/scope'\n\nimport * as pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nconst plugin: Plugin = {\n  id: 'pointer-events',\n  install (scope) {\n    scope.usePlugin(pointerEvents)\n    scope.usePlugin(holdRepeat)\n    scope.usePlugin(interactableTargets)\n  },\n}\n\nexport default plugin\n"</span>,<span class="code-string">"import type { Interactable } from '@interactjs/core/Interactable'\nimport type { ActionProps, DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport type { ActionName, Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit&lt;DoAnyPhaseArg, 'iEvent'&gt;\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: &lt;T extends ActionName&gt;(action: ActionProps&lt;T&gt;) =&gt; ReturnType&lt;typeof doReflow&gt;\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise&lt;void&gt;\n    _reflowResolve: (...args: unknown[]) =&gt; void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow&lt;T extends ActionName&gt; (\n  interactable: Interactable,\n  action: ActionProps&lt;T&gt;,\n  scope: Scope,\n): Promise&lt;Interactable&gt; {\n  const elements = (is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]) as Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array&lt;Promise&lt;null&gt;&gt; | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) {\n      break\n    }\n\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) =&gt; {\n      return (\n        interaction.interacting() &amp;&amp;\n        interaction.interactable === interactable &amp;&amp;\n        interaction.element === element &amp;&amp;\n        interaction.prepared.name === action.name\n      )\n    })\n    let reflowPromise: Promise&lt;null&gt;\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise =\n          runningInteraction._reflowPromise ||\n          new Promise((resolve: any) =&gt; {\n            runningInteraction._reflowResolve = resolve\n          })\n      }\n    } else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page: { x: xywh.x, y: xywh.y },\n        client: { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow&lt;T&gt;(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises &amp;&amp; Promise.all(promises).then(() =&gt; interactable)\n}\n\nfunction startReflow&lt;T extends ActionName&gt; (\n  scope: Scope,\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps&lt;T&gt;,\n  event: any,\n) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = (scope.window as unknown) as { Promise: PromiseConstructor }\n  const reflowPromise = Promise\n    ? new Promise&lt;undefined&gt;(resolve =&gt; {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  } else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) =&gt; {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n"</span>,<span class="code-string">"import actions from '@interactjs/actions/plugin'\nimport arrange from '@interactjs/arrange/plugin'\nimport autoScroll from '@interactjs/auto-scroll/plugin'\nimport autoStart from '@interactjs/auto-start/plugin'\nimport clone from '@interactjs/clone/plugin'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport devTools from '@interactjs/dev-tools/plugin'\nimport feedback from '@interactjs/feedback/plugin'\nimport inertia from '@interactjs/inertia/plugin'\nimport interact from '@interactjs/interact'\nimport modifiers from '@interactjs/modifiers/plugin'\nimport multiTarget from '@interactjs/multi-target/plugin'\nimport offset from '@interactjs/offset/plugin'\nimport pointerEvents from '@interactjs/pointer-events/plugin'\nimport reactComponents from '@interactjs/react/plugin'\nimport reflow from '@interactjs/reflow/plugin'\nimport vueComponents from '@interactjs/vue/plugin'\n\ninteract.use(multiTarget)\n\ninteract.use(interactablePreventDefault)\n\ninteract.use(offset)\n\n// interaction element cloning\ninteract.use(clone)\n\n// sortable and swappable\ninteract.use(arrange)\n\n// pointerEvents\ninteract.use(pointerEvents)\n\n// inertia\ninteract.use(inertia)\n\n// snap, resize, etc.\ninteract.use(modifiers)\n\n// autoStart, hold\ninteract.use(autoStart)\n\n// drag and drop, resize, gesture\ninteract.use(actions)\n\n// autoScroll\ninteract.use(autoScroll)\n\n// reflow\ninteract.use(reflow)\n\ninteract.use(feedback)\n\ninteract.use(vueComponents)\n\ninteract.use(reactComponents)\n\n// eslint-disable-next-line no-undef\nif (process.env.NODE_ENV !== 'production') {\n  interact.use(devTools)\n}\n\nexport default interact\n\nif (typeof module === 'object' &amp;&amp; !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n"</span>,<span class="code-string">"// eslint-disable-next-line import/no-extraneous-dependencies\nimport interact from '@interactjs/interactjs/index'\n\nexport default interact\n\nif (typeof module === 'object' &amp;&amp; !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n"</span>,<span class="code-string">"\nreturn _$index_84;\n\n});\n"</span>]}</code></td></tr><tr><td class="css-a4x74f">\</td><style data-emotion-css="jhhjkz">.css-jhhjkz{padding-left:10px;color:rgba(27,31,35,.3);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}</style><td class="css-jhhjkz">No newline at end of file</td></tr></tbody></table></div></div></div></div><style data-emotion-css="1teho9j">.css-1teho9j{margin-top:5rem;background:black;color:#aaa;}</style><footer class="css-1teho9j"><style data-emotion-css="1ui8put">.css-1ui8put{max-width:940px;padding:10px 20px;margin:0 auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}</style><div class="css-1ui8put"><p><span>Build: <!-- -->b5d1b223</span></p><p><span>© <!-- -->2021<!-- --> UNPKG</span></p><style data-emotion-css="la3nd4">.css-la3nd4{font-size:1.5rem;}</style><p class="css-la3nd4"><style data-emotion-css="bogekj">.css-bogekj{color:#aaa;display:inline-block;}.css-bogekj:hover{color:white;}</style><a href="https://twitter.com/unpkg" class="css-bogekj"><style data-emotion-css="i6dzq1">.css-i6dzq1{vertical-align:text-bottom;}</style><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="css-i6dzq1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><style data-emotion-css="3czw03">.css-3czw03{color:#aaa;display:inline-block;margin-left:1rem;}.css-3czw03:hover{color:white;}</style><a href="https://github.com/mjackson/unpkg" class="css-3czw03"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="css-i6dzq1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></p></div></footer></div><script src="/react@16.8.6/umd/react.production.min.js"></script><script src="/react-dom@16.8.6/umd/react-dom.production.min.js"></script><script src="/@emotion/core@10.0.6/dist/core.umd.min.js"></script><script>'use strict';(function(l,t,c){function k(){k=Object.assign||function(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],e;for(e in c)Object.prototype.hasOwnProperty.call(c,e)&&(a[e]=c[e])}return a};return k.apply(this,arguments)}function F(a,b){if(null==a)return{};var c={},e=Object.keys(a),f;for(f=0;f<e.length;f++){var h=e[f];0<=b.indexOf(h)||(c[h]=a[h])}return c}function G(a,b){b||(b=a.slice(0));a.raw=b;return a}function H(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,
"default")?a["default"]:a}function v(a,b){return b={exports:{}},a(b,b.exports),b.exports}function I(){}function J(){}function K(a){var b,d=a.children;a=a.css;return c.jsx("div",{css:k((b={border:"1px solid #dfe2e5",borderRadius:3},b["@media (max-width: 700px)"]={borderRightWidth:0,borderLeftWidth:0},b),a)},d)}function L(a){var b,d=a.children;a=a.css;return c.jsx("div",{css:k((b={padding:10,background:"#f6f8fa",color:"#424242",border:"1px solid #d1d5da",borderTopLeftRadius:3,borderTopRightRadius:3,
margin:"-1px -1px 0",display:"flex",flexDirection:"row",alignItems:"center",justifyContent:"space-between"},b["@media (max-width: 700px)"]={paddingRight:20,paddingLeft:20},b),a)},d)}function M(a){return a&&a.map(function(a,c){return l.createElement(a.tag,r({key:c},a.attr),M(a.child))})}function w(a){return function(b){return l.createElement(fa,r({attr:r({},a.attr)},b),M(a.child))}}function fa(a){var b=function(b){var c=a.size||b.size||"1em";if(b.className)var d=b.className;a.className&&(d=(d?d+" ":
"")+a.className);var h=a.attr,p=a.title,u=ha(a,["attr","title"]);return l.createElement("svg",r({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},b.attr,h,u,{className:d,style:r({color:a.color||b.color},b.style,a.style),height:c,width:c,xmlns:"http://www.w3.org/2000/svg"}),p&&l.createElement("title",null,p),a.children)};return void 0!==N?l.createElement(N.Consumer,null,function(a){return b(a)}):b(O)}function x(a,b){var d=b.css;b=F(b,["css"]);return c.jsx(a,k({css:k({},d,{verticalAlign:"text-bottom"})},
b))}function ia(a){return x(P,a)}function ja(a){return x(Q,a)}function ka(a){return x(R,a)}function la(a){return x(S,a)}function ma(a){return x(T,a)}function na(a){var b=a.path,d=a.details,e=Object.keys(d).reduce(function(a,b){var c=a.subdirs,e=a.files;b=d[b];"directory"===b.type?c.push(b):"file"===b.type&&e.push(b);return a},{subdirs:[],files:[]});a=e.subdirs;e=e.files;a.sort(U("path"));e.sort(U("path"));var f=[];"/"!==b&&f.push(c.jsx("tr",{key:".."},c.jsx("td",{css:C}),c.jsx("td",{css:n},c.jsx("a",
{title:"Parent directory",href:"../",css:D},"..")),c.jsx("td",{css:n}),c.jsx("td",{css:E})));a.forEach(function(a){a=a.path.substr(1<b.length?b.length+1:1);var d=a+"/";f.push(c.jsx("tr",{key:a},c.jsx("td",{css:C},c.jsx(ka,null)),c.jsx("td",{css:n},c.jsx("a",{title:a,href:d,css:D},a)),c.jsx("td",{css:n},"-"),c.jsx("td",{css:E},"-")))});e.forEach(function(a){var d=a.size,e=a.contentType;a=a.path.substr(1<b.length?b.length+1:1);f.push(c.jsx("tr",{key:a},c.jsx("td",{css:C},"text/plain"===e||"text/markdown"===
e?c.jsx(ia,null):c.jsx(ja,null)),c.jsx("td",{css:n},c.jsx("a",{title:a,href:a,css:D},a)),c.jsx("td",{css:n},V(d)),c.jsx("td",{css:E},e)))});var h=[];0<e.length&&h.push(e.length+" file"+(1===e.length?"":"s"));0<a.length&&h.push(a.length+" folder"+(1===a.length?"":"s"));return c.jsx(K,null,c.jsx(L,null,c.jsx("span",null,h.join(", "))),c.jsx("table",{css:{width:"100%",borderCollapse:"collapse",borderRadius:2,background:"#fff","@media (max-width: 700px)":{"& th + th + th + th, & td + td + td + td":{display:"none"}},
"& tr:first-of-type td":{borderTop:0}}},c.jsx("thead",null,c.jsx("tr",null,c.jsx("th",null,c.jsx(y,null,"Icon")),c.jsx("th",null,c.jsx(y,null,"Name")),c.jsx("th",null,c.jsx(y,null,"Size")),c.jsx("th",null,c.jsx(y,null,"Content Type")))),c.jsx("tbody",null,f)))}function oa(a){a=a.split("/");return a[a.length-1]}function pa(a){var b=a.uri;return c.jsx("div",{css:{padding:20,textAlign:"center"}},c.jsx("img",{alt:oa(a.path),src:b}))}function qa(a){a=a.highlights.slice(0);var b=a.length&&""===a[a.length-
1];b&&a.pop();return c.jsx("div",{className:"code-listing",css:{overflowX:"auto",overflowY:"hidden",paddingTop:5,paddingBottom:5}},c.jsx("table",{css:{border:"none",borderCollapse:"collapse",borderSpacing:0}},c.jsx("tbody",null,a.map(function(a,b){var d=b+1;return c.jsx("tr",{key:b},c.jsx("td",{id:"L"+d,css:{paddingLeft:10,paddingRight:10,color:"rgba(27,31,35,.3)",textAlign:"right",verticalAlign:"top",width:"1%",minWidth:50,userSelect:"none"}},c.jsx("span",null,d)),c.jsx("td",{id:"LC"+d,css:{paddingLeft:10,
paddingRight:10,color:"#24292e",whiteSpace:"pre"}},c.jsx("code",{dangerouslySetInnerHTML:{__html:a}})))}),!b&&c.jsx("tr",{key:"no-newline"},c.jsx("td",{css:{paddingLeft:10,paddingRight:10,color:"rgba(27,31,35,.3)",textAlign:"right",verticalAlign:"top",width:"1%",minWidth:50,userSelect:"none"}},"\\"),c.jsx("td",{css:{paddingLeft:10,color:"rgba(27,31,35,.3)",userSelect:"none"}},"No newline at end of file")))))}function ra(){return c.jsx("div",{css:{padding:20}},c.jsx("p",{css:{textAlign:"center"}},
"No preview available."))}function sa(a){var b=a.packageName,d=a.packageVersion,e=a.path;a=a.details;var f=a.highlights,h=a.uri,p=a.language;return c.jsx(K,null,c.jsx(L,null,c.jsx("span",null,V(a.size)),c.jsx("span",null,p),c.jsx("span",null,c.jsx("a",{href:"/"+b+"@"+d+e,css:{display:"inline-block",marginLeft:8,padding:"2px 8px",textDecoration:"none",fontWeight:600,fontSize:"0.9rem",color:"#24292e",backgroundColor:"#eff3f6",border:"1px solid rgba(27,31,35,.2)",borderRadius:3,":hover":{backgroundColor:"#e6ebf1",
borderColor:"rgba(27,31,35,.35)"},":active":{backgroundColor:"#e9ecef",borderColor:"rgba(27,31,35,.35)",boxShadow:"inset 0 0.15em 0.3em rgba(27,31,35,.15)"}}},"View Raw"))),f?c.jsx(qa,{highlights:f}):h?c.jsx(pa,{path:e,uri:h}):c.jsx(ra,null))}function W(){var a=G(["\n  .code-listing {\n    background: #fbfdff;\n    color: #383a42;\n  }\n  .code-comment,\n  .code-quote {\n    color: #a0a1a7;\n    font-style: italic;\n  }\n  .code-doctag,\n  .code-keyword,\n  .code-link,\n  .code-formula {\n    color: #a626a4;\n  }\n  .code-section,\n  .code-name,\n  .code-selector-tag,\n  .code-deletion,\n  .code-subst {\n    color: #e45649;\n  }\n  .code-literal {\n    color: #0184bb;\n  }\n  .code-string,\n  .code-regexp,\n  .code-addition,\n  .code-attribute,\n  .code-meta-string {\n    color: #50a14f;\n  }\n  .code-built_in,\n  .code-class .code-title {\n    color: #c18401;\n  }\n  .code-attr,\n  .code-variable,\n  .code-template-variable,\n  .code-type,\n  .code-selector-class,\n  .code-selector-attr,\n  .code-selector-pseudo,\n  .code-number {\n    color: #986801;\n  }\n  .code-symbol,\n  .code-bullet,\n  .code-meta,\n  .code-selector-id,\n  .code-title {\n    color: #4078f2;\n  }\n  .code-emphasis {\n    font-style: italic;\n  }\n  .code-strong {\n    font-weight: bold;\n  }\n"]);
W=function(){return a};return a}function X(){var a=G(["\n  html {\n    box-sizing: border-box;\n  }\n  *,\n  *:before,\n  *:after {\n    box-sizing: inherit;\n  }\n\n  html,\n  body,\n  #root {\n    height: 100%;\n    margin: 0;\n  }\n\n  body {\n    ","\n    font-size: 16px;\n    line-height: 1.5;\n    overflow-wrap: break-word;\n    background: white;\n    color: black;\n  }\n\n  code {\n    ","\n  }\n\n  th,\n  td {\n    padding: 0;\n  }\n\n  select {\n    font-size: inherit;\n  }\n\n  #root {\n    display: flex;\n    flex-direction: column;\n  }\n"]);
X=function(){return a};return a}function Y(a){var b=a.css;a=F(a,["css"]);return c.jsx("a",k({},a,{css:k({color:"#0076ff",textDecoration:"none",":hover":{textDecoration:"underline"}},b)}))}function ta(){return c.jsx("header",{css:{marginTop:"2rem"}},c.jsx("h1",{css:{textAlign:"center",fontSize:"3rem",letterSpacing:"0.05em"}},c.jsx("a",{href:"/",css:{color:"#000",textDecoration:"none"}},"UNPKG")))}function ua(a){var b=a.packageName,d=a.packageVersion,e=a.availableVersions;a=a.filename;var f=[];if("/"===
a)f.push(b);else{var h="/browse/"+b+"@"+d;f.push(c.jsx(Y,{href:h+"/"},b));b=a.replace(/^\/+/,"").replace(/\/+$/,"").split("/");a=b.pop();b.forEach(function(a){h+="/"+a;f.push(c.jsx(Y,{href:h+"/"},a))});f.push(a)}return c.jsx("header",{css:{display:"flex",flexDirection:"row",alignItems:"center","@media (max-width: 700px)":{flexDirection:"column-reverse",alignItems:"flex-start"}}},c.jsx("h1",{css:{fontSize:"1.5rem",fontWeight:"normal",flex:1,wordBreak:"break-all"}},c.jsx("nav",null,f.map(function(a,
b,d){return c.jsx(l.Fragment,{key:b},0!==b&&c.jsx("span",{css:{paddingLeft:5,paddingRight:5}},"/"),b===d.length-1?c.jsx("strong",null,a):a)}))),c.jsx(va,{packageVersion:d,availableVersions:e,onChange:function(a){window.location.href=window.location.href.replace("@"+d,"@"+a)}}))}function va(a){var b=a.onChange;return c.jsx("p",{css:{marginLeft:20,"@media (max-width: 700px)":{marginLeft:0,marginBottom:0}}},c.jsx("label",null,"Version:"," ",c.jsx("select",{name:"version",defaultValue:a.packageVersion,
onChange:function(a){b&&b(a.target.value)},css:{appearance:"none",cursor:"pointer",padding:"4px 24px 4px 8px",fontWeight:600,fontSize:"0.9em",color:"#24292e",border:"1px solid rgba(27,31,35,.2)",borderRadius:3,backgroundColor:"#eff3f6",backgroundImage:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAKCAYAAAC9vt6cAAAAAXNSR0IArs4c6QAAARFJREFUKBVjZAACNS39RhBNKrh17WI9o4quoT3Dn78HSNUMUs/CzOTI/O7Vi4dCYpJ3/jP+92BkYGAlyiBGhm8MjIxJt65e3MQM0vDu9YvLYmISILYZELOBxHABRkaGr0yMzF23r12YDFIDNgDEePv65SEhEXENBkYGFSAXuyGMjF8Z/jOsvX3tYiFIDwgwQSgIaaijnvj/P8M5IO8HsjiY/f//D4b//88A1SQhywG9jQr09PS4v/1mPAeUUPzP8B8cJowMjL+Bqu6xMQmaXL164AuyDgwDQJLa2qYSP//9vARkCoMVMzK8YeVkNbh+9uxzMB+JwGoASF5Vx0jz/98/18BqmZi171w9D2EjaaYKEwAEK00XQLdJuwAAAABJRU5ErkJggg==)",
backgroundPosition:"right 8px center",backgroundRepeat:"no-repeat",backgroundSize:"auto 25%",":hover":{backgroundColor:"#e6ebf1",borderColor:"rgba(27,31,35,.35)"},":active":{backgroundColor:"#e9ecef",borderColor:"rgba(27,31,35,.35)",boxShadow:"inset 0 0.15em 0.3em rgba(27,31,35,.15)"}}},a.availableVersions.map(function(a){return c.jsx("option",{key:a,value:a},a)}))))}function wa(a){var b=a.packageName,d=a.packageVersion;a=a.target;return"directory"===a.type?c.jsx(na,{path:a.path,details:a.details}):
"file"===a.type?c.jsx(sa,{packageName:b,packageVersion:d,path:a.path,details:a.details}):null}var Z="default"in l?l["default"]:l;t=t&&t.hasOwnProperty("default")?t["default"]:t;var xa="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},aa=v(function(a,b){function c(a){if("object"===typeof a&&null!==a){var b=a.$$typeof;switch(b){case f:switch(a=a.type,a){case q:case g:case p:case l:case u:case z:return a;
default:switch(a=a&&a.$$typeof,a){case m:case A:case k:return a;default:return b}}case n:case B:case h:return b}}}function e(a){return c(a)===g}Object.defineProperty(b,"__esModule",{value:!0});var f=(a="function"===typeof Symbol&&Symbol.for)?Symbol.for("react.element"):60103,h=a?Symbol.for("react.portal"):60106,p=a?Symbol.for("react.fragment"):60107,u=a?Symbol.for("react.strict_mode"):60108,l=a?Symbol.for("react.profiler"):60114,k=a?Symbol.for("react.provider"):60109,m=a?Symbol.for("react.context"):
60110,q=a?Symbol.for("react.async_mode"):60111,g=a?Symbol.for("react.concurrent_mode"):60111,A=a?Symbol.for("react.forward_ref"):60112,z=a?Symbol.for("react.suspense"):60113,B=a?Symbol.for("react.memo"):60115,n=a?Symbol.for("react.lazy"):60116;b.typeOf=c;b.AsyncMode=q;b.ConcurrentMode=g;b.ContextConsumer=m;b.ContextProvider=k;b.Element=f;b.ForwardRef=A;b.Fragment=p;b.Lazy=n;b.Memo=B;b.Portal=h;b.Profiler=l;b.StrictMode=u;b.Suspense=z;b.isValidElementType=function(a){return"string"===typeof a||"function"===
typeof a||a===p||a===g||a===l||a===u||a===z||"object"===typeof a&&null!==a&&(a.$$typeof===n||a.$$typeof===B||a.$$typeof===k||a.$$typeof===m||a.$$typeof===A)};b.isAsyncMode=function(a){return e(a)||c(a)===q};b.isConcurrentMode=e;b.isContextConsumer=function(a){return c(a)===m};b.isContextProvider=function(a){return c(a)===k};b.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===f};b.isForwardRef=function(a){return c(a)===A};b.isFragment=function(a){return c(a)===p};b.isLazy=function(a){return c(a)===
n};b.isMemo=function(a){return c(a)===B};b.isPortal=function(a){return c(a)===h};b.isProfiler=function(a){return c(a)===l};b.isStrictMode=function(a){return c(a)===u};b.isSuspense=function(a){return c(a)===z}});H(aa);var ya=v(function(a,b){});H(ya);v(function(a){a.exports=aa});(function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;
var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(e){return!1}})();Function.call.bind(Object.prototype.hasOwnProperty);J.resetWarningCache=I;var za=function(){function a(a,b,c,d,l,k){if("SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"!==k)throw a=Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"),
a.name="Invariant Violation",a;}function b(){return a}a.isRequired=a;var c={array:a,bool:a,func:a,number:a,object:a,string:a,symbol:a,any:a,arrayOf:b,element:a,elementType:a,instanceOf:b,node:a,objectOf:b,oneOf:b,oneOfType:b,shape:b,exact:b,checkPropTypes:J,resetWarningCache:I};return c.PropTypes=c};v(function(a){a.exports=za()});var Aa=Object.assign||function(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],e;for(e in c)Object.prototype.hasOwnProperty.call(c,e)&&(a[e]=c[e])}return a},Ba=
{border:0,clip:"rect(0 0 0 0)",height:"1px",width:"1px",margin:"-1px",padding:0,overflow:"hidden",position:"absolute"},y=function(a){return Z.createElement("div",Aa({style:Ba},a))},ba=v(function(a){(function(b,c){a.exports=c()})(xa,function(){function a(a){if(!a)return!0;if(!f(a)||0!==a.length)for(var b in a)if(n.call(a,b))return!1;return!0}function c(a){return"number"===typeof a||"[object Number]"===k.call(a)}function e(a){return"string"===typeof a||"[object String]"===k.call(a)}function f(a){return"object"===
typeof a&&"number"===typeof a.length&&"[object Array]"===k.call(a)}function h(a){var b=parseInt(a);return b.toString()===a?b:a}function p(b,g,d,f){c(g)&&(g=[g]);if(a(g))return b;if(e(g))return p(b,g.split("."),d,f);var q=h(g[0]);if(1===g.length)return g=b[q],void 0!==g&&f||(b[q]=d),g;void 0===b[q]&&(c(q)?b[q]=[]:b[q]={});return p(b[q],g.slice(1),d,f)}function l(b,d){c(d)&&(d=[d]);if(!a(b)){if(a(d))return b;if(e(d))return l(b,d.split("."));var g=h(d[0]),q=b[g];if(1===d.length)void 0!==q&&(f(b)?b.splice(g,
1):delete b[g]);else if(void 0!==b[g])return l(b[g],d.slice(1));return b}}var k=Object.prototype.toString,n=Object.prototype.hasOwnProperty,m={ensureExists:function(a,b,c){return p(a,b,c,!0)},set:function(a,b,c,d){return p(a,b,c,d)},insert:function(a,b,c,d){var e=m.get(a,b);d=~~d;f(e)||(e=[],m.set(a,b,e));e.splice(d,0,c)},empty:function(b,d){if(a(d))return b;if(!a(b)){var g,h;if(!(g=m.get(b,d)))return b;if(e(g))return m.set(b,d,"");if("boolean"===typeof g||"[object Boolean]"===k.call(g))return m.set(b,
d,!1);if(c(g))return m.set(b,d,0);if(f(g))g.length=0;else if("object"===typeof g&&"[object Object]"===k.call(g))for(h in g)n.call(g,h)&&delete g[h];else return m.set(b,d,null)}},push:function(a,b){var c=m.get(a,b);f(c)||(c=[],m.set(a,b,c));c.push.apply(c,Array.prototype.slice.call(arguments,2))},coalesce:function(a,b,c){for(var d,e=0,f=b.length;e<f;e++)if(void 0!==(d=m.get(a,b[e])))return d;return c},get:function(b,d,f){c(d)&&(d=[d]);if(a(d))return b;if(a(b))return f;if(e(d))return m.get(b,d.split("."),
f);var g=h(d[0]);return 1===d.length?void 0===b[g]?f:b[g]:m.get(b[g],d.slice(1),f)},del:function(a,b){return l(a,b)}};return m})});var ca=function(a){return function(b){return typeof b===a}};var Ca=function(a,b){var c=1,e=b||function(a,b){return b};"-"===a[0]&&(c=-1,a=a.substr(1));return function(b,d){var f;b=e(a,ba.get(b,a));d=e(a,ba.get(d,a));b<d&&(f=-1);b>d&&(f=1);b===d&&(f=0);return f*c}};var U=function(){var a=Array.prototype.slice.call(arguments),b=a.filter(ca("string")),c=a.filter(ca("function"))[0];
return function(a,d){for(var e=b.length,f=0,k=0;0===f&&k<e;)f=Ca(b[k],c)(a,d),k++;return f}};let da="B kB MB GB TB PB EB ZB YB".split(" "),ea=(a,b)=>{let c=a;"string"===typeof b?c=a.toLocaleString(b):!0===b&&(c=a.toLocaleString());return c};var V=(a,b)=>{if(!Number.isFinite(a))throw new TypeError(`Expected a finite number, got ${typeof a}: ${a}`);b=Object.assign({},b);if(b.signed&&0===a)return" 0 B";var c=0>a;let e=c?"-":b.signed?"+":"";c&&(a=-a);if(1>a)return a=ea(a,b.locale),e+a+" B";c=Math.min(Math.floor(Math.log10(a)/
3),da.length-1);a=Number((a/Math.pow(1E3,c)).toPrecision(3));a=ea(a,b.locale);return e+a+" "+da[c]},O={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},N=l.createContext&&l.createContext(O),r=window&&window.__assign||function(){r=Object.assign||function(a){for(var b,c=1,e=arguments.length;c<e;c++){b=arguments[c];for(var f in b)Object.prototype.hasOwnProperty.call(b,f)&&(a[f]=b[f])}return a};return r.apply(this,arguments)},ha=window&&window.__rest||function(a,b){var c={},e;for(e in a)Object.prototype.hasOwnProperty.call(a,
e)&&0>b.indexOf(e)&&(c[e]=a[e]);if(null!=a&&"function"===typeof Object.getOwnPropertySymbols){var f=0;for(e=Object.getOwnPropertySymbols(a);f<e.length;f++)0>b.indexOf(e[f])&&(c[e[f]]=a[e[f]])}return c},Q=function(a){return w({tag:"svg",attr:{viewBox:"0 0 12 16"},child:[{tag:"path",attr:{fillRule:"evenodd",d:"M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM5 6.98L3.5 8.5 5 10l-.5 1L2 8.5 4.5 6l.5.98zM7.5 6L10 8.5 7.5 11l-.5-.98L8.5 8.5 7 7l.5-1z"}}]})(a)};
Q.displayName="GoFileCode";var R=function(a){return w({tag:"svg",attr:{viewBox:"0 0 14 16"},child:[{tag:"path",attr:{fillRule:"evenodd",d:"M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z"}}]})(a)};R.displayName="GoFileDirectory";var P=function(a){return w({tag:"svg",attr:{viewBox:"0 0 12 16"},child:[{tag:"path",attr:{fillRule:"evenodd",d:"M6 5H2V4h4v1zM2 8h7V7H2v1zm0 2h7V9H2v1zm0 2h7v-1H2v1zm10-7.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v12h10V5z"}}]})(a)};
P.displayName="GoFile";var T=function(a){return w({tag:"svg",attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"}}]})(a)};
T.displayName="FaGithub";var S=function(a){return w({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"}}]})(a)};
S.displayName="FaTwitter";var D={color:"#0076ff",textDecoration:"none",":hover":{textDecoration:"underline"}},n={paddingTop:6,paddingRight:3,paddingBottom:6,paddingLeft:3,borderTop:"1px solid #eaecef"},C=k({},n,{color:"#424242",width:17,paddingRight:2,paddingLeft:10,"@media (max-width: 700px)":{paddingLeft:20}}),E=k({},n,{textAlign:"right",paddingRight:10,"@media (max-width: 700px)":{paddingRight:20}}),Da=c.css(X(),'\nfont-family: -apple-system,\n  BlinkMacSystemFont,\n  "Segoe UI",\n  "Roboto",\n  "Oxygen",\n  "Ubuntu",\n  "Cantarell",\n  "Fira Sans",\n  "Droid Sans",\n  "Helvetica Neue",\n  sans-serif;\n',
"\nfont-family: Menlo,\n  Monaco,\n  Lucida Console,\n  Liberation Mono,\n  DejaVu Sans Mono,\n  Bitstream Vera Sans Mono,\n  Courier New,\n  monospace;\n"),Ea=c.css(W());t.hydrate(Z.createElement(function(a){var b=a.packageName,d=a.packageVersion,e=a.availableVersions;e=void 0===e?[]:e;var f=a.filename;a=a.target;return c.jsx(l.Fragment,null,c.jsx(c.Global,{styles:Da}),c.jsx(c.Global,{styles:Ea}),c.jsx("div",{css:{flex:"1 0 auto"}},c.jsx("div",{css:{maxWidth:940,padding:"0 20px",margin:"0 auto"}},
c.jsx(ta,null)),c.jsx("div",{css:{maxWidth:940,padding:"0 20px",margin:"0 auto"}},c.jsx(ua,{packageName:b,packageVersion:d,availableVersions:e,filename:f})),c.jsx("div",{css:{maxWidth:940,padding:"0 20px",margin:"0 auto","@media (max-width: 700px)":{padding:0,margin:0}}},c.jsx(wa,{packageName:b,packageVersion:d,target:a}))),c.jsx("footer",{css:{marginTop:"5rem",background:"black",color:"#aaa"}},c.jsx("div",{css:{maxWidth:940,padding:"10px 20px",margin:"0 auto",display:"flex",flexDirection:"row",alignItems:"center",
justifyContent:"space-between"}},c.jsx("p",null,c.jsx("span",null,"Build: ","b5d1b223")),c.jsx("p",null,c.jsx("span",null,"\u00a9 ",(new Date).getFullYear()," UNPKG")),c.jsx("p",{css:{fontSize:"1.5rem"}},c.jsx("a",{href:"https://twitter.com/unpkg",css:{color:"#aaa",display:"inline-block",":hover":{color:"white"}}},c.jsx(la,null)),c.jsx("a",{href:"https://github.com/mjackson/unpkg",css:{color:"#aaa",display:"inline-block",":hover":{color:"white"},marginLeft:"1rem"}},c.jsx(ma,null))))))},window.__DATA__||
{}),document.getElementById("root"))})(React,ReactDOM,emotionCore);
</script></body></html>